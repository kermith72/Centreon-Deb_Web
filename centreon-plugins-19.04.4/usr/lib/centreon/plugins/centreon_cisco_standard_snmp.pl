#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"centreon/common/cisco/standard/snmp/mode/components/fan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_FAN';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::components::fan;
  
  use strict;
  use warnings;
  
  my %map_fan_state1 = (
      1 => 'normal', 
      2 => 'warning', 
      3 => 'critical', 
      4 => 'shutdown',
      5 => 'not present',
      6 => 'not functioning',
  );
  my %map_fan_state2 = (
      1 => 'unknown',
      2 => 'up',
      3 => 'down',
      4 => 'warning',
  );
  
  my $oid_ciscoEnvMonFanStatusEntry = '.1.3.6.1.4.1.9.9.13.1.4.1'; # CISCO-ENVMON-MIB
  my $oid_cefcFanTrayOperStatus = '.1.3.6.1.4.1.9.9.117.1.4.1.1.1'; # CISCO-ENTITY-SENSOR-MIB
  my $oid_entPhysicalDescr = '.1.3.6.1.2.1.47.1.1.1.1.2';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_ciscoEnvMonFanStatusEntry }, { oid => $oid_cefcFanTrayOperStatus };
  }
  
  sub check_fan_envmon {
      my ($self) = @_;
  
      my $mapping = {
          ciscoEnvMonFanStatusDescr => { oid => '.1.3.6.1.4.1.9.9.13.1.4.1.2' },
          ciscoEnvMonFanState => { oid => '.1.3.6.1.4.1.9.9.13.1.4.1.3', map => \%map_fan_state1 },
      };
      
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_ciscoEnvMonFanStatusEntry}})) {
          next if ($oid !~ /^$mapping->{ciscoEnvMonFanStatusDescr}->{oid}\./);
          $oid =~ /\.([0-9]+)$/;
          my $instance = $1;
  
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_ciscoEnvMonFanStatusEntry}, instance => $instance);
  
          next if ($self->check_filter(section => 'fan', instance => $instance));
          next if ($result->{ciscoEnvMonFanState} =~ /not present/i && 
                   $self->absent_problem(section => 'fan', instance => $instance));
          $self->{components}->{fan}->{total}++;
  
          $self->{output}->output_add(long_msg => sprintf("fan '%s' status is %s [instance: %s].",
                                      $result->{ciscoEnvMonFanStatusDescr}, $result->{ciscoEnvMonFanState},
                                      $instance
                                      ));
          my $exit = $self->get_severity(section => 'fan', value => $result->{ciscoEnvMonFanState});
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity =>  $exit,
                                          short_msg => sprintf("fan '%s' status is %s",
                                                               $result->{ciscoEnvMonFanStatusDescr}, $result->{ciscoEnvMonFanState}));
          }
      }
  }
  
  sub check_fan_entity {
      my ($self) = @_;
      
      my $mapping = {
          cefcFanTrayOperStatus => { oid => '.1.3.6.1.4.1.9.9.117.1.4.1.1.1', map => \%map_fan_state2 },
      };
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_cefcFanTrayOperStatus}})) {
          $oid =~ /\.([0-9]+)$/;
          my $instance = $1;
          
          my $fan_descr = $self->{results}->{$oid_entPhysicalDescr}->{$oid_entPhysicalDescr . '.' . $instance};
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_cefcFanTrayOperStatus}, instance => $instance);
          
          next if ($self->check_filter(section => 'fan', instance => $instance));
          
          $self->{components}->{fan}->{total}++;
          $self->{output}->output_add(long_msg => sprintf("Fan '%s' status is %s [instance: %s]",
                                      $fan_descr, $result->{cefcFanTrayOperStatus}, $instance));
          my $exit = $self->get_severity(section => 'fan', value => $result->{cefcFanTrayOperStatus});
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Fan '%s/%s' status is %s", $fan_descr, $instance, $result->{cefcFanTrayOperStatus}));
          }
      }
  }
  
  sub check {
      my ($self) = @_;
      
      $self->{output}->output_add(long_msg => "Checking fans");
      $self->{components}->{fan} = {name => 'fans', total => 0, skip => 0};
      return if ($self->check_filter(section => 'fan'));
  
      check_fan_envmon($self);
      check_fan_entity($self);
  }
  
  1;
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_FAN

$fatpacked{"centreon/common/cisco/standard/snmp/mode/components/module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_MODULE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::components::module;
  
  use strict;
  use warnings;
  
  my %map_module_state = (
      1 => 'unknown',
      2 => 'ok',
      3 => 'disabled',
      4 => 'okButDiagFailed',
      5 => 'boot',
      6 => 'selfTest',
      7 => 'failed',
      8 => 'missing',
      9 => 'mismatchWithParent',
      10 => 'mismatchConfig',
      11 => 'diagFailed',
      12 => 'dormant',
      13 => 'outOfServiceAdmin',
      14 => 'outOfServiceEnvTemp',
      15 => 'poweredDown',
      16 => 'poweredUp',
      17 => 'powerDenied',
      18 => 'powerCycled',
      19 => 'okButPowerOverWarning',
      20 => 'okButPowerOverCritical',
      21 => 'syncInProgress',
      22 => 'upgrading',
      23 => 'okButAuthFailed',
      24 => 'mdr',
      25 => 'fwMismatchFound',
      26 => 'fwDownloadSuccess',
      27 => 'fwDownloadFailure',
  );
  
  # In MIB 'CISCO-ENTITY-FRU-CONTROL-MIB'
  my $mapping = {
      cefcModuleOperStatus => { oid => '.1.3.6.1.4.1.9.9.117.1.2.1.1.2', map => \%map_module_state },
  };
  my $oid_cefcModuleOperStatus = '.1.3.6.1.4.1.9.9.117.1.2.1.1.2';
  my $oid_entPhysicalDescr = '.1.3.6.1.2.1.47.1.1.1.1.2';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_cefcModuleOperStatus };
  }
  
  sub check {
      my ($self) = @_;
      
      $self->{output}->output_add(long_msg => "Checking modules");
      $self->{components}->{module} = {name => 'modules', total => 0, skip => 0};
      return if ($self->check_filter(section => 'module'));
  
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_cefcModuleOperStatus}})) {
          $oid =~ /\.([0-9]+)$/;
          my $instance = $1;
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_cefcModuleOperStatus}, instance => $instance);
          my $module_descr = $self->{results}->{$oid_entPhysicalDescr}->{$oid_entPhysicalDescr . '.' . $instance};
          
          next if ($self->check_filter(section => 'module', instance => $instance));
          
          $self->{components}->{module}->{total}++;
          $self->{output}->output_add(long_msg => sprintf("Module '%s' status is %s [instance: %s]",
                                      $module_descr, $result->{cefcModuleOperStatus}, $instance));
          my $exit = $self->get_severity(section => 'module', value => $result->{cefcModuleOperStatus});
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Module '%s/%s' status is %s", $module_descr, 
                                                          $instance, $result->{cefcModuleOperStatus}));
          }
      }
  }
  
  1;
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_MODULE

$fatpacked{"centreon/common/cisco/standard/snmp/mode/components/physical.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_PHYSICAL';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::components::physical;
  
  use strict;
  use warnings;
  
  my %map_physical_state = (
      1 => 'other',
      2 => 'supported',
      3 => 'unsupported',
      4 => 'incompatible',
  );
  
  # In MIB 'CISCO-ENTITY-SENSOR-MIB'
  my $mapping = {
      cefcPhysicalStatus => { oid => '.1.3.6.1.4.1.9.9.117.1.5.1.1.1', map => \%map_physical_state },
  };
  my $oid_cefcPhysicalStatus = '.1.3.6.1.4.1.9.9.117.1.5.1.1.1';
  my $oid_entPhysicalDescr = '.1.3.6.1.2.1.47.1.1.1.1.2';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_cefcPhysicalStatus };
  }
  
  sub check {
      my ($self) = @_;
      
      $self->{output}->output_add(long_msg => "Checking physicals");
      $self->{components}->{physical} = {name => 'physical', total => 0, skip => 0};
      return if ($self->check_filter(section => 'physical'));
  
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_cefcPhysicalStatus}})) {
          $oid =~ /\.([0-9]+)$/;
          my $instance = $1;
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_cefcPhysicalStatus}, instance => $instance);
          my $physical_descr = $self->{results}->{$oid_entPhysicalDescr}->{$oid_entPhysicalDescr . '.' . $instance};
          
          if (!defined($physical_descr)) {
              $self->{output}->output_add(long_msg => sprintf("skipped instance '%s': no description", $instance));
              next;
          }
          
          next if ($self->check_filter(section => 'physical', instance => $instance));
          
          $self->{components}->{physical}->{total}++;
          $self->{output}->output_add(long_msg => sprintf("Physical '%s' status is %s [instance: %s]",
                                      $physical_descr, $result->{cefcPhysicalStatus}, $instance));
          my $exit = $self->get_severity(section => 'physical', value => $result->{cefcPhysicalStatus});
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Physical '%s/%s' status is %s", $physical_descr, 
                                                                  $instance, $result->{cefcPhysicalStatus}));
          }
      }
  }
  
  1;
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_PHYSICAL

$fatpacked{"centreon/common/cisco/standard/snmp/mode/components/psu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_PSU';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::components::psu;
  
  use strict;
  use warnings;
  
  my %map_psu_source = (
      1 => 'unknown',
      2 => 'ac',
      3 => 'dc',
      4 => 'externalPowerSupply',
      5 => 'internalRedundant'
  );
  my %map_psu_state1 = (
      1 => 'normal', 
      2 => 'warning', 
      3 => 'critical', 
      4 => 'shutdown',
      5 => 'not present',
      6 => 'not functioning',
  );
  my %map_psu_state2 = (
      1 => 'offEnvOther',
      2 => 'on',
      3 => 'offAdmin',
      4 => 'offDenied',
      5 => 'offEnvPower',
      6 => 'offEnvTemp',
      7 => 'offEnvFan',
      8 => 'failed',
      9 => 'onButFanFail',
      10 => 'offCooling',
      11 => 'offConnectorRating',
      12 => 'onButInlinePowerFail',
  );
  
  my $oid_ciscoEnvMonSupplyStatusEntry = '.1.3.6.1.4.1.9.9.13.1.5.1'; # CISCO-ENVMON-MIB
  my $oid_cefcFRUPowerOperStatus = '.1.3.6.1.4.1.9.9.117.1.1.2.1.2'; # CISCO-ENTITY-SENSOR-MIB
  my $oid_entPhysicalDescr = '.1.3.6.1.2.1.47.1.1.1.1.2';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_ciscoEnvMonSupplyStatusEntry }, { oid => $oid_cefcFRUPowerOperStatus };
  }
  
  sub check_psu_envmon {
      my ($self) = @_;
  
      my $mapping = {
          ciscoEnvMonSupplyStatusDescr => { oid => '.1.3.6.1.4.1.9.9.13.1.5.1.2' },
          ciscoEnvMonSupplyState => { oid => '.1.3.6.1.4.1.9.9.13.1.5.1.3', map => \%map_psu_state1 },
          ciscoEnvMonSupplySource => { oid => '.1.3.6.1.4.1.9.9.13.1.5.1.4', map => \%map_psu_source },
      };
      
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_ciscoEnvMonSupplyStatusEntry}})) {
          next if ($oid !~ /^$mapping->{ciscoEnvMonSupplyStatusDescr}->{oid}\./);
          $oid =~ /\.([0-9]+)$/;
          my $instance = $1;
  
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_ciscoEnvMonSupplyStatusEntry}, instance => $instance);
  
          next if ($self->check_filter(section => 'psu', instance => $instance));
          next if ($result->{ciscoEnvMonSupplyState} =~ /not present/i && 
                   $self->absent_problem(section => 'psu', instance => $instance));
          $self->{components}->{psu}->{total}++;
  
          $self->{output}->output_add(long_msg => sprintf("Power supply '%s' status is %s [instance: %s] [source: %s]",
                                      $result->{ciscoEnvMonSupplyStatusDescr}, $result->{ciscoEnvMonSupplyState},
                                      $instance, $result->{ciscoEnvMonSupplySource}
                                      ));
          my $exit = $self->get_severity(section => 'psu', value => $result->{ciscoEnvMonSupplyState});
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity =>  $exit,
                                          short_msg => sprintf("Power supply '%s' status is %s",
                                                               $result->{ciscoEnvMonSupplyStatusDescr}, $result->{ciscoEnvMonSupplyState}));
          }
      }
  }
  
  sub check_psu_entity {
      my ($self) = @_;
      
      my $mapping = {
          cefcFRUPowerOperStatus => { oid => '.1.3.6.1.4.1.9.9.117.1.1.2.1.2', map => \%map_psu_state2 },
      };
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_cefcFRUPowerOperStatus}})) {
          $oid =~ /\.([0-9]+)$/;
          my $instance = $1;
          
          my $psu_descr = $self->{results}->{$oid_entPhysicalDescr}->{$oid_entPhysicalDescr . '.' . $instance};
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_cefcFRUPowerOperStatus}, instance => $instance);
          
          next if ($self->check_filter(section => 'psu', instance => $instance));
          
          $self->{components}->{psu}->{total}++;
          $self->{output}->output_add(long_msg => sprintf("Power supply '%s' status is %s [instance: %s]",
                                      $psu_descr, $result->{cefcFRUPowerOperStatus}, $instance));
          my $exit = $self->get_severity(section => 'psu', value => $result->{cefcFRUPowerOperStatus});
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Power supply '%s/%s' status is %s", $psu_descr, $instance, $result->{cefcFRUPowerOperStatus}));
          }
      }
  }
  
  sub check {
      my ($self) = @_;
      
      $self->{output}->output_add(long_msg => "Checking power supplies");
      $self->{components}->{psu} = {name => 'psus', total => 0, skip => 0};
      return if ($self->check_filter(section => 'psu'));
  
      check_psu_envmon($self);
      check_psu_entity($self);
  }
  
  1;
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_PSU

$fatpacked{"centreon/common/cisco/standard/snmp/mode/components/sensor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_SENSOR';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::components::sensor;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  my %map_sensor_status = (
      1 => 'ok',
      2 => 'unavailable',
      3 => 'nonoperational',
  );
  my %map_sensor_type = (
      1 => 'other',
      2 => 'unknown',
      3 => 'voltsAC',
      4 => 'voltsDC',
      5 => 'amperes',
      6 => 'watts',
      7 => 'hertz',
      8 => 'celsius',
      9 => 'percentRH',
      10 => 'rpm',
      11 => 'cmm',
      12 => 'truthvalue',
      13 => 'specialEnum',
      14 => 'dBm',
  );
  my %map_scale = (
      1 => -24, # yocto, 
      2 => -21, # zepto
      3 => -18, # atto
      4 => -15, # femto 
      5 => -12, # pico
      6 => -9, # nano
      7 => -6, # micro
      8 => -3, # milli
      9 => 0, #units
      10 => 3, #kilo
      11 => 6, #mega
      12 => 9, #giga
      13 => 12, #tera
      14 => 18, #exa
      15 => 15, #peta
      16 => 21, #zetta
      17 => 24, #yotta
  );
  my %map_severity = (
      1 => 'other',
      10 => 'minor',
      20 => 'major',
      30 => 'critical',
  );
  my %map_relation = (
      1 => 'lessThan',
      2 => 'lessOrEqual',
      3 => 'greaterThan',
      4 => 'greaterOrEqual',
      5 => 'equalTo',
      6 => 'notEqualTo',
  );
  my %perfdata_unit = (
      'other' => '',
      'unknown' => '',
      'voltsAC' => 'V',
      'voltsDC' => 'V',
      'amperes' => 'A',
      'watts' => 'W',
      'hertz' => 'Hz',
      'celsius' => 'C',
      'percentRH' => '%',
      'rpm' => 'rpm',
      'cmm' => '',
      'truthvalue' => '',
      'specialEnum' => '',
      'dBm' => 'dBm',
  );
  
  # In MIB 'CISCO-ENTITY-SENSOR-MIB'
  my $mapping = {
      entSensorType => { oid => '.1.3.6.1.4.1.9.9.91.1.1.1.1.1', map => \%map_sensor_type },
      entSensorScale => { oid => '.1.3.6.1.4.1.9.9.91.1.1.1.1.2', map => \%map_scale },
      entSensorPrecision => { oid => '.1.3.6.1.4.1.9.9.91.1.1.1.1.3' },
      entSensorValue => { oid => '.1.3.6.1.4.1.9.9.91.1.1.1.1.4' },
      entSensorStatus => { oid => '.1.3.6.1.4.1.9.9.91.1.1.1.1.5', map => \%map_sensor_status },
  };
  my $mapping2 = {
      entSensorThresholdSeverity => { oid => '.1.3.6.1.4.1.9.9.91.1.2.1.1.2', map => \%map_severity },
      entSensorThresholdRelation => { oid => '.1.3.6.1.4.1.9.9.91.1.2.1.1.3', map => \%map_relation },
      entSensorThresholdValue => { oid => '.1.3.6.1.4.1.9.9.91.1.2.1.1.4' },
  };
  my $oid_entSensorValueEntry = '.1.3.6.1.4.1.9.9.91.1.1.1.1';
  my $oid_entSensorThresholdEntry = '.1.3.6.1.4.1.9.9.91.1.2.1.1';
  my $oid_entPhysicalDescr = '.1.3.6.1.2.1.47.1.1.1.1.2';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_entSensorValueEntry, end => $mapping->{entSensorStatus}->{oid} }, 
          { oid => $oid_entSensorThresholdEntry, end => $mapping2->{entSensorThresholdValue}->{oid} };
  }
  
  sub get_default_warning_threshold {
      my ($self, %options) = @_;
      my ($high_th, $low_th);
  
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_entSensorThresholdEntry}})) {
          next if ($oid !~ /^$mapping2->{entSensorThresholdSeverity}->{oid}\.$options{instance}\.(.*)$/);
          my $instance = $1;
          my $result = $self->{snmp}->map_instance(mapping => $mapping2, results => $self->{results}->{$oid_entSensorThresholdEntry}, instance => $options{instance} . '.' . $instance);
          next if ($result->{entSensorThresholdSeverity} ne 'minor');
  
          my $value = $result->{entSensorThresholdValue} * (10 ** ($options{result}->{entSensorScale}) * (10 ** -($options{result}->{entSensorPrecision})));
          if ($result->{entSensorThresholdRelation} eq 'greaterOrEqual') {
              $high_th = $value - (1 * (10 ** ($options{result}->{entSensorScale}) * (10 ** -($options{result}->{entSensorPrecision}))));
          } elsif ($result->{entSensorThresholdRelation} eq 'greaterThan') {
              $high_th = $value;
          } elsif ($result->{entSensorThresholdRelation} eq 'lessOrEqual') {
              $low_th = $value + (1 * (10 ** ($options{result}->{entSensorScale}) * (10 ** -($options{result}->{entSensorPrecision}))));
          } elsif ($result->{entSensorThresholdRelation} eq 'lessThan') {
              $low_th = $value;
          }
      }
      
      # when it's the same value. Means no threshold.
      if (defined($low_th) && defined($high_th) && $high_th <= $low_th) {
          return '';
      }
      my $th = '';
      $th = centreon::plugins::misc::expand_exponential(value => $low_th) . ':' if (defined($low_th));
      $th .= centreon::plugins::misc::expand_exponential(value => $high_th) if (defined($high_th));
  
      return $th;
  }
  
  sub get_default_critical_threshold {
      my ($self, %options) = @_;
      my ($high_th, $low_th);
  
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_entSensorThresholdEntry}})) {
          next if ($oid !~ /^$mapping2->{entSensorThresholdSeverity}->{oid}\.$options{instance}\.(.*)$/);
          my $instance = $1;
          my $result = $self->{snmp}->map_instance(mapping => $mapping2, results => $self->{results}->{$oid_entSensorThresholdEntry}, instance => $options{instance} . '.' . $instance);
          next if ($result->{entSensorThresholdSeverity} !~ /major|critical/);
          
          my $value = $result->{entSensorThresholdValue} * (10 ** ($options{result}->{entSensorScale}) * (10 ** -($options{result}->{entSensorPrecision})));
          if ($result->{entSensorThresholdRelation} eq 'greaterOrEqual') {
              $high_th = $value - (1 * (10 ** ($options{result}->{entSensorScale}) * (10 ** -($options{result}->{entSensorPrecision}))));
          } elsif ($result->{entSensorThresholdRelation} eq 'greaterThan') {
              $high_th = $value;
          } elsif ($result->{entSensorThresholdRelation} eq 'lessOrEqual') {
              $low_th = $value + (1 * (10 ** ($options{result}->{entSensorScale}) * (10 ** -($options{result}->{entSensorPrecision}))));
          } elsif ($result->{entSensorThresholdRelation} eq 'lessThan') {
              $low_th = $value;
          }
      }
  
      # when it's the same value. Means no threshold.
      if (defined($low_th) && defined($high_th) && $high_th <= $low_th) {
          return '';
      }
      my $th = '';
      $th = centreon::plugins::misc::expand_exponential(value => $low_th) . ':' if (defined($low_th));
      $th .= centreon::plugins::misc::expand_exponential(value => $high_th) if (defined($high_th));
      
      return $th;
  }
  
  sub check {
      my ($self) = @_;
      
      $self->{output}->output_add(long_msg => "Checking sensors");
      $self->{components}->{sensor} = {name => 'sensors', total => 0, skip => 0};
      return if ($self->check_filter(section => 'sensor'));
      
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_entSensorValueEntry}})) {
          next if ($oid !~ /^$mapping->{entSensorStatus}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_entSensorValueEntry}, instance => $instance);
          
          next if (!defined($self->{results}->{$oid_entPhysicalDescr}->{$oid_entPhysicalDescr . '.' . $instance}));
          my $sensor_descr = $self->{results}->{$oid_entPhysicalDescr}->{$oid_entPhysicalDescr . '.' . $instance};
          
          next if ($self->check_filter(section => 'sensor', instance => $result->{entSensorType} . '.' . $instance));
          $self->{components}->{sensor}->{total}++;
  
          $result->{entSensorValue} = defined($result->{entSensorValue}) ? 
             $result->{entSensorValue} * (10 ** ($result->{entSensorScale}) * (10 ** -($result->{entSensorPrecision}))) : undef;
          
          $self->{output}->output_add(long_msg => sprintf("Sensor '%s' status is '%s' [instance: %s] [value: %s %s]", 
                                      $sensor_descr, $result->{entSensorStatus},
                                      $instance, 
                                      defined($result->{entSensorValue}) ? $result->{entSensorValue} : '-',
                                      $result->{entSensorType}));
          my $exit = $self->get_severity(section => $result->{entSensorType}, label => 'sensor', value => $result->{entSensorStatus});
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Sensor '%s/%s' status is '%s'", 
                                                               $sensor_descr, $instance, $result->{entSensorStatus}));
          }
       
          next if (!defined($result->{entSensorValue}) || $result->{entSensorValue} !~ /[0-9]/);
          
          my $component = 'sensor.' . $result->{entSensorType};
          my ($exit2, $warn, $crit, $checked) = $self->get_severity_numeric(section => $component, instance => $instance, value => $result->{entSensorValue});
          if ($checked == 0) {
              my $warn_th = get_default_warning_threshold($self, instance => $instance, result => $result);
              my $crit_th = get_default_critical_threshold($self, instance => $instance, result => $result);
              $self->{perfdata}->threshold_validate(label => 'warning-' . $component . '-instance-' . $instance, value => $warn_th);
              $self->{perfdata}->threshold_validate(label => 'critical-' . $component . '-instance-' . $instance, value => $crit_th);
              $warn = $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $component . '-instance-' . $instance);
              $crit = $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $component  . '-instance-' . $instance);
              $exit2 = $self->{perfdata}->threshold_check(
                  value => $result->{entSensorValue}, 
                  threshold => [ { label => 'critical-' . $component  . '-instance-' . $instance, exit_litteral => 'critical' }, 
                                 { label => 'warning-' . $component . '-instance-' . $instance, exit_litteral => 'warning' }
                  ]
              );
          }
          if (!$self->{output}->is_status(value => $exit2, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit2,
                                          short_msg => sprintf("Sensor '%s/%s' is %s %s", $sensor_descr, $instance, $result->{entSensorValue}, $perfdata_unit{$result->{entSensorType}}));
          }
          $self->{output}->perfdata_add(
              label => $component, unit => $perfdata_unit{$result->{entSensorType}},
              nlabel => 'hardware.' . $component, 
              instances => $sensor_descr,
              value => $result->{entSensorValue},
              warning => $warn,
              critical => $crit
          );
      }
  }
  
  1;
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_SENSOR

$fatpacked{"centreon/common/cisco/standard/snmp/mode/components/temperature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_TEMPERATURE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::components::temperature;
  
  use strict;
  use warnings;
  
  my %map_temperature_state = (
      1 => 'normal', 
      2 => 'warning', 
      3 => 'critical', 
      4 => 'shutdown',
      5 => 'not present',
      6 => 'not functioning',
  );
  
  # In MIB 'CISCO-ENVMON-MIB'
  my $mapping = {
      ciscoEnvMonTemperatureStatusDescr => { oid => '.1.3.6.1.4.1.9.9.13.1.3.1.2' },
      ciscoEnvMonTemperatureStatusValue => { oid => '.1.3.6.1.4.1.9.9.13.1.3.1.3' },
      ciscoEnvMonTemperatureThreshold => { oid => '.1.3.6.1.4.1.9.9.13.1.3.1.4' },
      ciscoEnvMonTemperatureState => { oid => '.1.3.6.1.4.1.9.9.13.1.3.1.6', map => \%map_temperature_state },
  };
  my $oid_ciscoEnvMonTemperatureStatusEntry = '.1.3.6.1.4.1.9.9.13.1.3.1';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_ciscoEnvMonTemperatureStatusEntry };
  }
  
  sub check {
      my ($self) = @_;
      
      $self->{output}->output_add(long_msg => "Checking temperatures");
      $self->{components}->{temperature} = {name => 'temperatures', total => 0, skip => 0};
      return if ($self->check_filter(section => 'temperature'));
      
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_ciscoEnvMonTemperatureStatusEntry}})) {
          next if ($oid !~ /^$mapping->{ciscoEnvMonTemperatureState}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_ciscoEnvMonTemperatureStatusEntry}, instance => $instance);
          
          next if ($self->check_filter(section => 'temperature', instance => $instance));
          $self->{components}->{temperature}->{total}++;
  
          $self->{output}->output_add(long_msg => sprintf("Temperature '%s' status is %s [instance: %s] [value: %s C]", 
                                      $result->{ciscoEnvMonTemperatureStatusDescr}, $result->{ciscoEnvMonTemperatureState},
                                      $instance, defined($result->{ciscoEnvMonTemperatureStatusValue}) ? $result->{ciscoEnvMonTemperatureStatusValue} : '-'));
          my $exit = $self->get_severity(section => 'temperature', value => $result->{ciscoEnvMonTemperatureState});
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Temperature '%s' status is %s", 
                                                               $result->{ciscoEnvMonTemperatureStatusDescr}, $result->{ciscoEnvMonTemperatureState}));
          }
       
          next if (!defined($result->{ciscoEnvMonTemperatureStatusValue}));
          
          my ($exit2, $warn, $crit, $checked) = $self->get_severity_numeric(section => 'temperature', instance => $instance, value => $result->{ciscoEnvMonTemperatureStatusValue});
          if ($checked == 0) {
              my $warn_th = undef;
              my $crit_th = '~:' . $result->{ciscoEnvMonTemperatureThreshold};
              $self->{perfdata}->threshold_validate(label => 'warning-temperature-instance-' . $instance, value => $warn_th);
              $self->{perfdata}->threshold_validate(label => 'critical-temperature-instance-' . $instance, value => $crit_th);
              $warn = $self->{perfdata}->get_perfdata_for_output(label => 'warning-temperature-instance-' . $instance);
              $crit = $self->{perfdata}->get_perfdata_for_output(label => 'critical-temperature-instance-' . $instance);
          }
          if (!$self->{output}->is_status(value => $exit2, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit2,
                                          short_msg => sprintf("Temperature '%s' is %s degree centigrade", $result->{ciscoEnvMonTemperatureStatusDescr}, $result->{ciscoEnvMonTemperatureStatusValue}));
          }
          $self->{output}->perfdata_add(
              label => "temp", unit => 'C',
              nlabel => 'hardware.temperature.celsius',
              instances => $result->{ciscoEnvMonTemperatureStatusDescr},
              value => $result->{ciscoEnvMonTemperatureStatusValue},
              warning => $warn,
              critical => $crit
          );
      }
  }
  
  1;
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_TEMPERATURE

$fatpacked{"centreon/common/cisco/standard/snmp/mode/components/voltage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_VOLTAGE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::components::voltage;
  
  use strict;
  use warnings;
  
  my %map_voltage_state = (
      1 => 'normal', 
      2 => 'warning', 
      3 => 'critical', 
      4 => 'shutdown',
      5 => 'not present',
      6 => 'not functioning',
  );
  
  # In MIB 'CISCO-ENVMON-MIB'
  my $mapping = {
      ciscoEnvMonVoltageStatusDescr => { oid => '.1.3.6.1.4.1.9.9.13.1.2.1.2' },
      ciscoEnvMonVoltageStatusValue => { oid => '.1.3.6.1.4.1.9.9.13.1.2.1.3' },
      ciscoEnvMonVoltageThresholdLow => { oid => '.1.3.6.1.4.1.9.9.13.1.2.1.4' },
      ciscoEnvMonVoltageThresholdHigh => { oid => '.1.3.6.1.4.1.9.9.13.1.2.1.5' },
      ciscoEnvMonVoltageState => { oid => '.1.3.6.1.4.1.9.9.13.1.2.1.7', map => \%map_voltage_state },
  };
  my $oid_ciscoEnvMonVoltageStatusEntry = '.1.3.6.1.4.1.9.9.13.1.2.1';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_ciscoEnvMonVoltageStatusEntry };
  }
  
  sub check {
      my ($self) = @_;
      
      $self->{output}->output_add(long_msg => "Checking voltages");
      $self->{components}->{voltage} = {name => 'voltages', total => 0, skip => 0};
      return if ($self->check_filter(section => 'voltage'));
      
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_ciscoEnvMonVoltageStatusEntry}})) {
          next if ($oid !~ /^$mapping->{ciscoEnvMonVoltageState}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_ciscoEnvMonVoltageStatusEntry}, instance => $instance);
          
          next if ($self->check_filter(section => 'voltage', instance => $instance));
          $self->{components}->{voltage}->{total}++;
  
          $self->{output}->output_add(long_msg => sprintf("Voltage '%s' status is %s [instance: %s] [value: %s C]", 
                                      $result->{ciscoEnvMonVoltageStatusDescr}, $result->{ciscoEnvMonVoltageState},
                                      $instance, $result->{ciscoEnvMonVoltageStatusValue}));
          my $exit = $self->get_severity(section => 'voltage', value => $result->{ciscoEnvMonVoltageState});
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Voltage '%s' status is %s", 
                                                               $result->{ciscoEnvMonVoltageStatusDescr}, $result->{ciscoEnvMonVoltageState}));
          }
  
          $result->{ciscoEnvMonVoltageStatusValue} = $result->{ciscoEnvMonVoltageStatusValue} / 1000;
          my ($exit2, $warn, $crit, $checked) = $self->get_severity_numeric(section => 'voltage', instance => $instance, value => $result->{ciscoEnvMonVoltageStatusValue});
          if ($checked == 0) {
              my $warn_th = undef;
              my $crit_th = ((defined($result->{ciscoEnvMonVoltageThresholdLow}) && $result->{ciscoEnvMonVoltageThresholdLow} =~ /\d/) ? sprintf("%.3f", $result->{ciscoEnvMonVoltageThresholdLow} / 1000) : 0) . ':' . 
                  ((defined($result->{ciscoEnvMonVoltageThresholdHigh}) && $result->{ciscoEnvMonVoltageThresholdHigh} =~ /\d/) ? sprintf("%.3f", $result->{ciscoEnvMonVoltageThresholdHigh} / 1000) : '');
              $self->{perfdata}->threshold_validate(label => 'warning-voltage-instance-' . $instance, value => $warn_th);
              $self->{perfdata}->threshold_validate(label => 'critical-voltage-instance-' . $instance, value => $crit_th);
              $warn = $self->{perfdata}->get_perfdata_for_output(label => 'warning-voltage-instance-' . $instance);
              $crit = $self->{perfdata}->get_perfdata_for_output(label => 'critical-voltage-instance-' . $instance);
          }
          if (!$self->{output}->is_status(value => $exit2, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit2,
                                          short_msg => sprintf("Voltage '%s' is %.3f V", $result->{ciscoEnvMonVoltageStatusDescr}, $result->{ciscoEnvMonVoltageStatusValue}));
          }
          $self->{output}->perfdata_add(
              label => "voltage", unit => 'V',
              nlabel => 'hardware.voltage.volt',
              instances => $result->{ciscoEnvMonVoltageStatusDescr},
              value => sprintf("%.3f", $result->{ciscoEnvMonVoltageStatusValue}),
              warning => $warn,
              critical => $crit
          );
      }
  }
  
  1;
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_COMPONENTS_VOLTAGE

$fatpacked{"centreon/common/cisco/standard/snmp/mode/configuration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_CONFIGURATION';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::configuration;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_perfdata {
      my ($self, %options) = @_;
      
      $self->{output}->perfdata_add(label => 'running_last_changed', unit => 's',
                                    value => sprintf("%d", $self->{result_values}->{running_last_changed}),
                                    min => 0);
      $self->{output}->perfdata_add(label => 'running_last_saved', unit => 's',
                                    value => sprintf("%d", $self->{result_values}->{running_last_saved}),
                                    min => 0);
      $self->{output}->perfdata_add(label => 'startup_last_changed', unit => 's',
                                    value => sprintf("%d", $self->{result_values}->{startup_last_changed}),
                                    min => 0);
  }
  
  sub custom_status_output {
      my ($self, %options) = @_;
      
      my $msg = sprintf("Configuration Running Last Changed: %s, Running Last Saved: %s, Startup Last Changed: %s",
          ($self->{result_values}->{running_last_changed} > 0) ? centreon::plugins::misc::change_seconds(value => $self->{result_values}->{running_last_changed}) : "-",
          ($self->{result_values}->{running_last_saved} > 0) ? centreon::plugins::misc::change_seconds(value => $self->{result_values}->{running_last_saved}) : "-",
          ($self->{result_values}->{startup_last_changed} > 0) ? centreon::plugins::misc::change_seconds(value => $self->{result_values}->{startup_last_changed}) : "-");
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
      
      $self->{result_values}->{running_last_changed} = $options{new_datas}->{$self->{instance} . '_running_last_changed'};
      $self->{result_values}->{running_last_saved} = $options{new_datas}->{$self->{instance} . '_running_last_saved'};
      $self->{result_values}->{startup_last_changed} = $options{new_datas}->{$self->{instance} . '_startup_last_changed'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0 },
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'running_last_changed' }, { name => 'running_last_saved' }, { name => 'startup_last_changed' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => $self->can('custom_status_perfdata'),
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                    "warning-status:s"  => { name => 'warning_status', default => '' },
                                    "critical-status:s" => { name => 'critical_status', default => '%{running_last_changed} > %{running_last_saved}' },
                                  });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['warning_status', 'critical_status']);
  }
  
  my $oid_ccmHistoryRunningLastChanged = '.1.3.6.1.4.1.9.9.43.1.1.1.0';
  my $oid_ccmHistoryRunningLastSaved = '.1.3.6.1.4.1.9.9.43.1.1.2.0';
  my $oid_ccmHistoryStartupLastChanged = '.1.3.6.1.4.1.9.9.43.1.1.3.0';
  
  sub manage_selection {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      $self->{global} = {};
  
      $self->{results} = $self->{snmp}->get_leef(oids => [ $oid_ccmHistoryRunningLastChanged, $oid_ccmHistoryRunningLastSaved,
                                                        $oid_ccmHistoryStartupLastChanged ], nothing_quit => 1);
     
      $self->{global} = {
          running_last_changed => $self->{results}->{$oid_ccmHistoryRunningLastChanged} / 100,
          running_last_saved => $self->{results}->{$oid_ccmHistoryRunningLastSaved} / 100,
          startup_last_changed => $self->{results}->{$oid_ccmHistoryStartupLastChanged} / 100,
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check Cisco changed and saved configurations (CISCO-CONFIG-MAN-MIB).
  
  =over 8
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{running_last_changed}, %{running_last_saved}, %{startup_last_changed}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '%{running_last_changed} > %{running_last_saved}').
  Can used special variables like: %{running_last_changed}, %{running_last_saved}, %{startup_last_changed}
  
  =back
  
  =cut
      
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_CONFIGURATION

$fatpacked{"centreon/common/cisco/standard/snmp/mode/cpu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_CPU';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::cpu;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'cpu_avg', type => 0, cb_prefix_output => 'prefix_cpu_avg_output', message_separator => ' ', skipped_code => { -10 => 1 } },
          { name => 'cpu_core', type => 1, cb_prefix_output => 'prefix_cpu_core_output', message_separator => ' ', message_multiple => 'All core cpu are ok', skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{cpu_avg} = [
          { label => 'average-5s', nlabel => 'cpu.utilization.5s.percentage', set => {
                  key_values => [ { name => 'average_5s' } ],
                  output_template => '%.2f %% (5s)',
                  perfdatas => [
                      { label => 'total_cpu_5s_avg', value => 'average_5s_absolute', template => '%.2f',
                        min => 0, max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'average-1m', nlabel => 'cpu.utilization.1m.percentage', set => {
                  key_values => [ { name => 'average_1m' } ],
                  output_template => '%.2f %% (1m)',
                  perfdatas => [
                      { label => 'total_cpu_1m_avg', value => 'average_1m_absolute', template => '%.2f',
                        min => 0, max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'average-5m', nlabel => 'cpu.utilization.5m.percentage', set => {
                  key_values => [ { name => 'average_5m' } ],
                  output_template => '%.2f %% (5m)',
                  perfdatas => [
                      { label => 'total_cpu_5m_avg', value => 'average_5m_absolute', template => '%.2f',
                        min => 0, max => 100, unit => '%' },
                  ],
              }
          },
      ];
  
      $self->{maps_counters}->{cpu_core} = [
          { label => 'core-5s', nlabel => 'core.cpu.utilization.5s.percentage', set => {
                  key_values => [ { name => 'cpu_5s' }, { name => 'display' } ],
                  output_template => '%.2f %% (5s)',
                  perfdatas => [
                      { label => 'cpu_5s', value => 'cpu_5s_absolute', template => '%.2f',
                        min => 0, max => 100, unit => '%', label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
          { label => 'core-1m', nlabel => 'core.cpu.utilization.1m.percentage', set => {
                  key_values => [ { name => 'cpu_1m' }, { name => 'display' } ],
                  output_template => '%.2f %% (1m)',
                  perfdatas => [
                      { label => 'cpu_1m', value => 'cpu_1m_absolute', template => '%.2f',
                        min => 0, max => 100, unit => '%', label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
          { label => 'core-5m', nlabel => 'core.cpu.utilization.5m.percentage', set => {
                  key_values => [ { name => 'cpu_5m' }, { name => 'display' } ],
                  output_template => '%.2f %% (5m)',
                  perfdatas => [
                      { label => 'cpu_5m', value => 'cpu_5m_absolute', template => '%.2f',
                        min => 0, max => 100, unit => '%', label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
      ];
  }
  
  sub prefix_cpu_avg_output {
      my ($self, %options) = @_;
  
      return $self->{cpu_avg}->{count} . " CPU(s) average usage is ";
  }
  
  sub prefix_cpu_core_output {
      my ($self, %options) = @_;
  
      return "CPU '" . $options{instance_value}->{display} . "' usage ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'check-order:s'     => { name => 'check_order', default => 'process,old_sys,system_ext' },
      });
  
      return $self;
  }
  
  sub check_nexus_cpu {
      my ($self, %options) = @_;
      
      return if (!defined($options{snmp_result}->{$options{oid} . '.0'}));
  
      my $instance = 0;
      $self->{cpu_core}->{$instance} = {
          display => $instance,
          cpu_5m => $options{snmp_result}->{$options{oid} . '.0'},
      };
  
      $self->{checked_cpu} = 1;
  }
  
  sub check_table_cpu {
      my ($self, %options) = @_;
      
      return if ($self->{checked_cpu} == 1);
  
      my $instances =  {};
      foreach my $oid (keys %{$options{snmp_result}}) {
          $oid =~ /\.([0-9]+)$/;
          next if (defined($instances->{$1}));
          $instances->{$1} = 1;        
          my $instance = $1;
          
          my $cpu5sec = defined($options{snmp_result}->{$options{sec5} . '.' . $instance}) ? $options{snmp_result}->{$options{sec5} . '.' . $instance}  : undef;
          my $cpu1min = defined($options{snmp_result}->{$options{min1} . '.' . $instance}) ? $options{snmp_result}->{$options{min1} . '.' . $instance} : undef;
          my $cpu5min = defined($options{snmp_result}->{$options{min5} . '.' . $instance}) ? $options{snmp_result}->{$options{min5} . '.' . $instance} : undef;
  
          # Case that it's maybe other CPU oid in table for datas.
          next if (!defined($cpu5sec) && !defined($cpu1min) && !defined($cpu5min));
  
          $self->{checked_cpu} = 1;
          $self->{cpu_core}->{$instance} = {
              display => $instance,
              cpu_5s => $cpu5sec,
              cpu_1m => $cpu1min,
              cpu_5m => $cpu5min,
          };
      }    
  }
  
  sub check_cpu_average {
      my ($self, %options) = @_;
  
      my $count = scalar(keys %{$self->{cpu_core}});
      my ($avg_5s, $avg_1m, $avg_5m);
      foreach (values %{$self->{cpu_core}}) {
          $avg_5s = defined($avg_5s) ? $avg_5s + $_->{cpu_5s} : $_->{cpu_5s}
              if (defined($_->{cpu_5s}));
          $avg_1m = defined($avg_1m) ? $avg_1m + $_->{cpu_1m} : $_->{cpu_1m}
              if (defined($_->{cpu_1m}));
          $avg_5m = defined($avg_5m) ? $avg_5m + $_->{cpu_5m} : $_->{cpu_5m}
              if (defined($_->{cpu_5m}));
      }
      
      $self->{cpu_avg} = {
          average_5s => defined($avg_5s) ? $avg_5s / $count : undef,
          average_1m => defined($avg_1m) ? $avg_1m / $count : undef,
          average_5m => defined($avg_5m) ? $avg_5m / $count : undef,
          count => $count,
      };
  }
  
  sub check_cpu_process {
      my ($self, %options) = @_;
  
      return if ($self->{checked_cpu} == 1);
  
      # Cisco IOS Software releases later to 12.0(3)T and prior to 12.2(3.5)
      my $oid_cpmCPUTotalEntry = '.1.3.6.1.4.1.9.9.109.1.1.1.1';
      my $oid_cpmCPUTotal5sec = '.1.3.6.1.4.1.9.9.109.1.1.1.1.3';
      my $oid_cpmCPUTotal1min = '.1.3.6.1.4.1.9.9.109.1.1.1.1.4';
      my $oid_cpmCPUTotal5min = '.1.3.6.1.4.1.9.9.109.1.1.1.1.5';
      # Cisco IOS Software releases 12.2(3.5) or later
      my $oid_cpmCPUTotal5minRev = '.1.3.6.1.4.1.9.9.109.1.1.1.1.8';
      my $oid_cpmCPUTotal1minRev = '.1.3.6.1.4.1.9.9.109.1.1.1.1.7';
      my $oid_cpmCPUTotal5secRev = '.1.3.6.1.4.1.9.9.109.1.1.1.1.6';
  
      my $snmp_result = $self->{snmp}->get_table(
          oid => $oid_cpmCPUTotalEntry, start => $oid_cpmCPUTotal5sec, end => $oid_cpmCPUTotal5minRev
      );
      $self->check_table_cpu(snmp_result => $snmp_result, sec5 => $oid_cpmCPUTotal5secRev, min1 => $oid_cpmCPUTotal1minRev, min5 => $oid_cpmCPUTotal5minRev);
      $self->check_table_cpu(snmp_result => $snmp_result, sec5 => $oid_cpmCPUTotal5sec, min1 => $oid_cpmCPUTotal1min, min5 => $oid_cpmCPUTotal5min);
  }
  
  sub check_cpu_old_sys {
      my ($self, %options) = @_;
  
      return if ($self->{checked_cpu} == 1);
  
      # Cisco IOS Software releases prior to 12.0(3)T
      my $oid_lcpu = '.1.3.6.1.4.1.9.2.1';
      my $oid_busyPer = '.1.3.6.1.4.1.9.2.1.56'; # .0 in reality
      my $oid_avgBusy1 = '.1.3.6.1.4.1.9.2.1.57'; # .0 in reality
      my $oid_avgBusy5 = '.1.3.6.1.4.1.9.2.1.58'; # .0 in reality
      
      my $snmp_result = $self->{snmp}->get_table(
          oid => $oid_lcpu, start => $oid_busyPer, end => $oid_avgBusy5
      );
      $self->check_table_cpu(snmp_result => $snmp_result, sec5 => $oid_busyPer, min1 => $oid_avgBusy1, min5 => $oid_avgBusy5);
  }
  
  sub check_cpu_system_ext {
      my ($self, %options) = @_;
  
      return if ($self->{checked_cpu} == 1);
  
      # Cisco Nexus
      my $oid_cseSysCPUUtilization = '.1.3.6.1.4.1.9.9.305.1.1.1'; # .0 in reality
      my $snmp_result = $self->{snmp}->get_table(
          oid => $oid_cseSysCPUUtilization
      );
  
      $self->check_nexus_cpu(snmp_result => $snmp_result, oid => $oid_cseSysCPUUtilization);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{snmp} = $options{snmp};
      $self->{cpu_avg} = {};
      $self->{cpu_core} = {};
      $self->{checked_cpu} = 0;
      
      foreach (split /,/, $self->{option_results}->{check_order}) {
          my $method = $self->can('check_cpu_' . $_);
          if ($method) {
              $self->$method();
          }
      }
  
       if ($self->{checked_cpu} == 0) {
          $self->{output}->add_option_msg(short_msg => "Cannot find CPU informations");
          $self->{output}->option_exit();
      }
  
      $self->check_cpu_average();
  }
  
  1;
  
  
  =head1 MODE
  
  Check cpu usage (CISCO-PROCESS-MIB and CISCO-SYSTEM-EXT-MIB).
  
  =over 8
  
  =item B<--check-order>
  
  Check cpu in standard cisco mib. If you have some issue (wrong cpu information in a specific mib), you can change the order 
  (Default: 'process,old_sys,system_ext').
  
  =item B<--warning-*> B<--critical-*>
  
  Thresholds.
  Can be: 'core-5s', 'core-1m', 'core-5m', 'average-5s', 'average-1m', 'average-5m'.
  
  =back
  
  =cut
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_CPU

$fatpacked{"centreon/common/cisco/standard/snmp/mode/environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_ENVIRONMENT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::environment;
  
  use base qw(centreon::plugins::templates::hardware);
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub set_system {
      my ($self, %options) = @_;
      
      $self->{regexp_threshold_overload_check_section_option} = '^(fan|psu|temperature|voltage|module|physical|sensor)$';
      $self->{regexp_threshold_numeric_check_section_option} = '^(temperature|voltage|sensor.*)$';
      
      $self->{cb_hook2} = 'snmp_execute';
      
      $self->{thresholds} = {
          fan => [
              ['unknown', 'UNKNOWN'],
              ['down', 'CRITICAL'],
              ['up', 'OK'],
              
              ['normal', 'OK'],
              ['warning', 'WARNING'],
              ['critical', 'CRITICAL'],
              ['shutdown', 'CRITICAL'],
              ['not present', 'OK'],
              ['not functioning', 'WARNING'],
          ],
          psu => [
              ['^off*', 'WARNING'],
              ['failed', 'CRITICAL'],
              ['onButFanFail|onButInlinePowerFail', 'WARNING'],
              ['on', 'OK'],
              
              ['normal', 'OK'],
              ['warning', 'WARNING'],
              ['critical', 'CRITICAL'],
              ['shutdown', 'CRITICAL'],
              ['not present', 'OK'],
              ['not functioning', 'WARNING'],
          ],
          temperature => [
              ['normal', 'OK'],
              ['warning', 'WARNING'],
              ['critical', 'CRITICAL'],
              ['shutdown', 'CRITICAL'],
              ['not present', 'OK'],
              ['not functioning', 'WARNING'],
          ],
          voltage => [
              ['normal', 'OK'],
              ['warning', 'WARNING'],
              ['critical', 'CRITICAL'],
              ['shutdown', 'CRITICAL'],
              ['not present', 'OK'],
              ['not functioning', 'WARNING'],
          ],
          module => [
              ['unknown|mdr', 'UNKNOWN'],
              ['disabled|okButDiagFailed|missing|mismatchWithParent|mismatchConfig|dormant|outOfServiceAdmin|outOfServiceEnvTemp|powerCycled|okButPowerOverWarning|okButAuthFailed|fwMismatchFound|fwDownloadFailure', 'WARNING'],
              ['failed|diagFailed|poweredDown|powerDenied|okButPowerOverCritical', 'CRITICAL'],
              ['boot|selfTest|poweredUp|syncInProgress|upgrading|fwDownloadSuccess|ok', 'OK'],
          ],
          physical => [
              ['other', 'UNKNOWN'],
              ['incompatible|unsupported', 'CRITICAL'],
              ['supported', 'OK'],
          ],
          sensor => [
              ['ok', 'OK'],
              ['unavailable', 'OK'],
              ['nonoperational', 'CRITICAL'],
          ],
      };
      
      $self->{components_path} = 'centreon::common::cisco::standard::snmp::mode::components';
      $self->{components_module} = ['fan', 'psu', 'temperature', 'voltage', 'module', 'physical', 'sensor'];
  }
  
  my $oid_entPhysicalDescr = '.1.3.6.1.2.1.47.1.1.1.1.2';
  my $oid_ciscoEnvMonPresent = ".1.3.6.1.4.1.9.9.13.1.1";
  
  my %map_type_mon = (
      1 => 'oldAgs',
      2 => 'ags',
      3 => 'c7000',
      4 => 'ci',
      6 => 'cAccessMon',
      7 => 'cat6000',
      8 => 'ubr7200',
      9 => 'cat4000',
      10 => 'c10000',
      11 => 'osr7600',
      12 => 'c7600',
      13 => 'c37xx',
      14 => 'other'
  );
  
  sub snmp_execute {
      my ($self, %options) = @_;
      
      $self->{snmp} = $options{snmp};
      
      push @{$self->{request}}, { oid => $oid_entPhysicalDescr }, { oid => $oid_ciscoEnvMonPresent };
      $self->{results} = $self->{snmp}->get_multiple_table(oids => $self->{request});
      while (my ($key, $value) = each %{$self->{results}->{$oid_entPhysicalDescr}}) {
          $self->{results}->{$oid_entPhysicalDescr}->{$key} = centreon::plugins::misc::trim($value);
      }
      $self->{output}->output_add(long_msg => sprintf("Environment type: %s", 
                                  defined($self->{results}->{$oid_ciscoEnvMonPresent}->{$oid_ciscoEnvMonPresent . '.0'}) && defined($map_type_mon{$self->{results}->{$oid_ciscoEnvMonPresent}->{$oid_ciscoEnvMonPresent . '.0'}} ) ? 
                                  $map_type_mon{$self->{results}->{$oid_ciscoEnvMonPresent}->{$oid_ciscoEnvMonPresent . '.0'}} : 'unknown'));
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  { 
                                  });
      
      return $self;
  }
  
  1;
  
  
  =head1 MODE
  
  Check environment (Power Supplies, Fans, Temperatures, Voltages, Modules, Physical Entities).
  
  =over 8
  
  =item B<--component>
  
  Which component to check (Default: '.*').
  Can be: 'fan', 'psu', 'temperature', 'voltage', 'module', 'physical', 'sensor'.
  
  =item B<--filter>
  
  Exclude some parts (comma seperated list) (Example: --filter=fan --filter=psu)
  Can also exclude specific instance: --filter=fan,1
  
  =item B<--absent-problem>
  
  Return an error if an entity is not 'present' (default is skipping) (comma seperated list)
  Can be specific or global: --absent-problem=fan,1
  
  =item B<--no-component>
  
  Return an error if no compenents are checked.
  If total (with skipped) is 0. (Default: 'critical' returns).
  
  =item B<--threshold-overload>
  
  Set to overload default threshold values (syntax: section,status,regexp)
  It used before default thresholds (order stays).
  Example: --threshold-overload='fan,CRITICAL,^(?!(up|normal)$)'
  
  =item B<--warning>
  
  Set warning threshold for temperatures, voltages, sensors (syntax: type,regexp,threshold)
  Example: --warning='temperature,.*,30'
  
  =item B<--critical>
  
  Set critical threshold for temperatures, voltages, sensors (syntax: type,regexp,threshold)
  Example: --critical='temperature,.*,40'
  
  =back
  
  =cut
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_ENVIRONMENT

$fatpacked{"centreon/common/cisco/standard/snmp/mode/hsrp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_HSRP';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::hsrp;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my %map_row_status = (
      1 => 'active',
      2 => 'notInService',
      3 => 'notReady',
      4 => 'createAndGo',
      5 => 'createAndWait',
      6 => 'destroy'
  );
  my %map_states = (
      1 => 'initial',
      2 => 'learn',
      3 => 'listen',
      4 => 'speak',
      5 => 'standby',
      6 => 'active',
  );
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'role:s'        => { name => 'role', default => 'primary' },
          'filter-vrid:s' => { name => 'filter_vrid' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if ($self->{option_results}->{role} !~ /^primary|secondary$/) {
          $self->{output}->add_option_msg(short_msg => "You must use either primary either secondary for --role option");
          $self->{output}->option_exit();
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
      
      my $vridout = '';
      my $oid_cHsrpGrpStandbyState = ".1.3.6.1.4.1.9.9.106.1.2.1.1.15";    # HSRP Oper Status
      my $oid_cHsrpGrpEntryRowStatus = ".1.3.6.1.4.1.9.9.106.1.2.1.1.17";   # HSRP Admin Status
  
      my $results = $self->{snmp}->get_multiple_table(oids => 
          [
              { oid => $oid_cHsrpGrpStandbyState },
              { oid => $oid_cHsrpGrpEntryRowStatus },
          ],
          nothing_quit => 1
      );
  
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => sprintf("Router is in its expected state : '%s'", $self->{option_results}->{role}));
      foreach my $oid (keys %{$results->{$oid_cHsrpGrpStandbyState}}) {
          $oid =~ /(\d+\.\d+)$/; 
          my $vrid = $1;
  
          if (defined($self->{option_results}->{filter_vrid}) && $self->{option_results}->{filter_vrid} ne '' &&
              $vrid !~ /$self->{option_results}->{filter_vrid}/) {
              $self->{output}->output_add(long_msg => "skipping vrid '" . $vrid . "': no matching filter.", debug => 1);
              next;
          }
  
          my $operState = $results->{$oid_cHsrpGrpEntryRowStatus}->{$oid_cHsrpGrpEntryRowStatus . "." . $vrid};
          my $adminState = $results->{$oid_cHsrpGrpStandbyState}->{$oid};
  
          $self->{output}->output_add(long_msg => sprintf("[Vrid : %s] [Admin Status is '%s'] [Oper Status is '%s']",
                                                          $vrid, $map_states{$adminState}, $map_row_status{$operState}));
          
          if ($map_row_status{$operState} !~ /^active$/i) {
              $self->{output}->output_add(severity => 'CRITICAL',
  					                    short_msg => sprintf("VRID %s operational state is '%s'", $vrid, $map_row_status{$operState}));
          }
  
          if (($self->{option_results}->{role} eq 'primary' && $map_states{$adminState} !~ /^active$/) || 
              ($self->{option_results}->{role} eq 'secondary' && $map_states{$adminState} !~ /^standby$/)) {
              $vridout .= sprintf("(VRID %s is '%s')", $vrid, $map_states{$adminState});
          }
      }       
      
      if ($vridout ne '') {
          $self->{output}->output_add(severity => 'CRITICAL',
                                      short_msg => sprintf("%s - Router isn't in the expected state (%s)", $vridout, $self->{option_results}->{role}));
      }
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check Cisco HSRP (CISCO-HSRP-MIB). Trigger a critical if not in the expected state or if a VRID is not in an active state.
  
  =over 8
  
  =item B<--filter-vrid>
  
  Filter VRID (can be a regexp).
  
  =item B<--role>
  
  If role is 'primary', an error if HSRPs are 'standby' states. 
  If role is 'secondary', an error if HSRPs are 'active' states. (Default: 'primary')
  
  =back
  
  =cut
      
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_HSRP

$fatpacked{"centreon/common/cisco/standard/snmp/mode/interfaces.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_INTERFACES';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::interfaces;
  
  use base qw(snmp_standard::mode::interfaces);
  
  use strict;
  use warnings;
  
  sub set_oids_errors {
      my ($self, %options) = @_;
      
      $self->{oid_ifInDiscards} = '.1.3.6.1.2.1.2.2.1.13';
      $self->{oid_ifInErrors} = '.1.3.6.1.2.1.2.2.1.14';
      $self->{oid_ifOutDiscards} = '.1.3.6.1.2.1.2.2.1.19';
      $self->{oid_ifOutErrors} = '.1.3.6.1.2.1.2.2.1.20';
      $self->{oid_ifInCrc} = '.1.3.6.1.4.1.9.2.2.1.1.12';
  }
  
  sub set_counters_errors {
      my ($self, %options) = @_;
  
      $self->SUPER::set_counters_errors(%options);
      
      push @{$self->{maps_counters}->{int}}, 
          { label => 'in-crc', filter => 'add_errors', nlabel => 'interface.packets.in.crc.count', set => {
                  key_values => [ { name => 'incrc', diff => 1 }, { name => 'total_in_packets', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
                  closure_custom_calc => $self->can('custom_errors_calc'), closure_custom_calc_extra_options => { label_ref1 => 'in', label_ref2 => 'crc' },
                  closure_custom_output => $self->can('custom_errors_output'), output_error_template => 'Packets In Crc : %s',
                  closure_custom_perfdata => $self->can('custom_errors_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_errors_threshold'),
              }
          },
      ;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      return $self;
  }
  
  sub load_errors {
      my ($self, %options) = @_;
      
      $self->set_oids_errors();
      $self->{snmp}->load(
          oids => [
              $self->{oid_ifInDiscards}, $self->{oid_ifInErrors},
              $self->{oid_ifOutDiscards}, $self->{oid_ifOutErrors},
              $self->{oid_ifInCrc}
          ],
          instances => $self->{array_interface_selected}
      );
  }
  
  sub add_result_errors {
      my ($self, %options) = @_;
      
      $self->{int}->{$options{instance}}->{indiscard} = $self->{results}->{$self->{oid_ifInDiscards} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{inerror} = $self->{results}->{$self->{oid_ifInErrors} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{outdiscard} = $self->{results}->{$self->{oid_ifOutDiscards} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{outerror} = $self->{results}->{$self->{oid_ifOutErrors} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{incrc} = $self->{results}->{$self->{oid_ifInCrc} . '.' . $options{instance}};
  }
  
  1;
  
  
  =head1 MODE
  
  Check interfaces.
  
  =over 8
  
  =item B<--add-global>
  
  Check global port statistics (By default if no --add-* option is set).
  
  =item B<--add-status>
  
  Check interface status.
  
  =item B<--add-duplex-status>
  
  Check duplex status (with --warning-status and --critical-status).
  
  =item B<--add-traffic>
  
  Check interface traffic.
  
  =item B<--add-errors>
  
  Check interface errors.
  
  =item B<--add-cast>
  
  Check interface cast.
  
  =item B<--add-speed>
  
  Check interface speed.
  
  =item B<--add-volume>
  
  Check interface data volume between two checks (not supposed to be graphed, useful for BI reporting).
  
  =item B<--warning-status>
  
  Set warning threshold for status.
  Can used special variables like: %{admstatus}, %{opstatus}, %{duplexstatus}, %{display}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '%{admstatus} eq "up" and %{opstatus} ne "up"').
  Can used special variables like: %{admstatus}, %{opstatus}, %{duplexstatus}, %{display}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-port', 'total-admin-up', 'total-admin-down', 'total-oper-up', 'total-oper-down',
  'in-traffic', 'out-traffic', 'in-crc', 'in-error', 'in-discard', 'out-error', 'out-discard',
  'in-ucast' (%), 'in-bcast' (%), 'in-mcast' (%), 'out-ucast' (%), 'out-bcast' (%), 'out-mcast' (%),
  'speed' (b/s).
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-port', 'total-admin-up', 'total-admin-down', 'total-oper-up', 'total-oper-down',
  'in-traffic', 'out-traffic', 'in-crc', 'in-error', 'in-discard', 'out-error', 'out-discard',
  'in-ucast' (%), 'in-bcast' (%), 'in-mcast' (%), 'out-ucast' (%), 'out-bcast' (%), 'out-mcast' (%),
  'speed' (b/s).
  
  =item B<--units-traffic>
  
  Units of thresholds for the traffic (Default: '%') ('%', 'b/s').
  
  =item B<--units-errors>
  
  Units of thresholds for errors/discards (Default: '%') ('%', 'absolute').
  
  =item B<--nagvis-perfdata>
  
  Display traffic perfdata to be compatible with nagvis widget.
  
  =item B<--interface>
  
  Set the interface (number expected) ex: 1,2,... (empty means 'check all interface').
  
  =item B<--name>
  
  Allows to use interface name with option --interface instead of interface oid index (Can be a regexp)
  
  =item B<--speed>
  
  Set interface speed for incoming/outgoing traffic (in Mb).
  
  =item B<--speed-in>
  
  Set interface speed for incoming traffic (in Mb).
  
  =item B<--speed-out>
  
  Set interface speed for outgoing traffic (in Mb).
  
  =item B<--no-skipped-counters>
  
  Don't skip counters when no change.
  
  =item B<--force-counters32>
  
  Force to use 32 bits counters (even in snmp v2c and v3). Should be used when 64 bits counters are buggy.
  
  =item B<--reload-cache-time>
  
  Time in minutes before reloading cache file (default: 180).
  
  =item B<--oid-filter>
  
  Choose OID used to filter interface (default: ifName) (values: ifDesc, ifAlias, ifName, IpAddr).
  
  =item B<--oid-display>
  
  Choose OID used to display interface (default: ifName) (values: ifDesc, ifAlias, ifName, IpAddr).
  
  =item B<--oid-extra-display>
  
  Add an OID to display.
  
  =item B<--display-transform-src>
  
  Regexp src to transform display value.
  
  =item B<--display-transform-dst>
  
  Regexp dst to transform display value.
  
  =item B<--show-cache>
  
  Display cache interface datas.
  
  =back
  
  =cut
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_INTERFACES

$fatpacked{"centreon/common/cisco/standard/snmp/mode/ipsectunnel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_IPSECTUNNEL';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::ipsectunnel;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  use Socket;
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'global', type => 0 },
          { name => 'tunnel', type => 1, cb_prefix_output => 'prefix_tunnel_output', message_multiple => 'All tunnels are ok' },
      ];
  
      $self->{maps_counters}->{global} = [
          { label => 'tunnels-total', set => {
                  key_values => [ { name => 'total' } ],
                  output_template => 'Total Tunnels : %s',
                  perfdatas => [
                      { label => 'total_tunnels', value => 'total_absolute', template => '%s',
                        min => 0 },
                  ],
              }
          },
      ];
      $self->{maps_counters}->{tunnel} = [
          { label => 'traffic-in', set => {
                  key_values => [],
                  per_second => 1, manual_keys => 1,
                  closure_custom_calc => $self->can('custom_traffic_calc'), closure_custom_calc_extra_options => { label_ref => 'In' },
                  closure_custom_output => $self->can('custom_traffic_output'),
                  closure_custom_perfdata => $self->can('custom_traffic_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_traffic_threshold'),
              }
          },
          { label => 'traffic-out', set => {
                  key_values => [],
                  per_second => 1, manual_keys => 1,
                  closure_custom_calc => $self->can('custom_traffic_calc'), closure_custom_calc_extra_options => { label_ref => 'Out' },
                  closure_custom_output => $self->can('custom_traffic_output'),
                  closure_custom_perfdata => $self->can('custom_traffic_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_traffic_threshold'),
              }
          },
          { label => 'drop-in', set => {
                  key_values => [],
                  per_second => 1, manual_keys => 1,
                  closure_custom_calc => $self->can('custom_drop_calc'), closure_custom_calc_extra_options => { label_ref => 'In' },
                  closure_custom_output => $self->can('custom_drop_output'),
                  closure_custom_perfdata => $self->can('custom_drop_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_drop_threshold'),
              }
          },
          { label => 'drop-out', set => {
                  key_values => [],
                  per_second => 1, manual_keys => 1,
                  closure_custom_calc => $self->can('custom_drop_calc'), closure_custom_calc_extra_options => { label_ref => 'Out' },
                  closure_custom_output => $self->can('custom_drop_output'),
                  closure_custom_perfdata => $self->can('custom_drop_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_drop_threshold'),
              }
          },
          { label => 'sa-total', set => {
                  key_values => [ { name => 'sa' }, { name => 'display' } ],
                  output_template => 'Total SA : %s',
                  perfdatas => [
                      { label => 'total_sa', value => 'sa_absolute', template => '%s',
                        min => 0, label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
      ];
  }
  
  sub custom_traffic_perfdata {
      my ($self, %options) = @_;
  
      my $warning = $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel});
      my $critical = $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel});
      
      $self->{output}->perfdata_add(
          label => 'traffic_' . lc($self->{result_values}->{label}), unit => 'b/s',
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
          value => sprintf("%.2f", $self->{result_values}->{traffic_per_seconds}),
          warning => $warning,
          critical => $critical,
          min => 0
      );
  }
  
  sub custom_traffic_threshold {
      my ($self, %options) = @_;
      
      my $exit = $self->{perfdata}->threshold_check(value => $self->{result_values}->{traffic_per_seconds}, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      return $exit;
  }
  
  sub custom_traffic_output {
      my ($self, %options) = @_;
      
      my ($traffic_value, $traffic_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{traffic_per_seconds}, network => 1);    
      my $msg = sprintf("Traffic %s : %s/s",
                        $self->{result_values}->{label},
                        $traffic_value . $traffic_unit);
      return $msg;
  }
  
  sub custom_traffic_calc {
      my ($self, %options) = @_;
  
      my $total_bytes = 0;
      foreach (keys %{$options{new_datas}}) {
          if (/$self->{instance}_cipSecTunHc$options{extra_options}->{label_ref}Octets_(\d+)/) {
              my $new_bytes = $options{new_datas}->{$_};
              next if (!defined($options{old_datas}->{$_}));
              my $old_bytes = $options{old_datas}->{$_};
              
              $total_bytes += $new_bytes - $old_bytes;
              $total_bytes += $new_bytes if ($total_bytes <= 0);
          } elsif (/$self->{instance}_cipSecTun$options{extra_options}->{label_ref}Octets_(\d+)/) {
              my $new_bytes = $options{new_datas}->{$_};
              my $new_wraps = $options{new_datas}->{$self->{instance} . '_cipSecTun' . $options{extra_options}->{label_ref} . 'OctWraps_' . $1};
              next if (!defined($options{old_datas}->{$_}));
              my ($old_bytes, $old_wraps) = ($options{old_datas}->{$_}, $options{old_datas}->{$self->{instance} . '_cipSecTun' . $options{extra_options}->{label_ref} . 'OctWraps_' . $1});
              
              $total_bytes += $new_bytes - $old_bytes + (($new_wraps - $old_wraps) * (2**32));
              $total_bytes += $new_bytes if ($total_bytes <= 0);
          }
      }
      
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{traffic_per_seconds} = ($total_bytes * 8) / $options{delta_time};    
      $self->{result_values}->{label} = $options{extra_options}->{label_ref};
      
      return 0;
  }
  
  sub custom_drop_perfdata {
      my ($self, %options) = @_;
      
      my $warning = $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel});
      my $critical = $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel});
      
      $self->{output}->perfdata_add(
          label => 'drop_' . lc($self->{result_values}->{label}), unit => 'pkts/s',
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
          value => sprintf("%.2f", $self->{result_values}->{pkts_per_seconds}),
          warning => $warning,
          critical => $critical,
          min => 0
      );
  }
  
  sub custom_drop_threshold {
      my ($self, %options) = @_;
      
      my $exit = $self->{perfdata}->threshold_check(value => $self->{result_values}->{pkts_per_seconds}, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      return $exit;
  }
  
  sub custom_drop_output {
      my ($self, %options) = @_;
      
      my $msg = sprintf("Drop %s : %s pkts/s",
                        $self->{result_values}->{label}, $self->{result_values}->{pkts_per_seconds});
      return $msg;
  }
  
  sub custom_drop_calc {
      my ($self, %options) = @_;
  
      my $total_pkts = 0;
      foreach (keys %{$options{new_datas}}) {
          if (/$self->{instance}_cipSecTun$options{extra_options}->{label_ref}DropPkts_(\d+)/) {
              my $new_pkts = $options{new_datas}->{$_};
              next if (!defined($options{old_datas}->{$_}));
              my $old_pkts = $options{old_datas}->{$_};
              
              $old_pkts = 0 if ($old_pkts > $new_pkts);
              $total_pkts += $new_pkts - $old_pkts;
          }
      }
      
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{pkts_per_seconds} = $total_pkts / $options{delta_time};    
      $self->{result_values}->{label} = $options{extra_options}->{label_ref};
      
      return 0;
  }
  
  sub prefix_tunnel_output {
      my ($self, %options) = @_;
      
      return "Tunnel '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "filter-name:s" => { name => 'filter_name' },
          "filter-sa:s"   => { name => 'filter_sa' },
      });
  
      return $self;
  }
  
  my $mapping = {
      cikeTunLocalValue       => { oid => '.1.3.6.1.4.1.9.9.171.1.2.3.1.3' },
      cikeTunRemoteValue      => { oid => '.1.3.6.1.4.1.9.9.171.1.2.3.1.7' },
      cikeTunActiveTime       => { oid => '.1.3.6.1.4.1.9.9.171.1.2.3.1.16' },
  };
  my $mapping2 = {
      cipSecTunInOctets       => { oid => '.1.3.6.1.4.1.9.9.171.1.3.2.1.26' },
      cipSecTunHcInOctets     => { oid => '.1.3.6.1.4.1.9.9.171.1.3.2.1.27' },
      cipSecTunInOctWraps     => { oid => '.1.3.6.1.4.1.9.9.171.1.3.2.1.28' }, # seems buggy
      cipSecTunInDropPkts     => { oid => '.1.3.6.1.4.1.9.9.171.1.3.2.1.33' },
      cipSecTunOutOctets      => { oid => '.1.3.6.1.4.1.9.9.171.1.3.2.1.39' },
      cipSecTunHcOutOctets    => { oid => '.1.3.6.1.4.1.9.9.171.1.3.2.1.40' }, # seems buggy
      cipSecTunOutOctWraps    => { oid => '.1.3.6.1.4.1.9.9.171.1.3.2.1.41' },
      cipSecTunOutDropPkts    => { oid => '.1.3.6.1.4.1.9.9.171.1.3.2.1.46' },
  };
  my $mapping3 = {
      cipSecEndPtLocalAddr1   => { oid => '.1.3.6.1.4.1.9.9.171.1.3.3.1.4' },
      cipSecEndPtLocalAddr2   => { oid => '.1.3.6.1.4.1.9.9.171.1.3.3.1.5' },
      cipSecEndPtRemoteAddr1  => { oid => '.1.3.6.1.4.1.9.9.171.1.3.3.1.10' },
      cipSecEndPtRemoteAddr2  => { oid => '.1.3.6.1.4.1.9.9.171.1.3.3.1.11' },
  };
  
  my $oid_cikeTunnelEntry = '.1.3.6.1.4.1.9.9.171.1.2.3.1';
  my $oid_cipSecTunnelEntry = '.1.3.6.1.4.1.9.9.171.1.3.2.1';
  my $oid_cipSecEndPtEntry = '.1.3.6.1.4.1.9.9.171.1.3.3.1';
  my $oid_cipSecTunIkeTunnelIndex = '.1.3.6.1.4.1.9.9.171.1.3.2.1.2';
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      $self->{tunnel} = {};    
      my $request_oids = [
          { oid => $oid_cikeTunnelEntry, end => $mapping->{cikeTunActiveTime}->{oid} },
          { oid => $oid_cipSecTunnelEntry, begin => $mapping2->{cipSecTunInOctets}->{oid} },
          { oid => $oid_cipSecEndPtEntry },
          { oid => $oid_cipSecTunIkeTunnelIndex },
      ];
      my $results = $options{snmp}->get_multiple_table(oids => $request_oids);
  
      # The MIB doesn't give IPSec tunnel type (site-to-site or dynamic client)
      # You surely need to filter on SA. Dynamic client usually doesn't push local routes.
      foreach (keys %{$results->{$oid_cikeTunnelEntry}}) {
          next if (!/$mapping->{cikeTunRemoteValue}->{oid}\.(\d+)/);
          
          my $cike_tun_index = $1;
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $results->{$oid_cikeTunnelEntry}, instance => $cike_tun_index);
          
          my $name = $result->{cikeTunLocalValue} . '_' . $result->{cikeTunRemoteValue};
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $name !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping  '" . $name . "': no matching filter name.", debug => 1);
              next;
          }
          
          foreach my $key (keys %{$results->{$oid_cipSecTunIkeTunnelIndex}}) {
              next if ($results->{$oid_cipSecTunIkeTunnelIndex}->{$key} != $cike_tun_index);
              $key =~ /^$oid_cipSecTunIkeTunnelIndex\.(\d+)/;
              my $cip_tun_index = $1;
              
              my $result2 = $options{snmp}->map_instance(mapping => $mapping2, results => $results->{$oid_cipSecTunnelEntry}, instance => $cip_tun_index);
              my $sa_name = '';
              foreach my $key2 (keys %{$results->{$oid_cipSecEndPtEntry}}) {
                  if ($key2 =~ /^$mapping3->{cipSecEndPtLocalAddr1}->{oid}\.$cip_tun_index\.(\d+)/) {
                      my $result3 = $options{snmp}->map_instance(mapping => $mapping3, results => $results->{$oid_cipSecEndPtEntry}, instance => $cip_tun_index . '.' . $1);
                      $sa_name = inet_ntoa($result3->{cipSecEndPtLocalAddr1}) . ':' . inet_ntoa($result3->{cipSecEndPtLocalAddr2}) . '_' . inet_ntoa($result3->{cipSecEndPtRemoteAddr1}) . ':' . inet_ntoa($result3->{cipSecEndPtRemoteAddr2});
                      last;
                  }
              }
              
              if (defined($self->{option_results}->{filter_sa}) && $self->{option_results}->{filter_sa} ne '' &&
                  $sa_name !~ /$self->{option_results}->{filter_sa}/) {
                  $self->{output}->output_add(long_msg => "skipping  '" . $sa_name . "': no matching filter sa.", debug => 1);
                  next;
              }
              
              $self->{tunnel}->{$name} = { display => $name, sa => 0 } 
                  if (!defined($self->{tunnel}->{$name}));
              if (defined($result2->{cipSecTunHcInOctets}) && defined($result2->{cipSecTunHcOutOctets})) {
                  delete $result2->{cipSecTunInOctets};
                  delete $result2->{cipSecTunInOctWraps};
                  delete $result2->{cipSecTunOutOctets};
                  delete $result2->{cipSecTunOutOctWraps};
              }
              foreach my $oid_name (keys %{$mapping2}) {
                  $self->{tunnel}->{$name}->{$oid_name . '_' . $cip_tun_index} = $result2->{$oid_name} if (defined($result2->{$oid_name}));
              }
              $self->{tunnel}->{$name}->{cikeTunActiveTime} = $result->{cikeTunActiveTime};
              $self->{tunnel}->{$name}->{sa}++;
          }
      }
      
      $self->{cache_name} = "cisco_ipsectunnel_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' .
          (defined($self->{option_results}->{filter_name}) ? md5_hex($self->{option_results}->{filter_name}) : md5_hex('all')) . '_' .
          (defined($self->{option_results}->{filter_sa}) ? md5_hex($self->{option_results}->{filter_sa}) : md5_hex('all')) . '_' .
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
      
      $self->{global} = { total => scalar(keys %{$self->{tunnel}}) };
  }
  
  1;
  
  
  =head1 MODE
  
  Check IPsec tunnels.
  
  =over 8
  
  =item B<--filter-name>
  
  Filter name (can be a regexp).
  Example (format localaddr_remoteaddr): 
  
  =item B<--filter-sa>
  
  Filter IPSec Security Associations (can be a regexp).
  Example (format localaddr:localmask_remoteaddr:remotemask): 
  
  =item B<--filter-counters>
  
  Only display some counters (regexp can be used).
  Example: --filter-counters='^(tunnels-total)$'
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'tunnels-total', 'traffic-in', 
  'traffic-out', 'drop-in', 'drop-out', 'sa-total'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'tunnels-total', 'traffic-in', 
  'traffic-out', 'drop-in', 'drop-out', 'sa-total'.
  
  =back
  
  =cut
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_IPSECTUNNEL

$fatpacked{"centreon/common/cisco/standard/snmp/mode/ipsla.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_IPSLA';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::ipsla;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  use Math::Complex;
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'tag', type => 1, cb_prefix_output => 'prefix_tag_output', message_multiple => 'All RTT controls are ok',
            skipped_code => { -2 => 1, -3 => 1, -10 => 1 } }
      ];
      $self->{maps_counters}->{tag} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, 
                                  { name => 'rttMonCtrlAdminTag' },
                                  { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'rttMonCtrlAdminThreshold' },
                                  { name => 'rttMonEchoAdminPrecision' },
                                  { name => 'rttMonLatestRttOperCompletionTime' },
                                  { name => 'rttMonLatestRttOperSense' },
                                  { name => 'rttMonLatestRttOperApplSpecificSense' },
                                ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata =>  sub { return 0; },
                  closure_custom_threshold_check => $self->can('custom_status_threshold'),
              }
          },
          { label => 'CompletionTime', set => {
                  key_values => [ { name => 'rttMonLatestRttOperCompletionTime' }, { name => 'rttMonEchoAdminPrecision' }, { name => 'rttMonCtrlAdminTag' }
                                ],
                  output_template => 'Completion Time : %s',
                  perfdatas => [
                      { label => 'completion_time', value => 'rttMonLatestRttOperCompletionTime_absolute', template => '%s',
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'NumberOverThresholds', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'OverThresholds_1' }, { name => 'OverThresholds_2' }, { name => 'OverThresholds_times' },
                                ],
                  closure_custom_calc => $self->can('custom_NumberOverThresholds_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'Number Over Thresholds : %s',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'number_over_thresholds', value => 'value', template => '%s',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'AverageDelaySD', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'OWSumSD_1' }, { name => 'OWSumSD_2' }, { name => 'OWSumSD_times' },
                                  { name => 'NumOfOW_1' }, { name => 'NumOfOW_2' }, { name => 'NumOfOW_times' },
                                ],
                  closure_custom_calc => $self->can('custom_AverageDelaySD_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'Average Delay SD : %.2f ms',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'average_delay_sd', value => 'value', template => '%.2f', unit => 'ms',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'AverageDelayDS', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'OWSumDS_1' }, { name => 'OWSumDS_2' }, { name => 'OWSumDS_times' },
                                  { name => 'NumOfOW_1' }, { name => 'NumOfOW_2' }, { name => 'NumOfOW_times' },
                                ],
                  closure_custom_calc => $self->can('custom_AverageDelayDS_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'Average Delay DS : %.2f ms',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'average_delay_ds', value => 'value', template => '%.2f', unit => 'ms',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'PacketLossRatio', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'PacketLossDS_1' }, { name => 'PacketLossDS_2' }, { name => 'PacketLossDS_times' },
                                  { name => 'PacketLossSD_1' }, { name => 'PacketLossSD_2' }, { name => 'PacketLossSD_times' },
                                  { name => 'PacketMIA_1' }, { name => 'PacketMIA_2' }, { name => 'PacketMIA_times' },
                                  { name => 'PacketLateArrival_1' }, { name => 'PacketLateArrival_2' }, { name => 'PacketLateArrival_times' },
                                  { name => 'PacketOutOfSequence_1' }, { name => 'PacketOutOfSequence_2' }, { name => 'PacketOutOfSequence_times' },
                                  { name => 'NumOfRTT_1' }, { name => 'NumOfRTT_2' }, { name => 'NumOfRTT_times' },
                                ],
                  closure_custom_calc => $self->can('custom_PacketLossRatio_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'Packet Loss Ratio : %.2f %%',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'packet_loss_ratio', value => 'value', template => '%.2f', unit => '%',
                        label_extra_instance => 1, min => 0, max => 100 },
                  ],
              }
          },
          { label => 'PercentagePacketsPositiveJitter', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'NumOfPositivesSD_1' }, { name => 'NumOfPositivesSD_2' }, { name => 'NumOfPositivesSD_times' },
                                  { name => 'NumOfRTT_1' }, { name => 'NumOfRTT_2' }, { name => 'NumOfRTT_times' },
                                ],
                  closure_custom_calc => $self->can('custom_PercentagePacketsPositiveJitter_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'Percentage of Packets that had Positive Jitter : %.2f',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'prct_jitter_per_packet_positive_jitter', value => 'value', template => '%.2f',
                        label_extra_instance => 1, },
                  ],
              }
          },
          { label => 'AverageJitterPerPacketPositiveJitter', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'SumOfPositivesSD_1' }, { name => 'SumOfPositivesSD_2' }, { name => 'SumOfPositivesSD_times' },
                                  { name => 'NumOfRTT_1' }, { name => 'NumOfRTT_2' }, { name => 'NumOfRTT_times' },
                                ],
                  closure_custom_calc => $self->can('custom_AverageJitterPerPacketPositiveJitter_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'Average Jitter per Packet that had Positive Jitter : %.2f',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'average_jitter_per_packet_positive_jitter', value => 'value', template => '%.2f',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'PercentagePacketsNegativeJitter', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'NumOfNegativesSD_1' }, { name => 'NumOfNegativesSD_2' }, { name => 'NumOfNegativesSD_times' },
                                  { name => 'NumOfRTT_1' }, { name => 'NumOfRTT_2' }, { name => 'NumOfRTT_times' },
                                ],
                  closure_custom_calc => $self->can('custom_PercentagePacketsNegativeJitter_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'Percentage of Packets that had Negative Jitter : %.2f',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'prct_jitter_per_packet_negative_jitter', value => 'value', template => '%.2f',
                        label_extra_instance => 1,  },
                  ],
              }
          },
          { label => 'AverageJitterPerPacketNegativeJitter', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'SumOfNegativesSD_1' }, { name => 'SumOfNegativesSD_2' }, { name => 'SumOfNegativesSD_times' },
                                  { name => 'NumOfRTT_1' }, { name => 'NumOfRTT_2' }, { name => 'NumOfRTT_times' },
                                ],
                  closure_custom_calc => $self->can('custom_AverageJitterPerPacketNegativeJitter_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'Average Jitter per Packet that had Negative Jitter : %.2f',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'average_jitter_per_packet_negative_jitter', value => 'value', template => '%.2f',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'AverageJitter', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'SumOfPositivesDS_1' }, { name => 'SumOfPositivesDS_2' }, { name => 'SumOfPositivesDS_times' },
                                  { name => 'SumOfNegativesDS_1' }, { name => 'SumOfNegativesDS_2' }, { name => 'SumOfNegativesDS_times' },
                                  { name => 'SumOfPositivesSD_1' }, { name => 'SumOfPositivesSD_2' }, { name => 'SumOfPositivesSD_times' },
                                  { name => 'SumOfNegativesSD_1' }, { name => 'SumOfNegativesSD_2' }, { name => 'SumOfNegativesSD_times' },
                                  { name => 'NumOfPositivesDS_1' }, { name => 'NumOfPositivesDS_2' }, { name => 'NumOfPositivesDS_times' },
                                  { name => 'NumOfNegativesDS_1' }, { name => 'NumOfNegativesDS_2' }, { name => 'NumOfNegativesDS_times' },
                                  { name => 'NumOfPositivesSD_1' }, { name => 'NumOfPositivesSD_2' }, { name => 'NumOfPositivesSD_times' },
                                  { name => 'NumOfNegativesSD_1' }, { name => 'NumOfNegativesSD_2' }, { name => 'NumOfNegativesSD_times' },
                                ],
                  closure_custom_calc => $self->can('custom_AverageJitter_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'Average Jitter : %.2f ms',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'average_jitter', value => 'value', template => '%.2f', unit => 'ms',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'RTTStandardDeviation', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'RTTSum2High_1' }, { name => 'RTTSum2High_2' }, { name => 'RTTSum2High_times' },
                                  { name => 'RTTSum2Low_1' }, { name => 'RTTSum2Low_2' }, { name => 'RTTSum2Low_times' },
                                  { name => 'NumOfRTT_1' }, { name => 'NumOfRTT_2' }, { name => 'NumOfRTT_times' },
                                  { name => 'RTTSum_1' }, { name => 'RTTSum_2' }, { name => 'RTTSum_times' },
                                ],
                  closure_custom_calc => $self->can('custom_RTTStandardDeviation_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'Round-Trip Time Standard Deviation : %.2f ms',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'rtt_standard_deviation', value => 'value', template => '%.2f', unit => 'ms',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'DelaySource2DestinationStandardDeviation', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'OWSum2SDHigh_1' }, { name => 'OWSum2SDHigh_2' },  { name => 'OWSum2SDHigh_times' },
                                  { name => 'OWSum2SDLow_1' }, { name => 'OWSum2SDLow_2' },  { name => 'OWSum2SDLow_times' },
                                  { name => 'NumOfOW_1' }, { name => 'NumOfOW_2' },  { name => 'NumOfOW_times' },
                                  { name => 'OWSumSD_1' }, { name => 'OWSumSD_2' },  { name => 'OWSumSD_times' },
                                ],
                  closure_custom_calc => $self->can('custom_DelaySource2DestinationStandardDeviation_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'One-Way Delay Source to Destination Standard Deviation : %.2f ms',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'delay_src2dest_stdev', value => 'value', template => '%.2f', unit => 'ms',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'DelayDestination2SourceStandardDeviation', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'OWSum2DSHigh_1' }, { name => 'OWSum2DSHigh_2' }, { name => 'OWSum2DSHigh_times' },
                                  { name => 'OWSum2DSLow_1' }, { name => 'OWSum2DSLow_2' }, { name => 'OWSum2DSLow_times' },
                                  { name => 'NumOfOW_1' }, { name => 'NumOfOW_2' }, { name => 'NumOfOW_times' },
                                  { name => 'OWSumDS_1' }, { name => 'OWSumDS_2' }, { name => 'OWSumDS_times' },
                                ],
                  closure_custom_calc => $self->can('custom_DelayDestination2SourceStandardDeviation_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'One-Way Delay Destination to Source Standard Deviation : %.2f ms',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'delay_dest2src_stdev', value => 'value', template => '%.2f', unit => 'ms',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'JitterSource2DestinationStandardDeviation', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'Sum2PositivesSDHigh_1' }, { name => 'Sum2PositivesSDHigh_2' }, { name => 'Sum2PositivesSDHigh_times' },
                                  { name => 'Sum2PositivesSDLow_1' }, { name => 'Sum2PositivesSDLow_2' }, { name => 'Sum2PositivesSDLow_times' },
                                  { name => 'Sum2NegativesSDHigh_1' }, { name => 'Sum2NegativesSDHigh_2' }, { name => 'Sum2NegativesSDHigh_times' },
                                  { name => 'Sum2NegativesSDLow_1' }, { name => 'Sum2NegativesSDLow_2' }, { name => 'Sum2NegativesSDLow_times' },
                                  { name => 'SumOfPositivesSD_1' }, { name => 'SumOfPositivesSD_2' }, { name => 'SumOfPositivesSD_times' },
                                  { name => 'SumOfNegativesSD_1' }, { name => 'SumOfNegativesSD_2' }, { name => 'SumOfNegativesSD_times' },
                                  { name => 'NumOfPositivesSD_1' }, { name => 'NumOfPositivesSD_2' }, { name => 'NumOfPositivesSD_times' },
                                  { name => 'NumOfNegativesSD_1' }, { name => 'NumOfNegativesSD_2' }, { name => 'NumOfNegativesSD_times' },
                                  ],
                  closure_custom_calc => $self->can('custom_JitterSource2DestinationStandardDeviation_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'One-Way Jitter Source to Destination Standard Deviation : %.2f ms',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'jitter_src2dest_stdev', value => 'value', template => '%.2f', unit => 'ms',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'JitterDestination2SourceStandardDeviation', set => {
                  key_values => [ { name => 'rttMonCtrlAdminStatus' }, { name => 'rttMonCtrlAdminRttType' },
                                  { name => 'Sum2PositivesDSHigh_1' }, { name => 'Sum2PositivesDSHigh_2' }, { name => 'Sum2PositivesDSHigh_times' },
                                  { name => 'Sum2PositivesDSLow_1' }, { name => 'Sum2PositivesDSLow_2' }, { name => 'Sum2PositivesDSLow_times' },
                                  { name => 'Sum2NegativesDSHigh_1' }, { name => 'Sum2NegativesDSHigh_2' }, { name => 'Sum2NegativesDSHigh_times' },
                                  { name => 'Sum2NegativesDSLow_1' }, { name => 'Sum2NegativesDSLow_2' }, { name => 'Sum2NegativesDSLow_times' },
                                  { name => 'SumOfPositivesDS_1' }, { name => 'SumOfPositivesDS_2' }, { name => 'SumOfPositivesDS_times' },
                                  { name => 'SumOfNegativesDS_1' }, { name => 'SumOfNegativesDS_2' }, { name => 'SumOfNegativesDS_times' },
                                  { name => 'NumOfPositivesDS_1' }, { name => 'NumOfPositivesDS_2' }, { name => 'NumOfPositivesDS_times' },
                                  { name => 'NumOfNegativesDS_1' }, { name => 'NumOfNegativesDS_2' }, { name => 'NumOfNegativesDS_times' },
                                  ],
                  closure_custom_calc => $self->can('custom_JitterDestination2SourceStandardDeviation_calc'),
                  closure_custom_output => $self->can('custom_generic_output'),
                  output_template => 'One-Way Jitter Destination to Source Standard Deviation : %.2f ms',
                  threshold_use => 'value',
                  perfdatas => [
                      { label => 'jitter_dest2src_stdev', value => 'value', template => '%.2f', unit => 'ms',
                        label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_tag_output {
      my ($self, %options) = @_;
      
      return "RTT '" . $options{instance_value}->{rttMonCtrlAdminTag} . "' ";
  }
  
  my $ipsla;
  my $thresholds = {
      opersense => [
          ['ok', 'OK'],
          ['.*', 'CRITICAL'],
      ],
      applspecificsense => [
          ['.*', 'OK'],
      ],
  };
  
  ###### Common func ######
  
  sub get_my_delta {
      my ($self, %options) = @_;
      
      my $value;
      my ($old_time1, $old_time2) = split /_/, $options{old_datas}->{$self->{instance} . '_' . $options{name} . '_times'};
      my ($new_time1, $new_time2) = split /_/, $options{new_datas}->{$self->{instance} . '_' . $options{name} . '_times'};
      if (defined($old_time1) && defined($new_time1) && $old_time1 == $new_time1) {
          $value = $options{new_datas}->{$self->{instance} . '_' . $options{name} . '_1'} - $options{old_datas}->{$self->{instance} . '_' . $options{name} . '_1'} +
                   $options{new_datas}->{$self->{instance} . '_' . $options{name} . '_2'} - $options{old_datas}->{$self->{instance} . '_' . $options{name} . '_2'};
      } else {
          $value = $options{new_datas}->{$self->{instance} . '_' . $options{name} . '_1'} - $options{old_datas}->{$self->{instance} . '_' . $options{name} . '_2'} +
                   $options{new_datas}->{$self->{instance} . '_' . $options{name} . '_2'};
      }
      return $value;
  }
  
  sub custom_generic_output {
      my ($self, %options) = @_;
      
      return sprintf($self->{output_template}, $self->{result_values}->{value});
  }
  
  sub check_buffer_creation {
      my ($self, %options) = @_;
      
      if (!defined($options{old_datas}->{$self->{instance} . '_' . $options{name} . '_1'})) {
          $self->{error_msg} = "Buffer creation";
          return 1;
      }
      return 0;
  }
  
  ###### STATUS ######
  
  sub custom_status_threshold {
      my ($self, %options) = @_;
      my $status = 'ok';
      
      if ($self->{result_values}->{rttMonCtrlAdminStatus} !~ /active/) {
          return $status;
      }
     
      $status = $ipsla->get_severity(section => $self->{result_values}->{section}, value => $self->{result_values}->{opersense});
      return $status;
  }
  
  sub custom_status_output {
      my ($self, %options) = @_;
      my $msg = 'Status : ';
      
      if ($self->{result_values}->{rttMonCtrlAdminStatus} !~ /active/) {
          $msg .= 'not active (' . $self->{result_values}->{rttMonCtrlAdminStatus} . ')';
          return $msg;
      }
      $msg .= "operation sense is '" . $self->{result_values}->{opersense} . "'";
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{rttMonCtrlAdminStatus} = $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'};
      $self->{result_values}->{rttMonCtrlAdminTag} = $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminTag'};
      $self->{result_values}->{rttMonCtrlAdminRttType} = $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'};
      $self->{result_values}->{rttMonCtrlAdminThreshold} = $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminThreshold'};
      $self->{result_values}->{rttMonEchoAdminPrecision} = $options{new_datas}->{$self->{instance} . '_rttMonEchoAdminPrecision'};
      $self->{result_values}->{rttMonLatestRttOperCompletionTime} = $options{new_datas}->{$self->{instance} . '_rttMonLatestRttOperCompletionTime'};
      $self->{result_values}->{rttMonLatestRttOperSense} = $options{new_datas}->{$self->{instance} . '_rttMonLatestRttOperSense'};
      $self->{result_values}->{rttMonLatestRttOperApplSpecificSense} = $options{new_datas}->{$self->{instance} . '_rttMonLatestRttOperApplSpecificSense'};
      $self->{result_values}->{opersense} = $self->{result_values}->{rttMonLatestRttOperSense};
      $self->{result_values}->{section} = 'opersense';
      if ($self->{result_values}->{opersense} =~ /applicationSpecific/i) {
          $self->{result_values}->{opersense} = $self->{result_values}->{rttMonLatestRttOperApplSpecificSense};
          $self->{result_values}->{section} = 'applspecificsense';
      }
      return 0;
  }
  
  ####### 1 - Number Over Thresholds #######
  sub custom_NumberOverThresholds_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'OverThresholds'));
          
      $self->{result_values}->{value} = get_my_delta($self, %options, name => 'OverThresholds');
      return 0;
  }
  
  ####### 2 - Average Delay SD #######
  sub custom_AverageDelaySD_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'OWSumSD'));
      my $num_of_ow = get_my_delta($self, %options, name => 'NumOfOW');
      if ($num_of_ow == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
          
      $self->{result_values}->{value} = get_my_delta($self, %options, name => 'OWSumSD') / $num_of_ow;
      return 0;
  }
  
  ####### 3 - Average Delay DS #######
  sub custom_AverageDelayDS_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'OWSumDS'));
      my $num_of_ow = get_my_delta($self, %options, name => 'NumOfOW');
      if ($num_of_ow == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
          
      $self->{result_values}->{value} = get_my_delta($self, %options, name => 'OWSumDS') / $num_of_ow;
      return 0;
  }
  
  ####### 4 - Packet Loss Ratio   #######
  sub custom_PacketLossRatio_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'PacketLossDS'));
      my $divide = (get_my_delta($self, %options, name => 'PacketLossSD') + get_my_delta($self, %options, name => 'PacketLossDS') + get_my_delta($self, %options, name => 'PacketMIA') + 
                                          get_my_delta($self, %options, name => 'PacketLateArrival') + get_my_delta($self, %options, name => 'PacketOutOfSequence') + get_my_delta($self, %options, name => 'NumOfRTT'));
      if ($divide == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
      
      $self->{result_values}->{value} = ((get_my_delta($self, %options, name => 'PacketLossDS') + get_my_delta($self, %options, name => 'PacketLossSD') + get_my_delta($self, %options, name => 'PacketMIA')) * 100 ) / 
                                         $divide;
      return 0;
  }
  
  ####### 5 - Percentage of Packets that had Positive Jitter   #######
  sub custom_PercentagePacketsPositiveJitter_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'NumOfPositivesSD'));
      my $num_of_rtt = get_my_delta($self, %options, name => 'NumOfRTT');
      if ($num_of_rtt == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
          
      $self->{result_values}->{value} = get_my_delta($self, %options, name => 'NumOfPositivesSD') / $num_of_rtt;
      return 0;
  }
  
  ####### 6 - Average Jitter per Packet that had Positive Jitter   #######
  sub custom_AverageJitterPerPacketPositiveJitter_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'SumOfPositivesSD'));
      my $num_of_rtt = get_my_delta($self, %options, name => 'NumOfRTT');
      if ($num_of_rtt == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
          
      $self->{result_values}->{value} = get_my_delta($self, %options, name => 'SumOfPositivesSD') / $num_of_rtt;
      return 0;
  }
  
  ####### 7 - Percentage of Packets that had Negative Jitter   #######
  sub custom_PercentagePacketsNegativeJitter_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'NumOfNegativesSD'));
      my $num_of_rtt = get_my_delta($self, %options, name => 'NumOfRTT');
      if ($num_of_rtt == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
          
      $self->{result_values}->{value} = get_my_delta($self, %options, name => 'NumOfNegativesSD') / $num_of_rtt;
      return 0;
  }
  
  ####### 8 - Average Jitter per Packet that had Negative Jitter   #######
  sub custom_AverageJitterPerPacketNegativeJitter_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'SumOfNegativesSD'));
      my $num_of_rtt = get_my_delta($self, %options, name => 'NumOfRTT');
      if ($num_of_rtt == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
          
      $self->{result_values}->{value} = get_my_delta($self, %options, name => 'SumOfNegativesSD') / $num_of_rtt;
      return 0;
  }
  
  ####### 9 - Average Jitter   #######
  sub custom_AverageJitter_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'SumOfPositivesDS'));
      my $divide = (get_my_delta($self, %options, name => 'NumOfPositivesDS') + get_my_delta($self, %options, name => 'NumOfNegativesDS') + get_my_delta($self, %options, name => 'NumOfPositivesSD') + get_my_delta($self, %options, name => 'NumOfNegativesSD'));
      if ($divide == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
  
      $self->{result_values}->{value} = (get_my_delta($self, %options, name => 'SumOfPositivesDS') + get_my_delta($self, %options, name => 'SumOfNegativesDS') + get_my_delta($self, %options, name => 'SumOfPositivesSD') + get_my_delta($self, %options, name => 'SumOfNegativesSD')) / 
                                        $divide;
      return 0;
  }
  
  ####### 10 - Round-Trip Time Standard Deviation   #######
  sub custom_RTTStandardDeviation_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'NumOfRTT'));
      my $num_of_rtt = get_my_delta($self, %options, name => 'NumOfRTT');
      if ($num_of_rtt == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
          
      $self->{result_values}->{value} = sqrt ( ((get_my_delta($self, %options, name => 'RTTSum2High') * 2 ** 32 + get_my_delta($self, %options, name => 'RTTSum2Low')) 
                                                  / $num_of_rtt) - (get_my_delta($self, %options, name => 'RTTSum') / $num_of_rtt) ** 2
                                        );
      return 0;
  }
  
  ####### 11 - One-Way Delay Source to Destination Standard Deviation  #######
  sub custom_DelaySource2DestinationStandardDeviation_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'NumOfOW'));
      my $num_of_ow = get_my_delta($self, %options, name => 'NumOfOW');
      if ($num_of_ow == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
          
      $self->{result_values}->{value} = sqrt ( ((get_my_delta($self, %options, name => 'OWSum2SDHigh') * 2 ** 32 + get_my_delta($self, %options, name => 'OWSum2SDLow')) / 
                                                  $num_of_ow) - (get_my_delta($self, %options, name => 'OWSumSD') / $num_of_ow) ** 2
                                        );
      return 0;
  }
  
  ####### 12 - One-Way Delay Destination to Source Standard Deviation  #######
  sub custom_DelayDestination2SourceStandardDeviation_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'NumOfOW'));
      my $num_of_ow = get_my_delta($self, %options, name => 'NumOfOW');
      if ($num_of_ow == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
          
      $self->{result_values}->{value} = sqrt ( ((get_my_delta($self, %options, name => 'OWSum2DSHigh') * 2 ** 32 + get_my_delta($self, %options, name => 'OWSum2DSLow')) / 
                                                  $num_of_ow) - (get_my_delta($self, %options, name => 'OWSumDS') / $num_of_ow) ** 2
                                        );
      return 0;
  }
  
  ####### 13 - One-Way Jitter Source to Destination Standard Deviation #######
  sub custom_JitterSource2DestinationStandardDeviation_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'NumOfPositivesSD'));
      my $divide = (get_my_delta($self, %options, name => 'NumOfPositivesSD') + get_my_delta($self, %options, name => 'NumOfNegativesSD'));
      if ($divide == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
          
      $self->{result_values}->{value} = sqrt ( ((get_my_delta($self, %options, name => 'Sum2PositivesSDHigh') * 2 ** 32 + get_my_delta($self, %options, name => 'Sum2PositivesSDLow') + get_my_delta($self, %options, name => 'Sum2NegativesSDHigh') * 2 ** 32 + get_my_delta($self, %options, name => 'Sum2NegativesSDLow')) 
                                          / $divide) - 
                                          ((get_my_delta($self, %options, name => 'SumOfPositivesSD') + get_my_delta($self, %options, name => 'SumOfNegativesSD')) / 
                                          $divide) ** 2
                                        );
      return 0;
  }
  
  ####### 14 - JitterDestination2SourceStandardDeviation #######
  sub custom_JitterDestination2SourceStandardDeviation_calc {
      my ($self, %options) = @_;
  
      if ($options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminStatus'} !~ /active/ && 
          $options{new_datas}->{$self->{instance} . '_rttMonCtrlAdminRttType'} !~ /jitter/) {
          return -2;
      }
      return -1 if (check_buffer_creation($self, %options, name => 'NumOfPositivesDS'));
      my $divide = (get_my_delta($self, %options, name => 'NumOfPositivesDS') + get_my_delta($self, %options, name => 'NumOfNegativesDS'));
      if ($divide == 0) {
          $self->{error_msg} = "wait new values";
          return -3;
      }
          
      $self->{result_values}->{value} = sqrt ( ((get_my_delta($self, %options, name => 'Sum2PositivesDSHigh') * 2 ** 32 + get_my_delta($self, %options, name => 'Sum2PositivesDSLow') + get_my_delta($self, %options, name => 'Sum2NegativesDSHigh') * 2 ** 32 + get_my_delta($self, %options, name => 'Sum2NegativesDSLow')) 
                                          / $divide) - 
                                          ((get_my_delta($self, %options, name => 'SumOfPositivesDS') + get_my_delta($self, %options, name => 'SumOfNegativesDS')) / 
                                          $divide) ** 2
                                        );
      return 0;
  }
  
  my $oid_rttMonCtrlAdminEntry        = '.1.3.6.1.4.1.9.9.42.1.2.1.1';
  my $oid_rttMonEchoAdminPrecision    = '.1.3.6.1.4.1.9.9.42.1.2.2.1.37';
  
  my $oid_rttMonLatestRttOperEntry    = '.1.3.6.1.4.1.9.9.42.1.2.10.1';
  
  # Packet Loss Ratio (unit: %):
  #    [(RttMonJitterStatsPacketLossDS + RttMonJitterStatsPacketLossSD + RttMonJitterStatsPacketMIA) * 100 ] / 
  #           [RttMonJitterStatsPacketLossSD + RttMonJitterStatsPacketLossDS + RttMonJitterStatsPacketMIA + 
  #            RttMonJitterStatsPacketLateArrival + RttMonJitterStatsPacketOutOfSequence + RttMonJitterStatsNumOfRTT ]
  
  # Percentage (unit: %):
  #    NumOfPositiveSD/NumOfRTT (Percentage of Packets that had Positive Jitter)
  #    SumOfPositiveSD/NumOfRTT (Average Jitter per Packet that had Positive Jitter)
  #    NumOfNegativeSD/NumOfRTT (Percentage of Packets that had Negative Jitter)
  #    SumOfNegativeSD/NumOfRTT (Average Jitter per Packet that had Negative Jitter)
  #    
  # Average Jitter (unit: ms):
  #  jitterSum = sumOfPositivesDS + sumOfNegativesDS + sumOfPositivesSD + sumOfNegativesSD;
  #  jitterNum = numOfPositivesDS + numOfNegativesDS + numOfPositivesSD + numOfNegativesSD;
  #  avgJitter = jitterSum/jitterNum;
  
  # Delays (unit: ms):
  #   RttMonJitterStatsOWSumSD / RttMonJitterStatsNumOfOW
  #   RttMonJitterStatsOWSumDS / RttMonJitterStatsNumOfOW
  
  # Round-Trip Time Standard Deviation (unit: ms):
  #   Square Root of [ ((RttMonJitterStatsRTTSum2High * 2^32 + RttMonJitterStatsRTTSum2Low) / RttMonJitterStatsNumOfRTT) - (RttMonJitterStatsRTTSum / RttMonJitterStatsNumOfRTT)^2 ]
  # One-Way Delay Source to Destination Standard Deviation (unit: ms):
  #    Square Root of [ ((RttMonJitterStatsOWSum2SDHigh * 2^32 + RttMonJitterStatsOWSum2SDLow) / RttMonJitterStatsNumOfOW) - (RttMonJitterStatsOWSumSD / RttMonJitterStatsNumOfOW)^2 ]
  # One-Way Delay Destination to Source Standard Deviation (unit: ms):
  #    Square Root of [ ((RttMonJitterStatsOWSum2DSHigh * 2^32 + RttMonJitterStatsOWSum2DSLow) / RttMonJitterStatsNumOfOW) - (RttMonJitterStatsOWSumDS / RttMonJitterStatsNumOfOW)^2 ]
  # One-Way Jitter Source to Destination Standard Deviation (unit: ms):
  #    Square Root of [ ((RttMonJitterStatsSum2PositivesSDHigh * 2^32 + RttMonJitterStatsSum2PositivesSDLow + RttMonJitterStatsSum2NegativesSDHigh * 2^32 + RttMonJitterStatsSum2NegativesSDLow) / (RttMonJitterStatsNumOfPositivesSD + RttMonJitterStatsNumOfNegativesSD)) - ((RttMonJitterStatsSumOfPositivesSD + RttMonJitterStatsSumOfNegativesSD) / (RttMonJitterStatsNumOfPositivesSD + RttMonJitterStatsNumOfNegativesSD))^2 ]
  # One-Way Jitter Destination to Source Standard Deviation (unit: ms):
  #    Square Root of [ ((RttMonJitterStatsSum2PositivesDSHigh * 2^32 + RttMonJitterStatsSum2PositivesDSLow + RttMonJitterStatsSum2NegativesDSHigh * 2^32 + RttMonJitterStatsSum2NegativesDSLow) / (RttMonJitterStatsNumOfPositivesDS + RttMonJitterStatsNumOfNegativesDS)) - ((RttMonJitterStatsSumOfPositivesDS + RttMonJitterStatsSumOfNegativesDS) / (RttMonJitterStatsNumOfPositivesDS + RttMonJitterStatsNumOfNegativesDS))^2 ]
  
  my $oid_rttMonJitterStatsEntry  = '.1.3.6.1.4.1.9.9.42.1.3.5.1';
  my $oids_jitter_stats = {
      NumOfRTT          => '.1.3.6.1.4.1.9.9.42.1.3.5.1.4',
      OverThresholds         => '.1.3.6.1.4.1.9.9.42.1.3.5.1.3',
      RTTSum                 => '.1.3.6.1.4.1.9.9.42.1.3.5.1.5',
      RTTSum2Low             => '.1.3.6.1.4.1.9.9.42.1.3.5.1.6',
      RTTSum2High            => '.1.3.6.1.4.1.9.9.42.1.3.5.1.7',
      NumOfOW                => '.1.3.6.1.4.1.9.9.42.1.3.5.1.51',
      OWSumSD                => '.1.3.6.1.4.1.9.9.42.1.3.5.1.41', # low
      OWSumSDHigh            => '.1.3.6.1.4.1.9.9.42.1.3.5.1.67', # high
      OWSumDS                => '.1.3.6.1.4.1.9.9.42.1.3.5.1.46', # low
      OWSumDSHigh            => '.1.3.6.1.4.1.9.9.42.1.3.5.1.68', # high
      SumOfPositivesSD       => '.1.3.6.1.4.1.9.9.42.1.3.5.1.13',
      SumOfNegativesSD       => '.1.3.6.1.4.1.9.9.42.1.3.5.1.19',
      SumOfPositivesDS       => '.1.3.6.1.4.1.9.9.42.1.3.5.1.25',
      SumOfNegativesDS       => '.1.3.6.1.4.1.9.9.42.1.3.5.1.31',
      NumOfNegativesSD       => '.1.3.6.1.4.1.9.9.42.1.3.5.1.18',
      Sum2NegativesSDLow     => '.1.3.6.1.4.1.9.9.42.1.3.5.1.20',
      Sum2NegativesSDHigh    => '.1.3.6.1.4.1.9.9.42.1.3.5.1.21',
      NumOfNegativesDS       => '.1.3.6.1.4.1.9.9.42.1.3.5.1.30',
      Sum2NegativesDSLow     => '.1.3.6.1.4.1.9.9.42.1.3.5.1.32',
      Sum2NegativesDSHigh    => '.1.3.6.1.4.1.9.9.42.1.3.5.1.33',
      NumOfPositivesSD       => '.1.3.6.1.4.1.9.9.42.1.3.5.1.12',
      Sum2PositivesSDLow     => '.1.3.6.1.4.1.9.9.42.1.3.5.1.14',
      Sum2PositivesSDHigh    => '.1.3.6.1.4.1.9.9.42.1.3.5.1.15',
      NumOfPositivesDS       => '.1.3.6.1.4.1.9.9.42.1.3.5.1.24',
      Sum2PositivesDSLow     => '.1.3.6.1.4.1.9.9.42.1.3.5.1.26',
      Sum2PositivesDSHigh    => '.1.3.6.1.4.1.9.9.42.1.3.5.1.27',
      PacketLossSD           => '.1.3.6.1.4.1.9.9.42.1.3.5.1.34',
      PacketLossDS           => '.1.3.6.1.4.1.9.9.42.1.3.5.1.35',
      PacketOutOfSequence    => '.1.3.6.1.4.1.9.9.42.1.3.5.1.36',
      PacketMIA              => '.1.3.6.1.4.1.9.9.42.1.3.5.1.37',
      PacketLateArrival      => '.1.3.6.1.4.1.9.9.42.1.3.5.1.38',
      OWSum2SDLow            => '.1.3.6.1.4.1.9.9.42.1.3.5.1.42',
      OWSum2SDHigh           => '.1.3.6.1.4.1.9.9.42.1.3.5.1.43',
      OWSum2DSLow            => '.1.3.6.1.4.1.9.9.42.1.3.5.1.47',
      OWSum2DSHigh           => '.1.3.6.1.4.1.9.9.42.1.3.5.1.48',
      MaxOfICPIF             => '.1.3.6.1.4.1.9.9.42.1.3.5.1.59',
      MaxOfMOS               => '.1.3.6.1.4.1.9.9.42.1.3.5.1.57',
  };
  
  my %map_admin_rtt_type = (
      1 => 'echo1', 2 => 'pathEcho', 3 => 'fileIO', 4 => 'script', 5 => 'udpEcho', 6 => 'tcpConnect',
      7 => 'http', 8 => 'dns', 9 => 'jitter', 10 => 'dlsw', 11 => 'dhcp', 12 => 'ftp',
      13 => 'voip', 14 => 'rtp', 15 => 'lspGroup', 16 => 'icmpjitter', 17 => 'lspPing',
      18 => 'lspTrace', 19 => 'ethernetPing', 20 => 'ethernetJitter',
      21 => 'lspPingPseudowire', 22 => 'video', 23 => 'y1731Delay', 24 => 'y1731Loss', 25 => 'mcastJitter',
  );
  my %map_admin_status = (
      1 => 'active', 2 => 'notInService', 3 => 'notReady', 4 => 'createAndGo', 5 => 'createAndWait', 6 => 'destroy',
  );
  my %map_admin_precision = (
      1 => 'ms',
      2 => 'us',
  );
  my %map_rtt_oper_sense = (
      0 => 'other', 1 => 'ok', 2 => 'disconnected', 3 => 'overThreshold', 4 => 'timeout', 5 => 'busy',
      6 => 'notConnected', 7 => 'dropped', 8 => 'sequenceError', 9 => 'verifyError', 10 => 'applicationSpecific',
      11 => 'dnsServerTimeout', 12 => 'tcpConnectTimeout', 13 => 'httpTransactionTimeout', 14 => 'dnsQueryError',
      15 => 'httpError', 16 => 'error', 17 => 'mplsLspEchoTxError', 18 => 'mplsLspUnreachable',
      19 => 'mplsLspMalformedReq', 20 => 'mplsLspReachButNotFEC', 21 => 'enableOk', 22 => 'enableNoConnect',
      23 => 'enableVersionFail', 24 => 'enableInternalError', 25 => 'enableAbort', 26 => 'enableFail',
      27 => 'enableAuthFail', 28 => 'enableFormatError', 29 => 'enablePortInUse', 30 => 'statsRetrieveOk',
      31 => 'statsRetrieveNoConnect', 32 => 'statsRetrieveVersionFail', 33 => 'statsRetrieveInternalError',
      34 => 'statsRetrieveAbort', 35 => 'statsRetrieveFail', 36 => 'statsRetrieveAuthFail',
      37 => 'statsRetrieveFormatError', 38 => 'statsRetrievePortInUse',
  );
  
  my $mapping = {
      rttMonCtrlAdminTag          => { oid => '.1.3.6.1.4.1.9.9.42.1.2.1.1.3' },
      rttMonCtrlAdminRttType      => { oid => '.1.3.6.1.4.1.9.9.42.1.2.1.1.4', map => \%map_admin_rtt_type },
      rttMonCtrlAdminThreshold    => { oid => '.1.3.6.1.4.1.9.9.42.1.2.1.1.5' },
      rttMonCtrlAdminStatus       => { oid => '.1.3.6.1.4.1.9.9.42.1.2.1.1.9', map => \%map_admin_status },
  };
  my $mapping2 = {
      rttMonEchoAdminPrecision    => { oid => '.1.3.6.1.4.1.9.9.42.1.2.2.1.37', map => \%map_admin_precision },
  };
  my $mapping3 = {
      rttMonLatestRttOperCompletionTime       => { oid => '.1.3.6.1.4.1.9.9.42.1.2.10.1.1' },
      rttMonLatestRttOperSense                => { oid => '.1.3.6.1.4.1.9.9.42.1.2.10.1.2', map => \%map_rtt_oper_sense },
      rttMonLatestRttOperApplSpecificSense    => { oid => '.1.3.6.1.4.1.9.9.42.1.2.10.1.3' },
  };
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                  "filter-tag:s"          => { name => 'filter_tag', default => '.*' },
                                  "threshold-overload:s@" => { name => 'threshold_overload' },
                                  });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->{overload_th} = {};
      foreach my $val (@{$self->{option_results}->{threshold_overload}}) {
          if ($val !~ /^(.*?),(.*?),(.*)$/) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload option '" . $val . "'.");
              $self->{output}->option_exit();
          }
          my ($section, $status, $filter) = ($1, $2, $3);
          if ($self->{output}->is_litteral_status(status => $status) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload status '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->{overload_th}->{$section} = [] if (!defined($self->{overload_th}->{$section}));
          push @{$self->{overload_th}->{$section}}, {filter => $filter, status => $status};
      }
      
      # to be used on custom function
      $ipsla = $self;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{cache_name} = "cache_cisco_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' .
          (defined($self->{option_results}->{filter_tag}) ? md5_hex($self->{option_results}->{filter_tag}) : md5_hex('all')) . '_' .
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
      
      $self->{results} = $options{snmp}->get_multiple_table(oids => [ { oid => $oid_rttMonCtrlAdminEntry },
                                                                     { oid => $oid_rttMonEchoAdminPrecision },
                                                                     { oid => $oid_rttMonLatestRttOperEntry },
                                                                     { oid => $oid_rttMonJitterStatsEntry },
                                                                   ],
                                                            nothing_quit => 1);
      
      $self->{tag} = {};
      foreach my $oid ($options{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_rttMonCtrlAdminEntry}})) {
          next if ($oid !~ /^$mapping->{rttMonCtrlAdminTag}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_rttMonCtrlAdminEntry}, instance => $instance);
          my $tag_name = $result->{rttMonCtrlAdminTag};
          if (!defined($tag_name) || $tag_name eq '') {
              $self->{output}->output_add(long_msg => "skipping: please set a tag name");
              next;
          }
          if (defined($self->{tag}->{$tag_name})) {
              $self->{output}->output_add(long_msg => "skipping  '" . $tag_name . "': duplicate (please change the tag name).");
              next;
          }
          if (defined($self->{option_results}->{filter_tag}) && $self->{option_results}->{filter_tag} ne '' &&
              $tag_name !~ /$self->{option_results}->{filter_tag}/) {
              $self->{output}->output_add(long_msg => "skipping  '" . $tag_name . "': no matching filter.");
              next;
          }
          $self->{tag}->{$tag_name} = { %{$result} };
          $result = $options{snmp}->map_instance(mapping => $mapping2, results => $self->{results}->{$oid_rttMonEchoAdminPrecision}, instance => $instance);
          $self->{tag}->{$tag_name} = { %{$result}, %{$self->{tag}->{$tag_name}} };
          $result = $options{snmp}->map_instance(mapping => $mapping3, results => $self->{results}->{$oid_rttMonLatestRttOperEntry}, instance => $instance);
          $self->{tag}->{$tag_name} = { %{$result}, %{$self->{tag}->{$tag_name}} };
          
          # there are two entries with rotation: 1 -> last hour, 2 -> current hour.
          foreach my $key (keys %{$oids_jitter_stats}) {
              $self->{tag}->{$tag_name}->{$key . '_1'} = 0;
              $self->{tag}->{$tag_name}->{$key . '_2'} = 0;
              my $i = 1;
              my $instances = [];
              foreach my $oid2 ($options{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_rttMonJitterStatsEntry}})) {
                  next if ($oid2 !~ /^$oids_jitter_stats->{$key}\.$instance.(\d+)/);
                  push @{$instances}, $1;
                  $self->{tag}->{$tag_name}->{$key . '_' . $i} = $self->{results}->{$oid_rttMonJitterStatsEntry}->{$oid2};
                  $i++;
              }
              $self->{tag}->{$tag_name}->{$key . '_times'} = join('_', @{$instances});
          }        
      }
      
      if (scalar(keys %{$self->{tag}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No entry found.");
          $self->{output}->option_exit();
      } 
  }
  
  sub get_severity {
      my ($self, %options) = @_;
      my $status = 'UNKNOWN'; # default 
      
      if (defined($self->{overload_th}->{$options{section}})) {
          foreach (@{$self->{overload_th}->{$options{section}}}) {            
              if ($options{value} =~ /$_->{filter}/i) {
                  $status = $_->{status};
                  return $status;
              }
          }
      }
      foreach (@{$thresholds->{$options{section}}}) {           
          if ($options{value} =~ /$$_[0]/i) {
              $status = $$_[1];
              return $status;
          }
      }
      
      return $status;
  }
  
  1;
  
  
  =head1 MODE
  
  Check RTT Controls (CISCO-RTT-MON)
  
  =over 8
  
  =item B<--filter-tag>
  
  Filter tag (Default: '.*')
  
  =item B<--threshold-overload>
  
  Set to overload default threshold values (syntax: section,status,regexp)
  It used before default thresholds (order stays).
  Example: --threshold-overload='opersense,CRITICAL,^(?!(ok)$)'
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'CompletionTime', 'NumberOverThresholds', 'AverageDelaySD', 'AverageDelayDS', 'PacketLossRatio', 
  'PercentagePacketsPositiveJitter', 'AverageJitterPerPacketPositiveJitter', 'PercentagePacketsNegativeJitter', 'AverageJitterPerPacketNegativeJitter',
  'AverageJitter', 'RTTStandardDeviation', 'DelaySource2DestinationStandardDeviation', 'DelayDestination2SourceStandardDeviation', 
  'JitterSource2DestinationStandardDeviation', 'JitterDestination2SourceStandardDeviation'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'CompletionTime', 'NumberOverThresholds', 'AverageDelaySD', 'AverageDelayDS', 'PacketLossRatio', 
  'PercentagePacketsPositiveJitter', 'AverageJitterPerPacketPositiveJitter', 'PercentagePacketsNegativeJitter', 'AverageJitterPerPacketNegativeJitter',
  'AverageJitter', 'RTTStandardDeviation', 'DelaySource2DestinationStandardDeviation', 'DelayDestination2SourceStandardDeviation', 
  'JitterSource2DestinationStandardDeviation', 'JitterDestination2SourceStandardDeviation'.
  
  =back
  
  =cut
      
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_IPSLA

$fatpacked{"centreon/common/cisco/standard/snmp/mode/memory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_MEMORY';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::memory;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub custom_usage_perfdata {
      my ($self, %options) = @_;
  
      my ($label, $nlabel, $unit, $total) = ('used', $self->{nlabel}, '%', 100);
      my $value_perf = $self->{result_values}->{prct_used};
      my %total_options = ();
      if ($self->{result_values}->{total} != -1) {
          $nlabel = 'memory.usage.bytes';
          $unit = 'B';
          $total = $self->{result_values}->{total};
          $total_options{total} = $self->{result_values}->{total};
          $total_options{cast_int} = 1;
          $value_perf = $self->{result_values}->{used};
      }
  
      $self->{output}->perfdata_add(
          label => $label, unit => $unit,
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
          nlabel => $nlabel,
          value => $value_perf,
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}, %total_options),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}, %total_options),
          min => 0, max => $total
      );
  }
  
  sub custom_usage_threshold {
      my ($self, %options) = @_;
  
      return $self->{perfdata}->threshold_check(value => $self->{result_values}->{prct_used}, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' } ]);
  }
  
  sub custom_usage_output {
      my ($self, %options) = @_;
  
      my $msg;
      if ($self->{result_values}->{total} != -1) {
          my ($total_size_value, $total_size_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{total});
          my ($total_used_value, $total_used_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{used});
          my ($total_free_value, $total_free_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{free});
          $msg = sprintf("Usage Total: %s Used: %s (%.2f%%) Free: %s (%.2f%%)",
                         $total_size_value . " " . $total_size_unit,
                         $total_used_value . " " . $total_used_unit, $self->{result_values}->{prct_used},
                         $total_free_value . " " . $total_free_unit, $self->{result_values}->{prct_free});
      } else {
          $msg = sprintf("Usage : %.2f %%", $self->{result_values}->{prct_used});
      }
      return $msg;
  }
  
  sub custom_usage_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{prct_used} = $options{new_datas}->{$self->{instance} . '_prct_used'};
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_total'};
      $self->{result_values}->{used} = $options{new_datas}->{$self->{instance} . '_used'};
      if ($self->{result_values}->{total} != -1) {
          $self->{result_values}->{free} = $self->{result_values}->{total} - $self->{result_values}->{used};
          $self->{result_values}->{prct_used} = $self->{result_values}->{used} * 100 / $self->{result_values}->{total};
          $self->{result_values}->{prct_free} = 100 - $self->{result_values}->{prct_used};
      }
  
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'memory', type => 1, cb_prefix_output => 'prefix_memory_output', message_multiple => 'All memories are ok', skipped_code => { -10 => 1 } },
      ];
      
      $self->{maps_counters}->{memory} = [
          { label => 'usage', nlabel => 'memory.usage.percentage', set => {
                  key_values => [ { name => 'display' }, { name => 'used' }, { name => 'total' }, { name => 'prct_used' } ],
                  closure_custom_calc => $self->can('custom_usage_calc'),
                  closure_custom_output => $self->can('custom_usage_output'),
                  closure_custom_perfdata => $self->can('custom_usage_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_usage_threshold'),
              }
          },
      ];
  }
  
  sub prefix_memory_output {
      my ($self, %options) = @_;
      
      return "Memory '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'filter-pool:s'     => { name => 'filter_pool' },
          'check-order:s'     => { name => 'check_order', default => 'enhanced_pool,pool,process,system_ext' },
      });
  
      return $self;
  }
  
  my $mapping_memory_pool = {
      ciscoMemoryPoolName   => { oid => '.1.3.6.1.4.1.9.9.48.1.1.1.2' },
      ciscoMemoryPoolUsed   => { oid => '.1.3.6.1.4.1.9.9.48.1.1.1.5' }, # in B
      ciscoMemoryPoolFree   => { oid => '.1.3.6.1.4.1.9.9.48.1.1.1.6' }, # in B
  };
  my $oid_ciscoMemoryPoolEntry = '.1.3.6.1.4.1.9.9.48.1.1.1';
  
  sub check_memory_pool {
      my ($self, %options) = @_;
  
      return if ($self->{checked_memory} == 1);
      
      my $snmp_result = $self->{snmp}->get_table(
          oid => $oid_ciscoMemoryPoolEntry,
          start => $mapping_memory_pool->{ciscoMemoryPoolName}->{oid}, end => $mapping_memory_pool->{ciscoMemoryPoolFree}->{oid}
      );
      
      foreach my $oid (keys %{$snmp_result}) {
          next if ($oid !~ /^$mapping_memory_pool->{ciscoMemoryPoolName}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $self->{snmp}->map_instance(mapping => $mapping_memory_pool, results => $snmp_result, instance => $instance);
  
          $self->{checked_memory} = 1;
          if (defined($self->{option_results}->{filter_pool}) && $self->{option_results}->{filter_pool} ne '' &&
              $result->{ciscoMemoryPoolName} !~ /$self->{option_results}->{filter_pool}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $result->{ciscoMemoryPoolName} . "': no matching filter.", debug => 1);
              next;
          }
  
          $self->{memory}->{$instance} = {
              display => $result->{ciscoMemoryPoolName},
              total => $result->{ciscoMemoryPoolFree} + $result->{ciscoMemoryPoolUsed},
              used => $result->{ciscoMemoryPoolUsed},
              prct_used => -1,
          };
      }
  }
  
  my $oid_cseSysMemoryUtilization = '.1.3.6.1.4.1.9.9.305.1.1.2';
  
  sub check_memory_system_ext {
      my ($self, %options) = @_;
      
      return if ($self->{checked_memory} == 1);
      
      my $snmp_result = $self->{snmp}->get_table(
          oid => $oid_cseSysMemoryUtilization,
      );
      
      foreach my $oid (keys %{$snmp_result}) {
          my $used = $snmp_result->{$oid};
          next if ($used eq '');
          my $display = 'system';
  
          $self->{checked_memory} = 1;
          if (defined($self->{option_results}->{filter_pool}) && $self->{option_results}->{filter_pool} ne '' &&
              $display !~ /$self->{option_results}->{filter_pool}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $display . "': no matching filter.", debug => 1);
              next;
          }
  
          $self->{memory}->{system} = {
              display => 'system',
              total => -1,
              used => -1,
              prct_used => $used,
          };
      }
  }
  
  my $mapping_enh_memory_pool = {
      cempMemPoolName     => { oid => '.1.3.6.1.4.1.9.9.221.1.1.1.1.3' },
      cempMemPoolUsed     => { oid => '.1.3.6.1.4.1.9.9.221.1.1.1.1.7' }, # in B
      cempMemPoolFree     => { oid => '.1.3.6.1.4.1.9.9.221.1.1.1.1.8' }, # in B
      cempMemPoolHCUsed   => { oid => '.1.3.6.1.4.1.9.9.221.1.1.1.1.18' }, # in B
      cempMemPoolHCFree   => { oid => '.1.3.6.1.4.1.9.9.221.1.1.1.1.20' }, # in B
  };
  
  sub check_memory_enhanced_pool {
      my ($self, %options) = @_;
  
      return if ($self->{checked_memory} == 1);
      
      my $oids = [
          { oid => $mapping_enh_memory_pool->{cempMemPoolName}->{oid} },
          { oid => $mapping_enh_memory_pool->{cempMemPoolUsed}->{oid} },
          { oid => $mapping_enh_memory_pool->{cempMemPoolFree}->{oid} },
      ];
      if (!$self->{snmp}->is_snmpv1()) {
          push @{$oids}, { oid => $mapping_enh_memory_pool->{cempMemPoolHCUsed}->{oid} }, 
              { oid => $mapping_enh_memory_pool->{cempMemPoolHCFree}->{oid} };
      }
      my $snmp_result = $self->{snmp}->get_multiple_table(
          oids => $oids,
          return_type => 1
      );
      
      foreach my $oid (keys %{$snmp_result}) {
          next if ($oid !~ /^$mapping_enh_memory_pool->{cempMemPoolName}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $self->{snmp}->map_instance(mapping => $mapping_enh_memory_pool, results => $snmp_result, instance => $instance);
  
          $self->{checked_memory} = 1;
          if (defined($self->{option_results}->{filter_pool}) && $self->{option_results}->{filter_pool} ne '' &&
              $result->{cempMemPoolName} !~ /$self->{option_results}->{filter_pool}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $result->{cempMemPoolName} . "': no matching filter.", debug => 1);
              next;
          }
  
          my $used = defined($result->{cempMemPoolHCUsed}) ? $result->{cempMemPoolHCUsed} : $result->{cempMemPoolUsed};
          my $free = defined($result->{cempMemPoolHCFree}) ? $result->{cempMemPoolHCFree} : $result->{cempMemPoolFree};
          $self->{memory}->{$instance} = {
              display => $result->{cempMemPoolName},
              total => $used + $free,
              used => $used,
              prct_used => -1,
          };
      }
  }
  
  my $mapping_memory_process = {
      cpmCPUMemoryUsed        => { oid => '.1.3.6.1.4.1.9.9.109.1.1.1.1.12' }, # in KB
      cpmCPUMemoryFree        => { oid => '.1.3.6.1.4.1.9.9.109.1.1.1.1.13' }, # in KB
      cpmCPUMemoryUsedOvrflw  => { oid => '.1.3.6.1.4.1.9.9.109.1.1.1.1.16' }, # in KB
      cpmCPUMemoryFreeOvrflw  => { oid => '.1.3.6.1.4.1.9.9.109.1.1.1.1.18' }, # in KB
  };
  
  sub check_memory_process {
      my ($self, %options) = @_;
  
      return if ($self->{checked_memory} == 1);
  
      my $oid_cpmCPUTotalEntry = '.1.3.6.1.4.1.9.9.109.1.1.1.1';
      my $snmp_result = $self->{snmp}->get_table(
          oid => $oid_cpmCPUTotalEntry, 
          start => $mapping_memory_process->{cpmCPUMemoryUsed}->{oid},
          end => $mapping_memory_process->{cpmCPUMemoryFreeOvrflw}->{oid},
      );
      
      foreach my $oid (keys %{$snmp_result}) {
          next if ($oid !~ /^$mapping_memory_process->{cpmCPUMemoryUsed}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $self->{snmp}->map_instance(mapping => $mapping_memory_process, results => $snmp_result, instance => $instance);
  
          $self->{checked_memory} = 1;
  
          my $used = (
              defined($result->{cpmCPUMemoryUsedOvrflw}) ? 
              ($result->{cpmCPUMemoryUsedOvrflw} << 32) + ($result->{cpmCPUMemoryUsed}) :
              $result->{cpmCPUMemoryUsed}
          ) * 1024;
          my $free = (
              defined($result->{cpmCPUMemoryFreeOvrflw}) ? 
              ($result->{cpmCPUMemoryFreeOvrflw} << 32) + ($result->{cpmCPUMemoryFree}) :
              $result->{cpmCPUMemoryFree}
          ) * 1024;
          $self->{memory}->{$instance} = {
              display => $instance,
              total => $used + $free,
              used => $used,
              prct_used => -1,
          };
      }
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{snmp} = $options{snmp};
      $self->{checked_memory} = 0;
      $self->{memory} = {};
  
      foreach (split /,/, $self->{option_results}->{check_order}) {
          my $method = $self->can('check_memory_' . $_);
          if ($method) {
              $self->$method();
          }
      }
  
      if ($self->{checked_memory} == 0) {
          $self->{output}->add_option_msg(short_msg => "Cannot find memory informations");
          $self->{output}->option_exit();
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check memory usage (CISCO-MEMORY-POOL-MIB, CISCO-ENHANCED-MEMPOOL-MIB, CISCO-PROCESS-MIB, CISCO-SYSTEM-EXT-MIB).
  
  =over 8
  
  =item B<--warning-usage>
  
  Threshold warning in percent.
  
  =item B<--critical-usage>
  
  Threshold critical in percent.
  
  =item B<--filter-pool>
  
  Filter pool to check (can use regexp).
  
  =item B<--check-order>
  
  Check memory in standard cisco mib. If you have some issue (wrong memory information in a specific mib), you can change the order 
  (Default: 'enhanced_pool,pool,process,system_ext').
  
  =back
  
  =cut
      
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_MEMORY

$fatpacked{"centreon/common/cisco/standard/snmp/mode/memoryflash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_MEMORYFLASH';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::memoryflash;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub custom_usage_perfdata {
      my ($self, %options) = @_;
  
      $self->{output}->perfdata_add(
          label => 'used', unit => 'B',
          nlabel => $self->{nlabel},
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
          value => $self->{result_values}->{used},
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}, total => $self->{result_values}->{total}, cast_int => 1),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}, total => $self->{result_values}->{total}, cast_int => 1),
          min => 0, max => $self->{result_values}->{total}
      );
  }
  
  sub custom_usage_threshold {
      my ($self, %options) = @_;
      
      my $exit = $self->{perfdata}->threshold_check(value => $self->{result_values}->{prct_used}, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      return $exit;
  }
  
  sub custom_usage_output {
      my ($self, %options) = @_;
      
      my ($total_size_value, $total_size_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{total});
      my ($total_used_value, $total_used_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{used});
      my ($total_free_value, $total_free_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{free});
      
      my $msg = sprintf("Total: %s Used: %s (%.2f%%) Free: %s (%.2f%%)",
                        $total_size_value . " " . $total_size_unit,
                        $total_used_value . " " . $total_used_unit, $self->{result_values}->{prct_used},
                        $total_free_value . " " . $total_free_unit, $self->{result_values}->{prct_free});
      return $msg;
  }
  
  sub custom_usage_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_total'};
      $self->{result_values}->{free} = $options{new_datas}->{$self->{instance} . '_free'};
      $self->{result_values}->{used} = $self->{result_values}->{total} - $self->{result_values}->{free};
      $self->{result_values}->{prct_free} = $self->{result_values}->{free} * 100 / $self->{result_values}->{total};
      $self->{result_values}->{prct_used} = $self->{result_values}->{used} * 100 / $self->{result_values}->{total};
      return 0;
  }
  
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'memory', type => 1, cb_prefix_output => 'prefix_memory_output', message_multiple => 'All memory flash partitions are ok' }
      ];
      
      $self->{maps_counters}->{memory} = [
          { label => 'usage', nlabel => 'memory.flash.usage.bytes', set => {
                  key_values => [ { name => 'display' }, { name => 'free' }, { name => 'total' } ],
                  closure_custom_calc => $self->can('custom_usage_calc'),
                  closure_custom_output => $self->can('custom_usage_output'),
                  closure_custom_perfdata => $self->can('custom_usage_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_usage_threshold'),
              }
          },
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "filter-name:s" => { name => 'filter_name' },
      });
  
      return $self;
  }
  
  sub prefix_memory_output {
      my ($self, %options) = @_;
      
      return "Partition '" . $options{instance_value}->{display} . "' ";
  }
  
  my $mapping = {
      ciscoFlashPartitionSize                 => { oid => '.1.3.6.1.4.1.9.9.10.1.1.4.1.1.4' },
      ciscoFlashPartitionFreeSpace            => { oid => '.1.3.6.1.4.1.9.9.10.1.1.4.1.1.5' },
      ciscoFlashPartitionName                 => { oid => '.1.3.6.1.4.1.9.9.10.1.1.4.1.1.10' },
      ciscoFlashPartitionSizeExtended         => { oid => '.1.3.6.1.4.1.9.9.10.1.1.4.1.1.13' },
      ciscoFlashPartitionFreeSpaceExtended    => { oid => '.1.3.6.1.4.1.9.9.10.1.1.4.1.1.14' },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $ciscoFlashPartitionEntry = '.1.3.6.1.4.1.9.9.10.1.1.4.1.1';
      my $snmp_result = $options{snmp}->get_table(
          oid => $ciscoFlashPartitionEntry,
          nothing_quit => 1
      );
  
      $self->{memory} = {};
      foreach my $oid (keys %$snmp_result) {
          next if ($oid !~ /^$mapping->{ciscoFlashPartitionSize}->{oid}\.(.*)/);
          my $instance = $1;
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $instance);
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $result->{ciscoFlashPartitionName} !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping  '" . $result->{ciscoFlashPartitionName} . "': no matching filter.", debug => 1);
              next;
          }
  
          my $total = $result->{ciscoFlashPartitionSize};
          if (defined($result->{ciscoFlashPartitionSizeExtended})) {
              $total = $result->{ciscoFlashPartitionSizeExtended};
          }
          my $free = $result->{ciscoFlashPartitionFreeSpace};
          if (defined($result->{ciscoFlashPartitionFreeSpaceExtended})) {
              $free = $result->{ciscoFlashPartitionFreeSpaceExtended};
          }
          
          $self->{memory}->{$instance} = { 
              display => $result->{ciscoFlashPartitionName}, 
              free => $free, total => $total
          };
      }
      
      if (scalar(keys %{$self->{memory}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No flash memory found.");
          $self->{output}->option_exit();
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check memory flash usages.
  
  =over 8
  
  =item B<--warning-usage>
  
  Threshold warning (in percent).
  
  =item B<--critical-usage>
  
  Threshold critical (in percent).
  
  =item B<--filter-name>
  
  Filter partition name (can be a regexp).
  
  =back
  
  =cut
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_MEMORYFLASH

$fatpacked{"centreon/common/cisco/standard/snmp/mode/qosusage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_QOSUSAGE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::qosusage;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'total', type => 0 },
          { name => 'interface_classmap', type => 1, cb_prefix_output => 'prefix_intcmap_output', message_multiple => 'All interface classmaps are ok' },
          { name => 'classmap', type => 1, cb_prefix_output => 'prefix_cmap_output', message_multiple => 'All classmaps are ok' },
      ];
  
      $self->{maps_counters}->{interface_classmap} = [
           { label => 'int-cmap-traffic', set => {
                  key_values => [ { name => 'display' }, { name => 'traffic_usage', diff => 1 }, { name => 'total' } ],
                  per_second => 1,
                  closure_custom_calc => $self->can('custom_traffic_calc'),
                  closure_custom_output => $self->can('custom_traffic_output'),
                  closure_custom_perfdata => $self->can('custom_traffic_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_traffic_threshold'),
              }
          },
          { label => 'int-cmap-drop', set => {
                  key_values => [ { name => 'drop_usage', diff => 1 }, { name => 'display' } ],
                  per_second => 1, output_change_bytes => 2,
                  output_template => 'Drop : %s %s/s',
                  perfdatas => [
                      { label => 'icmap_drop', value => 'drop_usage_per_second', template => '%d',
                        unit => 'b/s', min => 0, label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
      ];
      $self->{maps_counters}->{classmap} = [
           { label => 'cmap-traffic', set => {
                  key_values => [ { name => 'traffic_usage', diff => 1 }, { name => 'display' } ],
                  per_second => 1, output_change_bytes => 2,
                  output_template => 'Traffic : %s %s/s',
                  perfdatas => [
                      { label => 'cmap_traffic', value => 'traffic_usage_per_second', template => '%d',
                        unit => 'b/s', min => 0, label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
          { label => 'cmap-drop', set => {
                  key_values => [ { name => 'drop_usage', diff => 1 }, { name => 'display' } ],
                  per_second => 1, output_change_bytes => 2,
                  output_template => 'Drop : %s %s/s',
                  perfdatas => [
                      { label => 'cmap_drop', value => 'drop_usage_per_second', template => '%d',
                        unit => 'b/s', min => 0, label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
      ];
      $self->{maps_counters}->{total} = [
           { label => 'total-traffic', set => {
                  key_values => [ { name => 'traffic_usage', diff => 1 } ],
                  per_second => 1, output_change_bytes => 2,
                  output_template => 'Total Traffic : %s %s/s',
                  perfdatas => [
                      { label => 'total_traffic', value => 'traffic_usage_per_second', template => '%d',
                        unit => 'b/s', min => 0 },
                  ],
              }
          },
          { label => 'total-drop', set => {
                  key_values => [ { name => 'drop_usage', diff => 1 } ],
                  per_second => 1, output_change_bytes => 2,
                  output_template => 'Total Drop : %s %s/s',
                  perfdatas => [
                      { label => 'total_drop', value => 'drop_usage_per_second', template => '%d',
                        unit => 'b/s', min => 0 },
                  ],
              }
          },
      ];
  }
  
  sub custom_traffic_perfdata {
      my ($self, %options) = @_;
      
      my ($warning, $critical);
      if ($self->{instance_mode}->{option_results}->{units_traffic} eq '%' && defined($self->{result_values}->{total})) {
          $warning = $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}, total => $self->{result_values}->{total}, cast_int => 1);
          $critical = $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}, total => $self->{result_values}->{total}, cast_int => 1);
      } elsif ($self->{instance_mode}->{option_results}->{units_traffic} eq 'b/s') {
          $warning = $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel});
          $critical = $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel});
      }
      
      $self->{output}->perfdata_add(
          label => 'icmap_traffic', unit => 'b/s',
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
          value => sprintf("%.2f", $self->{result_values}->{traffic_per_seconds}),
          warning => $warning,
          critical => $critical,
          min => 0, max => $self->{result_values}->{total}
      );
  }
  
  sub custom_traffic_threshold {
      my ($self, %options) = @_;
      
      my $exit = 'ok';
      if ($self->{instance_mode}->{option_results}->{units_traffic} eq '%' && defined($self->{result_values}->{total})) {
          $exit = $self->{perfdata}->threshold_check(value => $self->{result_values}->{traffic_prct}, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      } elsif ($self->{instance_mode}->{option_results}->{units_traffic} eq 'b/s') {
          $exit = $self->{perfdata}->threshold_check(value => $self->{result_values}->{traffic_per_seconds}, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      }
      return $exit;
  }
  
  sub custom_traffic_output {
      my ($self, %options) = @_;
      
      my ($traffic_value, $traffic_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{traffic_per_seconds}, network => 1);    
      my $msg = sprintf("Traffic : %s/s (%s)",
                        $traffic_value . $traffic_unit,
                        defined($self->{result_values}->{traffic_prct}) ? sprintf("%.2f%%", $self->{result_values}->{traffic_prct}) : '-');
      return $msg;
  }
  
  sub custom_traffic_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};    
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_total'};
      $self->{result_values}->{traffic_usage} = $options{new_datas}->{$self->{instance} . '_traffic_usage'};
      
      my $diff_traffic = ($options{new_datas}->{$self->{instance} . '_traffic_usage'} - $options{old_datas}->{$self->{instance} . '_traffic_usage'});
      $self->{result_values}->{traffic_per_seconds} = $diff_traffic / $options{delta_time};
      if ($options{new_datas}->{$self->{instance} . '_total'} =~ /[1-9]/) {
          $self->{result_values}->{traffic_prct} = $self->{result_values}->{traffic_per_seconds} * 100 / $options{new_datas}->{$self->{instance} . '_total'};
      }
      
      return 0;
  }
  
  sub prefix_intcmap_output {
      my ($self, %options) = @_;
      
      return "Interface classmap '" . $options{instance_value}->{display} . "' ";
  }
  
  sub prefix_cmap_output {
      my ($self, %options) = @_;
      
      return "Classmap '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "filter-source:s"       => { name => 'filter_source' },
          "oid-filter:s"          => { name => 'oid_filter', default => 'ifname' },
          "oid-display:s"         => { name => 'oid_display', default => 'ifname' },
          "units-traffic:s"       => { name => 'units_traffic', default => '%' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->{oids_label} = {
          'ifdesc' => '.1.3.6.1.2.1.2.2.1.2',
          'ifalias' => '.1.3.6.1.2.1.31.1.1.1.18',
          'ifname' => '.1.3.6.1.2.1.31.1.1.1.1',
      };
      $self->check_oids_label();
  }
  
  sub check_oids_label {
      my ($self, %options) = @_;
      
      foreach (('oid_filter', 'oid_display')) {
          $self->{option_results}->{$_} = lc($self->{option_results}->{$_}) if (defined($self->{option_results}->{$_}));
          if (!defined($self->{oids_label}->{$self->{option_results}->{$_}})) {
              my $label = $_;
              $label =~ s/_/-/g;
              $self->{output}->add_option_msg(short_msg => "Unsupported oid in --" . $label . " option.");
              $self->{output}->option_exit();
          }
      }
  }
  
  my $mapping = {
      cbQosCMPrePolicyByteOverflow    => { oid => '.1.3.6.1.4.1.9.9.166.1.15.1.1.4' },
      cbQosCMPrePolicyByte            => { oid => '.1.3.6.1.4.1.9.9.166.1.15.1.1.5' },
      cbQosCMPrePolicyByte64          => { oid => '.1.3.6.1.4.1.9.9.166.1.15.1.1.6' },
      cbQosCMPostPolicyByteOverflow   => { oid => '.1.3.6.1.4.1.9.9.166.1.15.1.1.8' },
      cbQosCMPostPolicyByte           => { oid => '.1.3.6.1.4.1.9.9.166.1.15.1.1.9' },
      cbQosCMPostPolicyByte64         => { oid => '.1.3.6.1.4.1.9.9.166.1.15.1.1.10' },
      cbQosCMDropByteOverflow         => { oid => '.1.3.6.1.4.1.9.9.166.1.15.1.1.15' },
      cbQosCMDropByte                 => { oid => '.1.3.6.1.4.1.9.9.166.1.15.1.1.16' },
      cbQosCMDropByte64               => { oid => '.1.3.6.1.4.1.9.9.166.1.15.1.1.17' },
  };
  my $mapping2 = {
      cbQosTSCfgRate      => { oid => '.1.3.6.1.4.1.9.9.166.1.13.1.1.1' }, # bps
      cbQosTSCfgRate64    => { oid => '.1.3.6.1.4.1.9.9.166.1.13.1.1.11' }, # bps
  };
  
  my $oid_cbQosIfIndex = '.1.3.6.1.4.1.9.9.166.1.1.1.1.4';
  my $oid_cbQosConfigIndex = '.1.3.6.1.4.1.9.9.166.1.5.1.1.2';
  my $oid_cbQosParentObjectsIndex = '.1.3.6.1.4.1.9.9.166.1.5.1.1.4';    
  # Classmap information
  my $oid_cbQosCMName = '.1.3.6.1.4.1.9.9.166.1.7.1.1.1';
  my $oid_cbQosCMStatsEntry = '.1.3.6.1.4.1.9.9.166.1.15.1.1';
  # Can be linked to a classmap also
  my $oid_cbQosPolicyMapName = '.1.3.6.1.4.1.9.9.166.1.6.1.1.1';
  # Shaping : Linked to a classmap
  my $oid_cbQosTSCfgEntry = '.1.3.6.1.4.1.9.9.166.1.13.1.1';
  # Linked to a classmap
  my $oid_cbQosQueueingCfgBandwidth = '.1.3.6.1.4.1.9.9.166.1.9.1.1.1';
  my $oid_cbQosQueueingCfgBandwidthUnits = '.1.3.6.1.4.1.9.9.166.1.9.1.1.2';
  
  sub build_qos_information {
      my ($self, %options) = @_;
      
      my $qos_data = { complete_name => $options{class_name} };
      # Need to try and find the queueing (it's a child)
      $qos_data->{queueing} = $options{link_queueing}->{$options{policy_index} . '.' . $options{object_index}}
          if (defined($options{link_queueing}->{$options{policy_index} . '.' . $options{object_index}}));
      $qos_data->{shaping} = $options{link_shaping}->{$options{policy_index} . '.' . $options{object_index}}
          if (!defined($qos_data->{shaping}) && defined($options{link_shaping}->{$options{policy_index} . '.' . $options{object_index}}));
      
      while (($options{object_index} = $self->{results}->{$oid_cbQosParentObjectsIndex}->{$oid_cbQosParentObjectsIndex . '.' . $options{policy_index} . '.' . $options{object_index}}) != 0) {        
          my $config_index = $self->{results}->{$oid_cbQosConfigIndex}->{$oid_cbQosConfigIndex . '.' . $options{policy_index} . '.' . $options{object_index}};
          
          my $tmp_name = '';
          # try to find policy_map or class_map
          if (defined($self->{results}->{$oid_cbQosCMName}->{$oid_cbQosCMName . '.' . $config_index})) {
              $tmp_name = $self->{results}->{$oid_cbQosCMName}->{$oid_cbQosCMName . '.' . $config_index};
          } elsif (defined($self->{results}->{$oid_cbQosPolicyMapName}->{$oid_cbQosPolicyMapName . '.' . $config_index})) {
              $tmp_name = $self->{results}->{$oid_cbQosPolicyMapName}->{$oid_cbQosPolicyMapName . '.' . $config_index};
          }
          
          $qos_data->{shaping} = $options{link_shaping}->{$options{policy_index} . '.' . $options{object_index}}
              if (!defined($qos_data->{shaping}) && defined($options{link_shaping}->{$options{policy_index} . '.' . $options{object_index}}));
          
          $qos_data->{complete_name} = $tmp_name . ':' . $qos_data->{complete_name};
      }
      
      return $qos_data;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      $self->{interface_classmap} = {};
      $self->{classmap} = {};
      $self->{total} = { drop_usage => 0, total_usage => 0 };
      
      my $request_oids = [
          { oid => $self->{oids_label}->{$self->{option_results}->{oid_filter}} },
          { oid => $oid_cbQosPolicyMapName },
          { oid => $oid_cbQosIfIndex },
          { oid => $oid_cbQosConfigIndex },
          { oid => $oid_cbQosCMName },
          { oid => $oid_cbQosQueueingCfgBandwidth },
          { oid => $oid_cbQosQueueingCfgBandwidthUnits },
          { oid => $oid_cbQosCMStatsEntry },
          { oid => $oid_cbQosParentObjectsIndex },
          { oid => $oid_cbQosTSCfgEntry },
      ];
      push @$request_oids, { oid => $self->{oids_label}->{$self->{option_results}->{oid_display}} } 
          if ($self->{option_results}->{oid_filter} ne $self->{option_results}->{oid_display});
      $self->{results} = $options{snmp}->get_multiple_table(oids => $request_oids);
  
      my %classmap_name = ();
      foreach (keys %{$self->{results}->{$oid_cbQosConfigIndex}}) {
          if (defined($self->{results}->{$oid_cbQosCMName}->{$oid_cbQosCMName . '.' . $self->{results}->{$oid_cbQosConfigIndex}->{$_}})) {
              /(\d+\.\d+)$/;
              $classmap_name{$1} = $self->{results}->{$oid_cbQosCMName}->{$oid_cbQosCMName . '.' . $self->{results}->{$oid_cbQosConfigIndex}->{$_}};
          }
      }
      my ($link_queueing, $link_shaping) = ({}, {});
      foreach (keys %{$self->{results}->{$oid_cbQosParentObjectsIndex}}) {
          /(\d+)\.(\d+)$/;
          my $config_index = $self->{results}->{$oid_cbQosConfigIndex}->{$oid_cbQosConfigIndex . '.' . $1 . '.' . $2};
          if (defined($self->{results}->{$oid_cbQosQueueingCfgBandwidth}->{$oid_cbQosQueueingCfgBandwidth . '.' . $config_index})) {
              $link_queueing->{$1 . '.' . $self->{results}->{$oid_cbQosParentObjectsIndex}->{$_}} = $config_index;
          } elsif (defined($self->{results}->{$oid_cbQosTSCfgEntry}->{$mapping2->{cbQosTSCfgRate}->{oid} . '.' . $config_index})) {
              $link_shaping->{$1 . '.' . $self->{results}->{$oid_cbQosParentObjectsIndex}->{$_}} = $config_index;
          }
      }
  
      foreach (keys %{$self->{results}->{$oid_cbQosCMStatsEntry}}) {
          next if (!/$mapping->{cbQosCMPrePolicyByte}->{oid}\.(\d+)\.(\d+)/);
          
          my ($policy_index, $qos_object_index) = ($1, $2);
          
          my $class_name = $classmap_name{$policy_index . '.' . $qos_object_index};
          my $if_index = $self->{results}->{$oid_cbQosIfIndex}->{$oid_cbQosIfIndex . '.' . $policy_index};
          if (!defined($self->{results}->{$self->{oids_label}->{$self->{option_results}->{oid_display}}}->{$self->{oids_label}->{$self->{option_results}->{oid_display}} . '.' . $if_index})) {
              $self->{output}->output_add(long_msg => "skipping interface index '" . $if_index . "': no display name.", debug => 1);
              next;
          }
          my $interface_display = $self->{results}->{$self->{oids_label}->{$self->{option_results}->{oid_display}}}->{$self->{oids_label}->{$self->{option_results}->{oid_display}} . '.' . $if_index};
          
          if (!defined($self->{results}->{$self->{oids_label}->{$self->{option_results}->{oid_filter}}}->{$self->{oids_label}->{$self->{option_results}->{oid_filter}} . '.' . $if_index})) {
              $self->{output}->output_add(long_msg => "skipping interface index '" . $if_index . "': no filter name.", debug => 1);
              next;
          }
          
          my $qos_data = $self->build_qos_information(class_name => $class_name, policy_index => $policy_index, object_index => $qos_object_index,
              link_queueing => $link_queueing, link_shaping => $link_shaping);
          
          my $interface_filter = $self->{results}->{$self->{oids_label}->{$self->{option_results}->{oid_filter}}}->{$self->{oids_label}->{$self->{option_results}->{oid_filter}} . '.' . $if_index};
          my $name = $interface_filter . ':' . $qos_data->{complete_name};
          
          if (defined($self->{option_results}->{filter_source}) && $self->{option_results}->{filter_source} ne '' &&
              $name !~ /$self->{option_results}->{filter_source}/) {
              $self->{output}->output_add(long_msg => "skipping  '" . $name . "': no matching filter source.", debug => 1);
              next;
          }
          
          # Same hash key but only for disco context
          if (defined($options{disco})) {
              $self->{interface_classmap}->{$policy_index . '.' . $qos_object_index} = $name;
              next;
          }
          
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_cbQosCMStatsEntry}, instance => $policy_index . '.' . $qos_object_index);
          my $traffic_usage = (defined($result->{cbQosCMPostPolicyByte64}) && $result->{cbQosCMPostPolicyByte64} =~ /[1-9]/) ?
              $result->{cbQosCMPostPolicyByte64} : (($result->{cbQosCMPostPolicyByteOverflow} << 32) + $result->{cbQosCMPostPolicyByte});
          my $drop_usage = (defined($result->{cbQosCMDropByte64}) && $result->{cbQosCMDropByte64} =~ /[1-9]/) ?
              $result->{cbQosCMDropByte64} : (($result->{cbQosCMDropByteOverflow} << 32) + $result->{cbQosCMDropByte});
          my $total = 'unknown';
          if (defined($qos_data->{shaping})) {
              my $result_shaping = $options{snmp}->map_instance(mapping => $mapping2, results => $self->{results}->{$oid_cbQosTSCfgEntry}, instance => $qos_data->{shaping});
              $total = defined($result_shaping->{cbQosTSCfgRate64}) ? $result_shaping->{cbQosTSCfgRate64} : $result_shaping->{cbQosTSCfgRate};
          }
          
          $self->{interface_classmap}->{$policy_index . '.' . $qos_object_index} = {
              display => $name,
              traffic_usage => $traffic_usage * 8, drop_usage => $drop_usage * 8, total => $total
          };
          
          my @tabname = split /:/, $name;
          if (defined($tabname[3])){
              $class_name = $tabname[3].'-'.$class_name;
          }
          
          $self->{classmap}->{$name} = { display => $class_name, drop_usage => 0, traffic_usage => 0} if (!defined($self->{classmap}->{$name}));
          $self->{classmap}->{$name}->{traffic_usage} += $traffic_usage * 8;
          $self->{classmap}->{$name}->{drop_usage} += $drop_usage * 8;
          
          if (!defined($tabname[3])){
              $self->{total}->{traffic_usage} += $traffic_usage * 8;
              $self->{total}->{drop_usage} += $drop_usage * 8;
          }
      }
      
      $self->{cache_name} = "cisco_qos_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' .
          (defined($self->{option_results}->{filter_source}) ? md5_hex($self->{option_results}->{filter_source}) : md5_hex('all')) . '_' .
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
      
      if (scalar(keys %{$self->{interface_classmap}}) <= 0 && !defined($options{disco})) {
          $self->{output}->add_option_msg(short_msg => "Cannot found classmap.");
          $self->{output}->option_exit();
      }
  }
  
  sub disco_format {
      my ($self, %options) = @_;
      
      $self->{output}->add_disco_format(elements => ['name']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      $self->manage_selection(disco => 1, %options);
      foreach (keys %{$self->{interface_classmap}}) {
          $self->{output}->add_disco_entry(name => $self->{interface_classmap}->{$_});
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check QoS.
  
  =over 8
  
  =item B<--filter-source>
  
  Filter interface name and class-map (can be a regexp).
  Example of a source (interfacename:servicepolicy:classmap:...): FastEthernet1:Visioconference
  
  =item B<--filter-counters>
  
  Only display some counters (regexp can be used).
  Example: --filter-counters='^(total-traffic)$'
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'int-cmap-traffic', 'int-cmap-drop', 
  'cmap-traffic', 'cmap-drop', 'total-traffic', 'total-drop'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'int-cmap-traffic', 'int-cmap-drop', 
  'cmap-traffic', 'cmap-drop', 'total-traffic', 'total-drop'.
  
  =item B<--units-traffic>
  
  Units of thresholds for the traffic (Default: '%') ('%', 'b/s').
  Only for --warning-int-traffic and --critical-int-traffic options.
  
  =item B<--oid-filter>
  
  Choose OID used to filter interface (default: ifName) (values: ifDesc, ifAlias, ifName).
  
  =item B<--oid-display>
  
  Choose OID used to display interface (default: ifName) (values: ifDesc, ifAlias, ifName).
  
  =back
  
  =cut
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_QOSUSAGE

$fatpacked{"centreon/common/cisco/standard/snmp/mode/sessions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_SESSIONS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::sessions;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'connections', type => 0, cb_prefix_output => 'prefix_connections_output', skipped_code => { -10 => 1 } },
          { name => 'sessions', type => 0, cb_prefix_output => 'prefix_sessions_output', skipped_code => { -10 => 1 } },
      ];
      $self->{maps_counters}->{connections} = [
          { label => 'connections-current', set => {
                  key_values => [ { name => 'cufwConnGlobalNumActive' } ],
                  output_template => 'current : %s', output_error_template => "current : %s",
                  perfdatas => [
                      { label => 'connections_current', value => 'cufwConnGlobalNumActive_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'connections-1m', set => {
                  key_values => [ { name => 'cufwConnGlobalConnSetupRate1' } ],
                  output_template => 'average last 1min : %s', output_error_template => "average last 1min : %s",
                  perfdatas => [
                      { label => 'connections_1m', value => 'cufwConnGlobalConnSetupRate1_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'connections-5m', set => {
                  key_values => [ { name => 'cufwConnGlobalConnSetupRate5' } ],
                  output_template => 'average last 5min : %s', output_error_template => "average last 5min : %s",
                  perfdatas => [
                      { label => 'connections_5m', value => 'cufwConnGlobalConnSetupRate5_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
      ];
      $self->{maps_counters}->{sessions} = [
          { label => 'sessions-total', set => {
                  key_values => [ { name => 'crasNumSessions' } ],
                  output_template => 'total : %s', output_error_template => "total : %s",
                  perfdatas => [
                      { label => 'sessions_total', value => 'crasNumSessions_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-email-current', set => {
                  key_values => [ { name => 'crasEmailNumSessions' } ],
                  output_template => 'current email proxy : %s', output_error_template => "current email proxy : %s",
                  perfdatas => [
                      { label => 'sessions_email_current', value => 'crasEmailNumSessions_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-email-psec', set => {
                  key_values => [ { name => 'crasEmailCumulateSessions', diff => 1 } ],
                  output_template => 'email proxy : %.2f/s', output_error_template => "email proxy : %s",
                  per_second => 1,
                  perfdatas => [
                      { label => 'sessions_email_psec', value => 'crasEmailCumulateSessions_per_second', template => '%.2f',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-ipsec-current', set => {
                  key_values => [ { name => 'crasIPSecNumSessions' } ],
                  output_template => 'current ipsec : %s', output_error_template => "current ipsec : %s",
                  perfdatas => [
                      { label => 'sessions_ipsec_current', value => 'crasIPSecNumSessions_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-ipsec-psec', set => {
                  key_values => [ { name => 'crasIPSecCumulateSessions', diff => 1 } ],
                  output_template => 'ipsec : %.2f/s', output_error_template => "ipsec : %s",
                  per_second => 1,
                  perfdatas => [
                      { label => 'sessions_ipsec_psec', value => 'crasIPSecCumulateSessions_per_second', template => '%.2f',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-l2l-current', set => {
                  key_values => [ { name => 'crasL2LNumSessions' } ],
                  output_template => 'current LAN to LAN : %s', output_error_template => "current LAN to LAN : %s",
                  perfdatas => [
                      { label => 'sessions_l2l_current', value => 'crasL2LNumSessions_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-l2l-psec', set => {
                  key_values => [ { name => 'crasL2LCumulateSessions', diff => 1 } ],
                  output_template => 'LAN to LAN : %.2f/s', output_error_template => "LAN to LAN : %s",
                  per_second => 1,
                  perfdatas => [
                      { label => 'sessions_l2l_psec', value => 'crasL2LCumulateSessions_per_second', template => '%.2f',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-lb-current', set => {
                  key_values => [ { name => 'crasLBNumSessions' } ],
                  output_template => 'current load balancing : %s', output_error_template => "current load balancing : %s",
                  perfdatas => [
                      { label => 'sessions_lb_current', value => 'crasLBNumSessions_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-lb-psec', set => {
                  key_values => [ { name => 'crasLBCumulateSessions', diff => 1 } ],
                  output_template => 'load balancing : %.2f/s', output_error_template => "load balancing : %s",
                  per_second => 1,
                  perfdatas => [
                      { label => 'sessions_lb_psec', value => 'crasLBCumulateSessions_per_second', template => '%.2f',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-svc-current', set => {
                  key_values => [ { name => 'crasSVCNumSessions' } ],
                  output_template => 'current SVC : %s', output_error_template => "current SVC : %s",
                  perfdatas => [
                      { label => 'sessions_svc_current', value => 'crasSVCNumSessions_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-svc-psec', set => {
                  key_values => [ { name => 'crasSVCCumulateSessions', diff => 1 } ],
                  output_template => 'SVC : %.2f/s', output_error_template => "SVC : %s",
                  per_second => 1,
                  perfdatas => [
                      { label => 'sessions_svc_psec', value => 'crasSVCCumulateSessions_per_second', template => '%.2f',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-webvpn-current', set => {
                  key_values => [ { name => 'crasWebvpnNumSessions' } ],
                  output_template => 'current webvpn : %s', output_error_template => "current webvpn : %s",
                  perfdatas => [
                      { label => 'sessions_webvpn_current', value => 'crasWebvpnNumSessions_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'sessions-webvpn-psec', set => {
                  key_values => [ { name => 'crasWebvpnCumulateSessions', diff => 1 } ],
                  output_template => 'webvpn : %.2f/s', output_error_template => "webvpn : %s",
                  per_second => 1,
                  perfdatas => [
                      { label => 'sessions_webvpn_psec', value => 'crasWebvpnCumulateSessions_per_second', template => '%.2f',
                        min => 0 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_connections_output {
      my ($self, %options) = @_;
      
      return "Connections ";
  }
  
  sub prefix_sessions_output {
      my ($self, %options) = @_;
      
      return "Sessions ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {                               
                                  });
      
      return $self;
  }
  
  my %oids_connections = (
      cufwConnGlobalNumActive         => '.1.3.6.1.4.1.9.9.491.1.1.1.6.0',
      cufwConnGlobalConnSetupRate1    => '.1.3.6.1.4.1.9.9.491.1.1.1.10.0',
      cufwConnGlobalConnSetupRate5    => '.1.3.6.1.4.1.9.9.491.1.1.1.11.0',
  );
  my %oids_sessions = (    
      crasNumSessions             => '.1.3.6.1.4.1.9.9.392.1.3.1.0',
      crasEmailNumSessions        => '.1.3.6.1.4.1.9.9.392.1.3.23.0',
      crasEmailCumulateSessions   => '.1.3.6.1.4.1.9.9.392.1.3.24.0',
      crasIPSecNumSessions        => '.1.3.6.1.4.1.9.9.392.1.3.26.0',
      crasIPSecCumulateSessions   => '.1.3.6.1.4.1.9.9.392.1.3.27.0',
      crasL2LNumSessions          => '.1.3.6.1.4.1.9.9.392.1.3.29.0',
      crasL2LCumulateSessions     => '.1.3.6.1.4.1.9.9.392.1.3.30.0',
      crasLBNumSessions           => '.1.3.6.1.4.1.9.9.392.1.3.32.0',
      crasLBCumulateSessions      => '.1.3.6.1.4.1.9.9.392.1.3.33.0',
      crasSVCNumSessions          => '.1.3.6.1.4.1.9.9.392.1.3.35.0',
      crasSVCCumulateSessions     => '.1.3.6.1.4.1.9.9.392.1.3.36.0',
      crasWebvpnNumSessions       => '.1.3.6.1.4.1.9.9.392.1.3.38.0',
      crasWebvpnCumulateSessions  => '.1.3.6.1.4.1.9.9.392.1.3.39.0',
  );
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      $self->{cache_name} = "cisco_standard_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' .
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
      
      $self->{connections} = {};
      $self->{sessions} = {};
      
      $self->{results} = $options{snmp}->get_leef(oids => [values %oids_connections, values %oids_sessions],
                                                  nothing_quit => 1);
      foreach my $name (keys %oids_connections) {
          next if (!defined($self->{results}->{$oids_connections{$name}}) || $self->{results}->{$oids_connections{$name}} == 0);
          $self->{connections}->{$name} = $self->{results}->{$oids_connections{$name}};
      }
      foreach my $name (keys %oids_sessions) {
          next if (!defined($self->{results}->{$oids_sessions{$name}}) || $self->{results}->{$oids_sessions{$name}} == 0);
          $self->{sessions}->{$name} = $self->{results}->{$oids_sessions{$name}};
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check sessions. 
  
  =over 8
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'connections-current', 'connections-1m', 'connections-5m',
  'sessions-total', 'sessions-email-current', 'sessions-email-psec',
  'sessions-ipsec-current', 'sessions-ipsec-psec', 'sessions-l2l-current', 'sessions-lb-psec'
  'sessions-lb-current', 'sessions-lb-psec', 'sessions-svc-current', 'sessions-svc-psec',
  'sessions-webvpn-current', 'sessions-webvpn-psec'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'connections-current', 'connections-1m', 'connections-5m',
  'sessions-total', 'sessions-email-current', 'sessions-email-psec',
  'sessions-ipsec-current', 'sessions-ipsec-psec', 'sessions-l2l-current', 'sessions-lb-psec'
  'sessions-lb-current', 'sessions-lb-psec', 'sessions-svc-current', 'sessions-svc-psec',
  'sessions-webvpn-current', 'sessions-webvpn-psec'.
  
  =back
  
  =cut
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_SESSIONS

$fatpacked{"centreon/common/cisco/standard/snmp/mode/stack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_STACK';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::common::cisco::standard::snmp::mode::stack;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold catalog_status_calc);
  
  sub custom_stack_status_output {
      my ($self, %options) = @_;
      
      my $msg = sprintf("Stack status is '%s'", $self->{result_values}->{stack_status});
      return $msg;
  }
  
  sub custom_status_output {
      my ($self, %options) = @_;
      
      my $msg = sprintf("State is '%s', Role is '%s'", $self->{result_values}->{state}, $self->{result_values}->{role});
      return $msg;
  }
  
  sub prefix_global_output {
      my ($self, %options) = @_;
      
      return "Number of members ";
  }
  
  sub prefix_status_output {
      my ($self, %options) = @_;
      
      return "Member '" . $options{instance_value}->{id} . "' ";
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'stack', type => 0 },
          { name => 'global', type => 0, cb_prefix_output => 'prefix_global_output' },
          { name => 'members', type => 1, cb_prefix_output => 'prefix_status_output', message_multiple => 'All stack members status are ok' },
      ];
  
      $self->{maps_counters}->{stack} = [
          { label => 'stack-status', threshold => 0, set => {
                  key_values => [ { name => 'stack_status' } ],
                  closure_custom_calc => \&catalog_status_calc,
                  closure_custom_output => $self->can('custom_stack_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          }
      ];
  
      $self->{maps_counters}->{global} = [
          { label => 'waiting', set => {
                  key_values => [ { name => 'waiting' } ],
                  output_template => 'Waiting: %d',
                  perfdatas => [
                      { label => 'waiting', value => 'waiting_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'progressing', set => {
                  key_values => [ { name => 'progressing' } ],
                  output_template => 'Progressing: %d',
                  perfdatas => [
                      { label => 'progressing', value => 'progressing_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'added', set => {
                  key_values => [ { name => 'added' } ],
                  output_template => 'Added: %d',
                  perfdatas => [
                      { label => 'added', value => 'added_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'ready', set => {
                  key_values => [ { name => 'ready' } ],
                  output_template => 'Ready: %d',
                  perfdatas => [
                      { label => 'ready', value => 'ready_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'sdm-mismatch', set => {
                  key_values => [ { name => 'sdmMismatch' } ],
                  output_template => 'SDM Mismatch: %d',
                  perfdatas => [
                      { label => 'sdm_mismatch', value => 'sdmMismatch_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'version-mismatch', set => {
                  key_values => [ { name => 'verMismatch' } ],
                  output_template => 'Version Mismatch: %d',
                  perfdatas => [
                      { label => 'version_mismatch', value => 'verMismatch_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'feature-mismatch', set => {
                  key_values => [ { name => 'featureMismatch' } ],
                  output_template => 'Feature Mismatch: %d',
                  perfdatas => [
                      { label => 'feature_mismatch', value => 'featureMismatch_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'new-master-init', set => {
                  key_values => [ { name => 'newMasterInit' } ],
                  output_template => 'New Master Init: %d',
                  perfdatas => [
                      { label => 'new_master_init', value => 'newMasterInit_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'provisioned', set => {
                  key_values => [ { name => 'provisioned' } ],
                  output_template => 'Provisioned: %d',
                  perfdatas => [
                      { label => 'provisioned', value => 'provisioned_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'invalid', set => {
                  key_values => [ { name => 'invalid' } ],
                  output_template => 'Invalid: %d',
                  perfdatas => [
                      { label => 'invalid', value => 'invalid_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
          { label => 'removed', set => {
                  key_values => [ { name => 'removed' } ],
                  output_template => 'Removed: %d',
                  perfdatas => [
                      { label => 'removed', value => 'removed_absolute', template => '%d',
                        min => 0 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{members} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'id' }, { name => 'role' }, { name => 'state' } ],
                  closure_custom_calc => \&catalog_status_calc,
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'warning-stack-status:s'    => { name => 'warning_stack_status', default => '' },
          'critical-stack-status:s'   => { name => 'critical_stack_status', default => '%{stack_status} =~ /notredundant/' },
          'warning-status:s'          => { name => 'warning_status', default => '' },
          'critical-status:s'         => { name => 'critical_status', default => '%{state} !~ /ready/ && %{state} !~ /provisioned/' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['warning_stack_status', 'critical_stack_status', 'warning_status', 'critical_status']);
  }
  
  my %map_role = (
      1 => 'master',
      2 => 'member',
      3 => 'notMember',
      4 => 'standby'
  );
  my %map_state = (
      1 => 'waiting',
      2 => 'progressing',
      3 => 'added',
      4 => 'ready',
      5 => 'sdmMismatch',
      6 => 'verMismatch',
      7 => 'featureMismatch',
      8 => 'newMasterInit',
      9 => 'provisioned',
      10 => 'invalid',
      11 => 'removed',
  );
  
  my $mapping = {
      cswSwitchRole => { oid => '.1.3.6.1.4.1.9.9.500.1.2.1.1.3', map => \%map_role },
      cswSwitchState => { oid => '.1.3.6.1.4.1.9.9.500.1.2.1.1.6', map => \%map_state },
  };
  my $oid_cswSwitchInfoEntry = '.1.3.6.1.4.1.9.9.500.1.2.1.1';
  
  my $oid_cswRingRedundant = '.1.3.6.1.4.1.9.9.500.1.1.3.0';
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{global} = {
          waiting => 0, progressing => 0, added => 0, ready => 0, sdmMismatch => 0, 
          verMismatch => 0, featureMismatch => 0, newMasterInit => 0, provisioned => 0, 
          invalid => 0, removed => 0
      };
      $self->{members} = {};
  
      my $snmp_result = $options{snmp}->get_leef(oids => [ $oid_cswRingRedundant ], nothing_quit => 1);
      $self->{stack} = {
          stack_status => ($snmp_result->{$oid_cswRingRedundant} != 1) ? 'notredundant' : 'redundant',
      };
  
      $snmp_result = $options{snmp}->get_table(
          oid => $oid_cswSwitchInfoEntry,
          start => $mapping->{cswSwitchRole}->{oid},
          end => $mapping->{cswSwitchState}->{oid},
          nothing_quit => 1
      );
  
      foreach my $oid (keys %$snmp_result) {
          next if($oid !~ /^$mapping->{cswSwitchRole}->{oid}\.(.*)$/);
          my $instance = $1;
          
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $instance);
  
          # .1001, .2001 the instance.
          my $id = int(($instance - 1) / 1000);
          $self->{members}->{$id} = {
              id => $id,
              role => $result->{cswSwitchRole},
              state => $result->{cswSwitchState},
          };
          $self->{global}->{$result->{cswSwitchState}}++;
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check Cisco Stack (CISCO-STACKWISE-MIB).
  
  =over 8
  
  =item B<--warning-*> B<--critical-*>
  
  Set thresholds on members count for each states.
  (Can be: 'waiting', 'progressing', 'added', 'ready', 'sdm-mismatch', 'version-mismatch',
  'feature-mismatch', 'new-master-init', 'provisioned', 'invalid', 'removed')
  
  =item B<--warning-stack-status>
  
  Set warning threshold for stack status (Default: '').
  Can used special variables like: %{stack_status}
  
  =item B<--critical-stack-status>
  
  Set critical threshold for stack status (Default: '%{stack_status} =~ /notredundant/').
  Can used special variables like: %{stack_status}
  
  =item B<--warning-status>
  
  Set warning threshold for members status (Default: '').
  Can used special variables like: %{id}, %{role}, %{state}
  
  =item B<--critical-status>
  
  Set critical threshold for member status (Default: '%{state} !~ /ready/ && %{state} !~ /provisioned/').
  Can used special variables like: %{id}, %{role}, %{state}
  
  Role can be: 'master', 'member', 'notMember', 'standby'.
  
  State can be: 'waiting', 'progressing', 'added',
  'ready', 'sdmMismatch', 'verMismatch', 'featureMismatch',
  'newMasterInit', 'provisioned', 'invalid', 'removed'.
  
  =back
  
  =cut
      
CENTREON_COMMON_CISCO_STANDARD_SNMP_MODE_STACK

$fatpacked{"centreon/plugins/alternative/FatPackerOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_ALTERNATIVE_FATPACKEROPTIONS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::alternative::FatPackerOptions;
  
  use base qw(centreon::plugins::options);
  
  use strict;
  use warnings;
  use Pod::Usage;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      return $self;
  }
  
  sub display_help {
      my ($self, %options) = @_;
      
      my $stdout;
      foreach (@{$self->{pod_package}}) {
          
          {
              my $pp = $_->{package} . ".pm";
              $pp =~ s{::}{/}g;
              my $content_class = $INC{$pp}->{$pp};
              open my $str_fh, '<', \$content_class;
              
              local *STDOUT;
              open STDOUT, '>', \$stdout;
              pod2usage(-exitval => 'NOEXIT', -input => $str_fh,
                        -verbose => 99, 
                        -sections => $_->{sections});
              
              close $str_fh;
          }
          
          $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
      }
  }
  
  1;
  
CENTREON_PLUGINS_ALTERNATIVE_FATPACKEROPTIONS

$fatpacked{"centreon/plugins/alternative/Getopt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_ALTERNATIVE_GETOPT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::alternative::Getopt;
  
  use strict;
  use warnings;
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  BEGIN {
      @EXPORT    = qw(&GetOptions);
      @EXPORT_OK = qw();
  }
  
  use vars @EXPORT, @EXPORT_OK;
  
  our $warn_message = 0;
  
  sub get_assigned_value {
      my (%options) = @_;
      
      if (!defined($options{val}) || $options{val} eq '') {
          # Add defined also. Hardened code: already see: $ARGV[6] = undef for example
          if ($options{pos} + 1 < $options{num_args} && defined($ARGV[$options{pos} + 1]) && $ARGV[$options{pos} + 1] !~ /^--/) {
              my $val = $ARGV[$options{pos} + 1];
              splice @ARGV, $options{pos} + 1, 1;
              return ($options{num_args} - 1, $val);
          } else {
              return ($options{num_args}, '');
          }
      }
      
      return ($options{num_args}, $options{val});
  }
  
  sub GetOptions {
      my (%opts) = @_;
      
      my $search_str = ',' . join(',', keys %opts) . ',';
      my $num_args = scalar(@ARGV);
      for (my $i = 0; $i < $num_args;) {
          if (defined($ARGV[$i]) && $ARGV[$i] =~ /^--(.*?)(?:=|$)(.*)/) {
              my ($option, $value) = ($1, $2);
              
              # find type of option
              if ($search_str !~ /,((?:[^,]*?\|){0,}$option(?:\|.*?){0,}(:.*?){0,1}),/) {
                  warn "Unknown option: $option" if ($warn_message == 1);
                  $i++;
                  next;
              }
              
              my ($option_selected, $type_opt) = ($1, $2);
              if (!defined($type_opt)) {
                  ${$opts{$option_selected}} = 1;
              } elsif ($type_opt =~ /:s$/) {
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  ${$opts{$option_selected}} = $assigned;
              } elsif ($type_opt =~ /:s\@$/) {
                  ${$opts{$option . $type_opt}} = [] if (!defined(${$opts{$option . $type_opt}}));
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  push @{${$opts{$option_selected}}}, $assigned;
              } elsif ($type_opt =~ /:s\%$/) {
                  ${$opts{$option . $type_opt}} = {} if (!defined(${$opts{$option . $type_opt}}));
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  if ($assigned =~ /^(.*?)=(.*)/) {
                      ${$opts{$option_selected}}->{$1} = $2;
                  }
              } 
              
              splice @ARGV, $i, 1;
              $num_args--;
          } else {
              warn "argument $ARGV[$i] alone" if ($warn_message == 1 && $i != 0 && defined($ARGV[$i]));
              $i++;
          }
      }
  }
  
  1;
  
CENTREON_PLUGINS_ALTERNATIVE_GETOPT

$fatpacked{"centreon/plugins/misc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MISC';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::misc;
  
  use strict;
  use warnings;
  use utf8;
  
  sub execute {
      my (%options) = @_;
      
      if ($^O eq 'MSWin32') {
          return windows_execute(%options, timeout => $options{options}->{timeout});
      } else {
          return unix_execute(%options);
      }
  }
  
  sub windows_execute {
      my (%options) = @_;
      my $result;
      my ($stdout, $pid, $ended) = ('');
      my ($exit_code, $cmd);
      
      $cmd = $options{command_path} . '/' if (defined($options{command_path}));
      $cmd .= $options{command} . ' ' if (defined($options{command}));
      $cmd .= $options{command_options} if (defined($options{command_options}));
      
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'Win32::Job',
                                             error_msg => "Cannot load module 'Win32::Job'.");
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'Time::HiRes',
                                             error_msg => "Cannot load module 'Time::HiRes'.");
      
      $| = 1;
      pipe FROM_CHILD, TO_PARENT or do {
          $options{output}->add_option_msg(short_msg => "Internal error: can't create pipe from child to parent: $!");
          $options{output}->option_exit();
      };
      my $job = Win32::Job->new;
      my $stderr = 'NUL';
      $stderr = \*TO_PARENT if ($options{output}->is_debug());
      if (!($pid = $job->spawn(undef, $cmd,
                         { stdin => 'NUL',
                           stdout => \*TO_PARENT,
                           stderr => $stderr }))) {
          $options{output}->add_option_msg(short_msg => "Internal error: execution issue: $^E");
          $options{output}->option_exit();
      }
      close TO_PARENT;
  
      my $ein = '';
      vec($ein, fileno(FROM_CHILD), 1) = 1;
      $job->watch(
          sub {            
              my ($buffer);
              my $time = $options{timeout};
              my $last_time = Time::HiRes::time();
              $ended = 0;
              while (select($ein, undef, undef, $options{timeout})) {
                  if (sysread(FROM_CHILD, $buffer, 16384)) {
                      $buffer =~ s/\r//g;
                      $stdout .= $buffer;
                  } else {
                      $ended = 1;
                      last;
                  }
                  $options{timeout} -= Time::HiRes::time() - $last_time;
                  last if ($options{timeout} <= 0);         
                  $last_time = Time::HiRes::time();
              }
              return 1 if ($ended == 0);
              return 0;
          },
          0.1
      );
          
      $result = $job->status;
      close FROM_CHILD;    
      
      if ($ended == 0) {
          $options{output}->add_option_msg(short_msg => 'Command too long to execute (timeout)...');
          $options{output}->option_exit();
      }
      chomp $stdout;
      
      if (defined($options{no_quit}) && $options{no_quit} == 1) {
          return ($stdout, $result->{$pid}->{exitcode});
      }
      
      if ($result->{$pid}->{exitcode} != 0) {
          $stdout =~ s/\n/ - /g;
          $options{output}->add_option_msg(short_msg => "Command error: $stdout");
          $options{output}->option_exit();
      }
      
      return ($stdout, $result->{$pid}->{exitcode});
  }
  
  sub unix_execute {
      my (%options) = @_;
      my $cmd = '';
      my $args = [];
      my ($lerror, $stdout, $exit_code);
  
      my $redirect_stderr = 1;
      $redirect_stderr = $options{redirect_stderr} if (defined($options{redirect_stderr}));
      my $wait_exit = 1;
      $wait_exit = $options{wait_exit} if (defined($options{wait_exit}));
      
      # Build command line
      # Can choose which command is done remotely (can filter and use local file)
      if (defined($options{options}->{remote}) && 
          ($options{options}->{remote} eq '' || !defined($options{label}) || $options{label} =~ /$options{options}->{remote}/)) {
          my $sub_cmd;
  
          $cmd = $options{options}->{ssh_path} . '/' if (defined($options{options}->{ssh_path}));
          $cmd .= $options{options}->{ssh_command} if (defined($options{options}->{ssh_command}));
          
          foreach (@{$options{options}->{ssh_option}}) {
              my ($lvalue, $rvalue) = split /=/;
              push @$args, $lvalue if (defined($lvalue));
              push @$args, $rvalue if (defined($rvalue));
          }
          
          if (defined($options{options}->{ssh_address}) && $options{options}->{ssh_address} ne '') {
              push @$args, $options{options}->{ssh_address};
          } else {
              push @$args, $options{options}->{hostname};
          }
  		
          $sub_cmd = 'sudo ' if (defined($options{sudo}));
          $sub_cmd .= $options{command_path} . '/' if (defined($options{command_path}));
          $sub_cmd .= $options{command} . ' ' if (defined($options{command}));
          $sub_cmd .= $options{command_options} if (defined($options{command_options}));
          # On some equipment. Cannot get a pseudo terminal
          if (defined($options{ssh_pipe}) && $options{ssh_pipe} == 1) {
              $cmd = "echo '" . $sub_cmd . "' | " . $cmd . ' ' . join(' ', @$args);
              ($lerror, $stdout, $exit_code) = backtick(
                  command => $cmd,
                  timeout => $options{options}->{timeout},
                  wait_exit => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          } else {
              ($lerror, $stdout, $exit_code) = backtick(
                  command => $cmd,
                  arguments => [@$args, $sub_cmd],
                  timeout => $options{options}->{timeout},
                  wait_exit => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          }
      } else {
          $cmd = 'sudo ' if (defined($options{sudo}));
          $cmd .= $options{command_path} . '/' if (defined($options{command_path}));
          $cmd .= $options{command} . ' ' if (defined($options{command}));
          $cmd .= $options{command_options} if (defined($options{command_options}));
          
          ($lerror, $stdout, $exit_code) = backtick(
              command => $cmd,
              timeout => $options{options}->{timeout},
              wait_exit => $wait_exit,
              redirect_stderr => $redirect_stderr
          );
      }
  
      if (defined($options{options}->{show_output}) && 
          ($options{options}->{show_output} eq '' || (defined($options{label}) && $options{label} eq $options{options}->{show_output}))) {
          print $stdout;
          exit $exit_code;
      }
      
      $stdout =~ s/\r//g;
      if ($lerror <= -1000) {
          $options{output}->add_option_msg(short_msg => $stdout);
          $options{output}->option_exit();
      }
      
      if (defined($options{no_quit}) && $options{no_quit} == 1) {
          return ($stdout, $exit_code);
      }
      
      if ($exit_code != 0 && (!defined($options{no_errors}) || !defined($options{no_errors}->{$exit_code}))) {
          $stdout =~ s/\n/ - /g;
          $options{output}->add_option_msg(short_msg => "Command error: $stdout");
          $options{output}->option_exit();
      }
      
      return $stdout;
  }
  
  sub mymodule_load {
      my (%options) = @_;
      my $file;
      ($file = ($options{module} =~ /\.pm$/ ? $options{module} : $options{module} . '.pm')) =~ s{::}{/}g;
      
      eval {
          local $SIG{__DIE__} = 'IGNORE';
          require $file;
          $file =~ s{/}{::}g;
          $file =~ s/\.pm$//;
      };
      if ($@) {
          return 1 if (defined($options{no_quit}) && $options{no_quit} == 1);
          $options{output}->add_option_msg(long_msg => $@);
          $options{output}->add_option_msg(short_msg => $options{error_msg});
          $options{output}->option_exit();
      }
      return wantarray ? (0, $file) : 0;
  }
  
  sub backtick {
      my %arg = (
          command => undef,
          arguments => [],
          timeout => 30,
          wait_exit => 0,
          redirect_stderr => 0,
          @_,
      );
      my @output;
      my $pid;
      my $return_code;
      
      my $sig_do;
      if ($arg{wait_exit} == 0) {
          $sig_do = 'IGNORE';
          $return_code = undef;
      } else {
          $sig_do = 'DEFAULT';
      }
      local $SIG{CHLD} = $sig_do;
      $SIG{TTOU} = 'IGNORE';
      $| = 1;
  
      if (!defined($pid = open( KID, "-|" ))) {
          return (-1001, "Cant fork: $!", -1);
      }
  
      if ($pid) {
          
          eval {
             local $SIG{ALRM} = sub { die "Timeout by signal ALARM\n"; };
             alarm( $arg{timeout} );
             while (<KID>) {
                 chomp;
                 push @output, $_;
             }
  
             alarm(0);
          };
  
          if ($@) {
              if ($pid != -1) {
                  kill -9, $pid;
              }
  
              alarm(0);
              return (-1000, 'Command too long to execute (timeout)...', -1);
          } else {
              if ($arg{wait_exit} == 1) {
                  # We're waiting the exit code                
                  waitpid($pid, 0);
                  $return_code = ($? >> 8);
              }
              close KID;
          }
      } else {
          # child
          # set the child process to be a group leader, so that
          # kill -9 will kill it and all its descendents
          # We have ignore SIGTTOU to let write background processes
          setpgrp( 0, 0 );
  
          if ($arg{redirect_stderr} == 1) {
              open STDERR, '>&STDOUT';
          }
          if (scalar(@{$arg{arguments}}) <= 0) {
              exec($arg{command});
          } else {
              exec($arg{command}, @{$arg{arguments}});
          }
          # Exec is in error. No such command maybe.
          exit(127);
      }
  
      return (0, join("\n", @output), $return_code);
  }
  
  sub trim {
      my ($value) = $_[0];
      
      # Sometimes there is a null character
      $value =~ s/\x00$//;
      $value =~ s/^[ \t\n]+//;
      $value =~ s/[ \t\n]+$//;
      return $value;
  }
  
  sub powershell_encoded {
      my ($value) = $_[0];
  
      require Encode;
      require MIME::Base64;
      my $bytes = Encode::encode('utf16LE', $value);
      my $script = MIME::Base64::encode_base64($bytes, "\n");
      $script =~ s/\n//g;
      return $script;
  }
  
  sub powershell_escape {
      my ($value) = $_[0];
      $value =~ s/`/``/g;
      $value =~ s/#/`#/g;
      $value =~ s/'/`'/g;
      $value =~ s/"/`"/g;
      return $value;
  }
  
  sub powershell_json_sanitizer {
      my (%options) = @_;
  
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'JSON::XS',
                                             error_msg => "Cannot load module 'JSON::XS'.");
      foreach my $line (split /\n/, $options{string}) {
          eval { JSON::XS->new->utf8->decode($line) };
          return $line if (!$@);
      }
      return -1;
  }
  
  sub minimal_version {
      my ($version_src, $version_dst) = @_;
          
      # No Version. We skip   
      if (!defined($version_src) || !defined($version_dst) || 
          $version_src !~ /^[0-9]+(?:\.[0-9\.]+)*$/ || $version_dst !~ /^[0-9x]+(?:\.[0-9x]+)*$/) {
          return 1;
      }
    
      my @version_src = split /\./, $version_src;
      my @versions = split /\./, $version_dst;
      for (my $i = 0; $i < scalar(@versions); $i++) {
          return 1 if ($versions[$i] eq 'x');
          return 1 if (!defined($version_src[$i]));
          $version_src[$i] =~ /^([0-9]*)/;
          next if ($versions[$i] == int($1));
          return 0 if ($versions[$i] > int($1));
          return 1 if ($versions[$i] < int($1));
      }
      
      return 1;
  }
  
  sub change_seconds {
      my %options = @_;
      my ($str, $str_append) = ('', '');
      my $periods = [
          { unit => 'y', value => 31556926 },
          { unit => 'M', value => 2629743 },
          { unit => 'w', value => 604800 },
          { unit => 'd', value => 86400 },
          { unit => 'h', value => 3600 },
          { unit => 'm', value => 60 },
          { unit => 's', value => 1 },
      ];
      my %values = ('y' => 1, 'M' => 2, 'w' => 3, 'd' => 4, 'h' => 5, 'm' => 6, 's' => 7);
  
      foreach (@$periods) {
          next if (defined($options{start}) && $values{$_->{unit}} < $values{$options{start}});
          my $count = int($options{value} / $_->{value});
  
          next if ($count == 0);
          $str .= $str_append . $count . $_->{unit};
          $options{value} = $options{value} % $_->{value};
          $str_append = ' ';
      }
  
      return $str;
  }
  
  sub scale_bytesbit {
      my (%options) = @_;
      
      my $base = 1024;
      if (defined($options{dst_unit}) && defined($options{src_unit})) {
          $options{value} *= 8 if ($options{dst_unit} =~ /b/ && $options{src_unit} =~ /B/);
          $options{value} /= 8 if ($options{dst_unit} =~ /B/ && $options{src_unit} =~ /b/);
          if ($options{dst_unit} =~ /b/) {
              $base = 1000;
          }
      }
          
      my %expo = ('' => 0, k => 1, m => 2, g => 3, t => 4, p => 5, e => 6);
      my ($src_expo, $dst_expo) = (0, 0);
      $src_expo = $expo{lc($options{src_quantity})} if (defined($options{src_quantity}) && $options{src_quantity} =~ /[kmgtpe]/i);
      if ($options{dst_unit} eq 'auto') {
          my @auto = ('', 'k', 'm', 'g', 't', 'p', 'e');
          my $i = defined($options{src_quantity}) ? $expo{$options{src_quantity}} : 0;
          for (; $i < scalar(@auto); $i++) {
              last if ($options{value} < $base);
              $options{value} = $options{value} / $base;
          }
  
          return ($options{value}, $auto[$i], $options{src_unit});
      } elsif (defined($options{dst_quantity}) && ($options{dst_quantity} eq '' || $options{dst_quantity} =~ /[kmgtpe]/i )) {
          my $dst_expo = $expo{lc($options{dst_quantity})};
          if ($dst_expo - $src_expo > 0) {
              $options{value} = $options{value} / ($base ** ($dst_expo - $src_expo));
          } elsif ($dst_expo - $src_expo < 0) {
              $options{value} = $options{value} * ($base ** (($dst_expo - $src_expo) * -1));
          }
      }
      
      return $options{value};
  }
  
  sub convert_bytes {
      my (%options) = @_;
  
      my %expo = (k => 1, m => 2, g => 3, t => 4, p => 5);
      my $value = $options{value};
      my $base = defined($options{network}) ? 1000 : 1024;    
      if ($options{unit} =~ /([kmgt])b/i) {
          $value = $value * ($base ** $expo{lc($1)});
      }
  
      return $value;
  }
  
  sub expand_exponential {
      my (%options) = @_;
      
      return $options{value} unless ($options{value} =~ /^(.*)e([-+]?)(.*)$/);
      my ($num, $sign, $exp) = ($1, $2, $3);
      my $sig = $sign eq '-' ? "." . ($exp - 1 + length $num) : '';
      return sprintf("%${sig}f", $options{value});
  }
  
  sub parse_threshold {
      my (%options) = @_;
  
      my $perf = trim($options{threshold});
      my $perf_result = { arobase => 0, infinite_neg => 0, infinite_pos => 0, start => '', end => '' };
  
      my $global_status = 1;    
      if ($perf =~ /^(\@?)((?:~|(?:\+|-)?\d+(?:[\.,]\d+)?(?:[KMGTPE][bB])?|):)?((?:\+|-)?\d+(?:[\.,]\d+)?(?:[KMGTPE][bB])?)?$/) {
          $perf_result->{start} = $2 if (defined($2));
          $perf_result->{end} = $3 if (defined($3));
          $perf_result->{arobase} = 1 if (defined($1) && $1 eq '@');
          $perf_result->{start} =~ s/[\+:]//g;
          $perf_result->{end} =~ s/\+//;
          if ($perf_result->{start} =~ s/([KMGTPE])([bB])//) {
              $perf_result->{start} = scale_bytesbit(
                  value => $perf_result->{start},
                  src_unit => $2, dst_unit => $2,
                  src_quantity => $1, dst_quantity => '',
              );
          }
          if ($perf_result->{end} =~ s/([KMGTPE])([bB])//) {
              $perf_result->{end} = scale_bytesbit(
                  value => $perf_result->{end},
                  src_unit => $2, dst_unit => $2,
                  src_quantity => $1, dst_quantity => '',
              );
          }
          if ($perf_result->{end} eq '') {
              $perf_result->{end} = 1e500;
              $perf_result->{infinite_pos} = 1;
          }
          $perf_result->{start} = 0 if ($perf_result->{start} eq '');      
          $perf_result->{start} =~ s/,/\./;
          $perf_result->{end} =~ s/,/\./;
          
          if ($perf_result->{start} eq '~') {
              $perf_result->{start} = -1e500;
              $perf_result->{infinite_neg} = 1;
          }
      } else {
          $global_status = 0;
      }
  
      return ($global_status, $perf_result);
  }
  
  sub get_threshold_litteral {
      my (%options) = @_;
      
      my $perf_output = ($options{arobase} == 1 ? '@' : '') . 
                        (($options{infinite_neg} == 0) ? $options{start} : '~') . 
                        ':' . 
                        (($options{infinite_pos} == 0) ? $options{end} : '');
      return $perf_output;
  }
  
  sub set_timezone {
      my (%options) = @_;
      
      return {} if (!defined($options{name}) || $options{name} eq '');
       
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'DateTime::TimeZone',
                                             error_msg => "Cannot load module 'DateTime::TimeZone'.");
      if (DateTime::TimeZone->is_valid_name($options{name})) {
          return { time_zone => DateTime::TimeZone->new(name => $options{name}) };
      }
      
      # try to manage syntax (:Pacific/Noumea for example)
      if ($options{name} =~ /^:(.*)$/ && DateTime::TimeZone->is_valid_name($1)) {
          return { time_zone => DateTime::TimeZone->new(name => $1) };
      }
  
      return {};
  }
  
  1;
  
  
CENTREON_PLUGINS_MISC

$fatpacked{"centreon/plugins/mode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MODE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::mode;
  
  use strict;
  use warnings;
  use centreon::plugins::perfdata;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{perfdata} = centreon::plugins::perfdata->new(output => $options{output});
      
      %{$self->{option_results}} = ();
      $self->{output} = $options{output};
      $self->{output}->use_new_perfdata(value => 1)
          if (defined($options{force_new_perfdata}) && $options{force_new_perfdata} == 1);
      $self->{mode} = $options{mode};
      $self->{version} = '1.0';
  
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      # options{default} = { mode_xxx => { option_name => option_value }, }
  
      %{$self->{option_results}} = %{$options{option_results}};
      # Manage default value
      return if (!defined($options{default}));
      foreach (keys %{$options{default}}) {
          if ($_ eq $self->{mode}) {
              foreach my $value (keys %{$options{default}->{$_}}) {
                  if (!defined($self->{option_results}->{$value})) {
                      $self->{option_results}->{$value} = $options{default}->{$_}->{$value};
                  }
              }
          }
      }
  }
  
  sub version {
      my ($self, %options) = @_;
      
      $self->{output}->add_option_msg(short_msg => "Mode Version: " . $self->{version});
  }
  
  sub disco_format {
      my ($self, %options) = @_;
  
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
  }
  
  1;
  
  
CENTREON_PLUGINS_MODE

$fatpacked{"centreon/plugins/options.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_OPTIONS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::options;
  
  use Pod::Usage;
  use Pod::Find qw(pod_where);
  use strict;
  use warnings;
  
  my $alternative = 1;
  
  sub new {
      my ($class) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{sanity} = 0;
      $self->{options_stored} = {};
      $self->{options} = {};
      @{$self->{pod_package}} = ();
      $self->{pod_packages_once} = {};
      
      if ($alternative == 0) {
          require Getopt::Long;
          Getopt::Long->import();
          Getopt::Long::Configure("pass_through");
          Getopt::Long::Configure('bundling');
          Getopt::Long::Configure('no_auto_abbrev');
      } else {
          require centreon::plugins::alternative::Getopt;
          $centreon::plugins::alternative::Getopt::warn_message = 0;
          centreon::plugins::alternative::Getopt->import();
      }
      
      return $self;
  }
  
  sub set_sanity {
      my ($self, %options) = @_;
      
      if ($alternative == 0) {
          Getopt::Long::Configure('no_pass_through');
      } else {
          $centreon::plugins::alternative::Getopt::warn_message = 1;
      }
  
      $self->{sanity} = 1;
  }
  
  sub set_output {
      my ($self, %options) = @_;
      
      $self->{output} = $options{output};
  }
  
  sub display_help {
      my ($self, %options) = @_;
      
      my $stdout;
      foreach (@{$self->{pod_package}}) {
          
          {
              local *STDOUT;
              open STDOUT, '>', \$stdout;
              my $where = pod_where({-inc => 1}, $_->{package});
              pod2usage(-exitval => 'NOEXIT', -input => $where,
                        -verbose => 99, 
                        -sections => $_->{sections}) if (defined($where));
          }
          
          $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
      }
  }
  
  sub add_help {
      my ($self, %options) = @_;
      # $options{package} = string package
      # $options{sections} = string sections
      # $options{help_first} = put at the beginning
      # $options{once} = put help only one time for a package
      
      if (defined($options{once}) && defined($self->{pod_packages_once}->{$options{package}})) {
          return ;
      }
      
      if (defined($options{help_first})) {
          unshift @{$self->{pod_package}}, {package => $options{package}, sections => $options{sections}};
      } else {
          push @{$self->{pod_package}}, { package => $options{package}, sections => $options{sections} };
      }
      
      $self->{pod_packages_once}->{$options{package}} = 1;
  }
  
  sub add_options {
      my ($self, %options) = @_;
      # $options{arguments} = ref to hash table with string and name to store (example: { 'mode:s' => { name => 'mode', default => 'defaultvalue' )
      
      foreach (keys %{$options{arguments}}) {
          if (defined($options{arguments}->{$_}->{redirect})) {
              $self->{options}->{$_} = \$self->{options_stored}->{$options{arguments}->{$_}->{redirect}};
              next;
          }
          
          if (defined($options{arguments}->{$_}->{default})) {
              $self->{options_stored}->{$options{arguments}->{$_}->{name}} = $options{arguments}->{$_}->{default};
          } else {
              $self->{options_stored}->{$options{arguments}->{$_}->{name}} = undef;
          }
          
          $self->{options}->{$_} = \$self->{options_stored}->{$options{arguments}->{$_}->{name}};
      }
  }
  
  sub parse_options {
      my $self = shift;
      #%{$self->{options_stored}} = ();
  
      my $save_warn_handler;
      if ($self->{sanity} == 1) {
          $save_warn_handler = $SIG{__WARN__};
          $SIG{__WARN__} = sub {
              $self->{output}->add_option_msg(short_msg => $_[0]);
              $self->{output}->option_exit(nolabel => 1);
          };
      }
      
      GetOptions(
         %{$self->{options}}
      );
      %{$self->{options}} = ();
      
      $SIG{__WARN__} = $save_warn_handler if ($self->{sanity} == 1);
  }
  
  sub get_option {
      my ($self, %options) = @_;
  
      return $self->{options_stored}->{$options{argument}};
  }
  
  sub get_options {
      my $self = shift;
  
      return $self->{options_stored};
  }
  
  sub clean {
      my $self = shift;
      
      $self->{options_stored} = {};
  }
  
  1;
  
CENTREON_PLUGINS_OPTIONS

$fatpacked{"centreon/plugins/output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_OUTPUT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::output;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      if (!defined($options{options})) {
          print "Class Output: Need to specify 'options' argument to load.\n";
          exit 3;
      }
  
      $options{options}->add_options(arguments => {
          'explode-perfdata-max:s@' => { name => 'explode_perfdata_max' },
          'range-perfdata:s'        => { name => 'range_perfdata' },
          'filter-perfdata:s'       => { name => 'filter_perfdata' },
          'change-perfdata:s@'      => { name => 'change_perfdata' },
          'extend-perfdata:s@'      => { name => 'extend_perfdata' },
          'extend-perfdata-group:s@'=> { name => 'extend_perfdata_group' },
          'change-short-output:s@'  => { name => 'change_short_output' },
          'use-new-perfdata'        => { name => 'use_new_perfdata' },
          'filter-uom:s'            => { name => 'filter_uom' },
          'verbose'                 => { name => 'verbose' },
          'debug'                   => { name => 'debug' },
          'opt-exit:s'              => { name => 'opt_exit', default => 'unknown' },
          'output-xml'              => { name => 'output_xml' },
          'output-json'             => { name => 'output_json' },
          'output-openmetrics'      => { name => 'output_openmetrics' },
          'output-file:s'           => { name => 'output_file' },
          'disco-format'            => { name => 'disco_format' },
          'disco-show'              => { name => 'disco_show' },
          'float-precision:s'       => { name => 'float_precision', default => 8 },
      });
      
      %{$self->{option_results}} = ();
  
      $self->{option_msg} = [];
      
      $self->{is_output_xml} = 0;
      $self->{is_output_json} = 0;
      $self->{errors} = {OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3, PENDING => 4};
      $self->{errors_num} = {0 => 'OK', 1 => 'WARNING', 2 => 'CRITICAL', 3 => 'UNKNOWN', 4 => 'PENDING'};
      $self->{myerrors} = {0 => "OK", 1 => "WARNING", 3 => "UNKNOWN", 7 => "CRITICAL"};
      $self->{myerrors_mask} = {CRITICAL => 7, WARNING => 1, UNKNOWN => 3, OK => 0};
      $self->{global_short_concat_outputs} = {OK => undef, WARNING => undef, CRITICAL => undef, UNKNOWN => undef, UNQUALIFIED_YET => undef};
      $self->{global_short_outputs} = {OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [], UNQUALIFIED_YET => []};
      $self->{global_long_output} = [];
      $self->{perfdatas} = [];
      $self->{explode_perfdatas} = {};
      $self->{change_perfdata} = {};
      $self->{explode_perfdata_total} = 0;
      $self->{range_perfdata} = 0;
      $self->{global_status} = 0;
      $self->{encode_utf8_import} = 0;
      $self->{perlqq} = 0;
  
      $self->{disco_elements} = [];
      $self->{disco_entries} = [];
  
      $self->{plugin} = '';
      $self->{mode} = '';
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      # $options{option_results} = ref to options result
  
      %{$self->{option_results}} = %{$options{option_results}};
      $self->{option_results}->{opt_exit} = lc($self->{option_results}->{opt_exit});
      if (!$self->is_litteral_status(status => $self->{option_results}->{opt_exit})) {
          $self->add_option_msg(short_msg => "Unknown value '" . $self->{option_results}->{opt_exit}  . "' for --opt-exit.");
          $self->option_exit(exit_litteral => 'unknown');
      }
      # Go in XML Mode
      if ($self->is_disco_show() || $self->is_disco_format()) {
          # By Default XML
          if (!defined($self->{option_results}->{output_json})) {
              $self->{option_results}->{output_xml} = 1;
          }
      }
      
      if (defined($self->{option_results}->{range_perfdata})) {
          $self->{range_perfdata} = $self->{option_results}->{range_perfdata};
          $self->{range_perfdata} = 1 if ($self->{range_perfdata} eq '');
          if ($self->{range_perfdata} !~ /^[012]$/) {
              $self->add_option_msg(short_msg => "Wrong range-perfdata option '" . $self->{range_perfdata} . "'");
              $self->option_exit();
          }
      }
      
      if (defined($self->{option_results}->{explode_perfdata_max})) {
          if (${$self->{option_results}->{explode_perfdata_max}}[0] eq '') {
              $self->{explode_perfdata_total} = 2;
          } else {
              $self->{explode_perfdata_total} = 1;
              foreach (@{$self->{option_results}->{explode_perfdata_max}}) {
                  my ($perf_match, $perf_result) = split /,/;
                  if (!defined($perf_result)) {
                      $self->add_option_msg(short_msg => "Wrong explode-perfdata-max option '" . $_ . "' (syntax: match,value)");
                      $self->option_exit();
                  }
                  $self->{explode_perfdatas}->{$perf_match} = $perf_result;
              }
          }
      }
      
      $self->load_perfdata_extend_args();
      $self->{option_results}->{use_new_perfdata} = 1 if (defined($self->{option_results}->{output_openmetrics}));
  }
  
  sub add_option_msg {
      my ($self, %options) = @_;
      # $options{short_msg} = string msg
      # $options{long_msg} = string msg
      $options{severity} = 'UNQUALIFIED_YET';
      
      $self->output_add(%options);
  }
  
  sub set_status {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
  
      # Nothing to do for 'UNQUALIFIED_YET'
      if (!$self->{myerrors_mask}->{uc($options{exit_litteral})}) {
          return ;
      }
      $self->{global_status} |= $self->{myerrors_mask}->{uc($options{exit_litteral})};
  }
  
  sub output_add {
      my ($self, %params) = @_;
      my %args = (
          severity => 'OK',
          separator => ' - ',
          debug => 0,
          short_msg => undef,
          long_msg => undef,
      );
      my $options = {%args, %params};
      
      if (defined($options->{short_msg})) {
          chomp $options->{short_msg};
          if (defined($self->{global_short_concat_outputs}->{uc($options->{severity})})) {
              $self->{global_short_concat_outputs}->{uc($options->{severity})} .= $options->{separator} . $options->{short_msg};
          } else {
              $self->{global_short_concat_outputs}->{uc($options->{severity})} = $options->{short_msg};
          }
          
          push @{$self->{global_short_outputs}->{uc($options->{severity})}}, $options->{short_msg};
          $self->set_status(exit_litteral => $options->{severity});
      }
      if (defined($options->{long_msg}) && 
          ($options->{debug} == 0 || defined($self->{option_results}->{debug}))) {
          chomp $options->{long_msg};
          push @{$self->{global_long_output}}, $options->{long_msg};
      }
  }
  
  sub perfdata_add {
      my ($self, %options) = @_;
      my $perfdata = {
          label => '', value => '', unit => '', warning => '', critical => '', min => '', max => ''
      };
      foreach (keys %options) {
          next if (!defined($options{$_}));
          $perfdata->{$_} = $options{$_};
      }
      
      if (defined($self->{option_results}->{use_new_perfdata}) && defined($options{nlabel})) {
          $perfdata->{label} = $options{nlabel};
      }
      if (defined($options{instances})) {
          $options{instances} = [$options{instances}] if (!ref($options{instances}));
          my ($external_instance_separator, $internal_instance_separator) = ('#', '~');
          if (defined($self->{option_results}->{use_new_perfdata})) {
              $perfdata->{label} = join('~', @{$options{instances}}) . '#' . $perfdata->{label};
          } else {
              $perfdata->{label} .= '_' . join('_', @{$options{instances}});
          }
      }
      
      $perfdata->{label} =~ s/'/''/g;
      push @{$self->{perfdatas}}, $perfdata;
  }
  
  sub range_perfdata {
      my ($self, %options) = @_;
      
      return if ($self->{range_perfdata} == 0);
      if ($self->{range_perfdata} == 1) {
          for (my $i = 0; $i < scalar(@{$options{ranges}}); $i++) {
              ${${$options{ranges}}[$i]} =~ s/^(@?)-?[0\.]+:/$1/;
          }
      } else {
          for (my $i = 0; $i < scalar(@{$options{ranges}}); $i++) {
              ${${$options{ranges}}[$i]} = '';
          }
      }
  }
  
  sub output_json {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      my $json_content = {
          plugin => {
              name => $self->{plugin},
              mode => $self->{mode},
              exit => $options{exit_litteral},
              outputs => [],
              perfdatas => []
          }
      };    
  
      foreach my $code_litteral (keys %{$self->{global_short_outputs}}) {
          foreach (@{$self->{global_short_outputs}->{$code_litteral}}) {
              my ($child_output, $child_type, $child_msg, $child_exit);
              my $lcode_litteral = ($code_litteral eq 'UNQUALIFIED_YET' ? uc($options{exit_litteral}) : $code_litteral);
  
              push @{$json_content->{plugin}->{outputs}}, {
                  type => 1,
                  msg => ($options{nolabel} == 0 ? ($lcode_litteral . ': ') : '') . $_,
                  exit => $lcode_litteral
              };
          }
      }
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          foreach (@{$self->{global_long_output}}) {
              push @{$json_content->{plugin}->{outputs}}, {
                  type => 2,
                  msg => $_,
              };
          }
      }
  
      if ($options{force_ignore_perfdata} == 0) {
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if (defined($self->{option_results}->{filter_perfdata}) &&
                       $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
              
              my %values = ();
              foreach my $key (keys %$perf) {
                  $perf->{$key} = '' if (defined($self->{option_results}->{filter_uom}) && $key eq 'unit' &&
                      $perf->{$key} !~ /$self->{option_results}->{filter_uom}/);
                  $values{$key} = $perf->{$key};
              }
              
              push @{$json_content->{plugin}->{perfdatas}}, {
                  %values
              };
          }
      }
  
      print $self->{json_output}->encode($json_content);
  }
  
  sub output_xml {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      my ($child_plugin_name, $child_plugin_mode, $child_plugin_exit, $child_plugin_output, $child_plugin_perfdata); 
  
      my $root = $self->{xml_output}->createElement('plugin');
      $self->{xml_output}->setDocumentElement($root);
  
      $child_plugin_name = $self->{xml_output}->createElement('name');
      $child_plugin_name->appendText($self->{plugin});
  
      $child_plugin_mode = $self->{xml_output}->createElement('mode');
      $child_plugin_mode->appendText($self->{mode});
  
      $child_plugin_exit = $self->{xml_output}->createElement('exit');
      $child_plugin_exit->appendText($options{exit_litteral});
  
      $child_plugin_output = $self->{xml_output}->createElement('outputs');
      $child_plugin_perfdata = $self->{xml_output}->createElement('perfdatas');
  
      $root->addChild($child_plugin_name);
      $root->addChild($child_plugin_mode);
      $root->addChild($child_plugin_exit);
      $root->addChild($child_plugin_output);
      $root->addChild($child_plugin_perfdata);
  
      foreach my $code_litteral (keys %{$self->{global_short_outputs}}) {
          foreach (@{$self->{global_short_outputs}->{$code_litteral}}) {
              my ($child_output, $child_type, $child_msg, $child_exit);
              my $lcode_litteral = ($code_litteral eq 'UNQUALIFIED_YET' ? uc($options{exit_litteral}) : $code_litteral);
  
              $child_output = $self->{xml_output}->createElement('output');
              $child_plugin_output->addChild($child_output);
  
              $child_type = $self->{xml_output}->createElement('type');
              $child_type->appendText(1); # short
  
              $child_msg = $self->{xml_output}->createElement('msg');
              $child_msg->appendText(($options{nolabel} == 0 ? ($lcode_litteral . ': ') : '') . $_);
              $child_exit = $self->{xml_output}->createElement('exit');
              $child_exit->appendText($lcode_litteral);
  
              $child_output->addChild($child_type);
              $child_output->addChild($child_exit);
              $child_output->addChild($child_msg);
          }
      }
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          foreach (@{$self->{global_long_output}}) {
              my ($child_output, $child_type, $child_msg);
          
              $child_output = $self->{xml_output}->createElement('output');
              $child_plugin_output->addChild($child_output);
  
              $child_type = $self->{xml_output}->createElement('type');
              $child_type->appendText(2); # long
  
              $child_msg = $self->{xml_output}->createElement('msg');
              $child_msg->appendText($_);
  
              $child_output->addChild($child_type);
              $child_output->addChild($child_msg);
          }
      }
  
      if ($options{force_ignore_perfdata} == 0) {
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if (defined($self->{option_results}->{filter_perfdata}) &&
                       $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
          
              my ($child_perfdata);
              $child_perfdata = $self->{xml_output}->createElement('perfdata');
              $child_plugin_perfdata->addChild($child_perfdata);
              foreach my $key (keys %$perf) {
                  $perf->{$key} = '' if (defined($self->{option_results}->{filter_uom}) && $key eq 'unit' &&
                      $perf->{$key} !~ /$self->{option_results}->{filter_uom}/);
                  my $child = $self->{xml_output}->createElement($key);
                  $child->appendText($perf->{$key});
                  $child_perfdata->addChild($child);
              }
          }
      }
  
      print $self->{xml_output}->toString(1);
  }
  
  sub output_openmetrics {
      my ($self, %options) = @_;
  
      $self->change_perfdata();
      foreach my $perf (@{$self->{perfdatas}}) {
          next if (defined($self->{option_results}->{filter_perfdata}) &&
                   $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
          $perf->{unit} = '' if (defined($self->{option_results}->{filter_uom}) &&
              $perf->{unit} !~ /$self->{option_results}->{filter_uom}/);
          $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
          my $label = $perf->{label};
          my $instance;
          if ($label =~ /^(.*?)#(.*)$/) {
              ($perf->{instance}, $label) = ($1, $2);
          }
          my ($bucket, $append) = ('{plugin="' . $self->{plugin} . '",mode="' . $self->{mode} . '"', '');
          foreach ('unit', 'warning', 'critical', 'min', 'max', 'instance') {
              if (defined($perf->{$_}) && $perf->{$_} ne '') {
                  $bucket .= ',' . $_ . '="' . $perf->{$_} . '"';
              }
          }
          $bucket .= '}';
          
          print $label . $bucket . ' ' . $perf->{value} . "\n";
      }
  }
  
  sub output_txt_short_display {
      my ($self, %options) = @_;
      
      if (defined($self->{global_short_concat_outputs}->{CRITICAL})) {
          print (($options{nolabel} == 0 ? 'CRITICAL: ' : '') . $self->{global_short_concat_outputs}->{CRITICAL} . " ");
      }
      if (defined($self->{global_short_concat_outputs}->{WARNING})) {
          print (($options{nolabel} == 0 ? 'WARNING: ' : '') . $self->{global_short_concat_outputs}->{WARNING} . " ");
      }
      if (defined($self->{global_short_concat_outputs}->{UNKNOWN})) {
          print (($options{nolabel} == 0 ? 'UNKNOWN: ' : '') . $self->{global_short_concat_outputs}->{UNKNOWN} . " ");
      }
      if (uc($options{exit_litteral}) eq 'OK') {
          print (($options{nolabel} == 0 ? 'OK: ' : '') . (defined($self->{global_short_concat_outputs}->{OK}) ? $self->{global_short_concat_outputs}->{OK} : '') . " ");
      }
  }
  
  sub output_txt_short {
      my ($self, %options) = @_;
      
      if (!defined($self->{option_results}->{change_short_output})) {
          $self->output_txt_short_display(%options);
          return ;
      }
      
      my $stdout = '';
      {
          local *STDOUT;
          open STDOUT, '>', \$stdout;
          $self->output_txt_short_display(%options);
      }
      
      foreach (@{$self->{option_results}->{change_short_output}}) {
           my ($pattern, $replace, $modifier) = split /~/;
           next if (!defined($pattern));
           $replace = '' if (!defined($replace));
           $modifier = '' if (!defined($modifier));
           eval "\$stdout =~ s{$pattern}{$replace}$modifier";
      }
      
      print $stdout;
  }
  
  sub output_txt {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
  
      if (defined($self->{global_short_concat_outputs}->{UNQUALIFIED_YET})) {
          $self->output_add(severity => uc($options{exit_litteral}), short_msg => $self->{global_short_concat_outputs}->{UNQUALIFIED_YET});
      }
  
      $self->output_txt_short(%options);
  
      if ($force_ignore_perfdata == 1) {
          print "\n";
      } else {
          print '|';
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if (defined($self->{option_results}->{filter_perfdata}) &&
                       $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
              $perf->{unit} = '' if (defined($self->{option_results}->{filter_uom}) &&
                  $perf->{unit} !~ /$self->{option_results}->{filter_uom}/);
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
              print " '" . $perf->{label} . "'=" . $perf->{value} . $perf->{unit} . ';' . $perf->{warning} . ';' . $perf->{critical} . ';' . $perf->{min} . ';' . $perf->{max};
          }
          print "\n";
      }
      
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          if (scalar(@{$self->{global_long_output}})) {
              print join("\n", @{$self->{global_long_output}});
              print "\n";
          }
      }
  }
  
  sub display {
      my ($self, %options) = @_;
      my $nolabel = defined($options{nolabel}) ? 1 : 0;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      $force_long_output = 1 if (defined($self->{option_results}->{debug}));
  
      if (defined($self->{option_results}->{output_file})) {
          if (!open (STDOUT, '>', $self->{option_results}->{output_file})) {
              $self->output_add(severity => 'UNKNOWN',
                                short_msg => "cannot open file  '" . $self->{option_results}->{output_file} . "': $!");
          }
      }
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $self->get_litteral_status(), 
                                nolabel => $nolabel, 
                                force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output);
              return ;
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $self->get_litteral_status(), 
                                 nolabel => $nolabel,
                                 force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output);
              return ;
          }
      } elsif (defined($self->{option_results}->{output_openmetrics})) {
          $self->output_openmetrics();
          return ;
      }
      
      $self->output_txt(
          exit_litteral => $self->get_litteral_status(), 
          nolabel => $nolabel,
          force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output
      );
  }
  
  sub die_exit {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
      # $options{nolabel} = interger label display
      my $exit_litteral = defined($options{exit_litteral}) ? $options{exit_litteral} : $self->{option_results}->{opt_exit};
      my $nolabel = defined($options{nolabel}) ? 1 : 0;
      # ignore long output in the following case
      $self->{option_results}->{verbose} = undef;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } 
  
      $self->output_txt(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
      $self->exit(exit_litteral => $exit_litteral);
  }
  
  sub option_exit {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
      # $options{nolabel} = interger label display
      my $exit_litteral = defined($options{exit_litteral}) ? $options{exit_litteral} : $self->{option_results}->{opt_exit};
      my $nolabel = defined($options{nolabel}) ? 1 : 0;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      }
  
      $self->output_txt(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
      $self->exit(exit_litteral => $exit_litteral);
  }
  
  sub exit {
      my ($self, %options) = @_;
      # $options{exit_litteral} = exit
      
      if (defined($options{exit_litteral})) {
          exit $self->{errors}->{uc($options{exit_litteral})};
      }
      exit $self->{errors}->{$self->{myerrors}->{$self->{global_status}}};
  }
  
  sub get_most_critical {
      my ($self, %options) = @_;
      my $current_status = 0; # For 'OK'
  
      foreach (@{$options{status}}) {
          if ($self->{myerrors_mask}->{uc($_)} > $current_status) {
              $current_status = $self->{myerrors_mask}->{uc($_)};
          }
      }
      return $self->{myerrors}->{$current_status};
  }
  
  sub get_litteral_status {
      my ($self, %options) = @_;
      
      if (defined($options{status})) {
          if (defined($self->{errors_num}->{$options{status}})) {
              return $self->{errors_num}->{$options{status}};
          }
          return $options{status};
      } else {
          return $self->{myerrors}->{$self->{global_status}};
      }
  }
  
  sub is_status {
      my ($self, %options) = @_;
      # $options{value} = string status 
      # $options{litteral} = value is litteral
      # $options{compare} = string status 
  
      if (defined($options{litteral})) {
          my $value = defined($options{value}) ? $options{value} : $self->get_litteral_status();
      
          if (uc($value) eq uc($options{compare})) {
              return 1;
          }
          return 0;
      }
  
      my $value = defined($options{value}) ? $options{value} : $self->{global_status};
      my $dec_val = $self->{myerrors_mask}->{$value};
      my $lresult = $value & $dec_val;
      # Need to manage 0
      if ($lresult > 0 || ($dec_val == 0 && $value == 0)) {
          return 1;
      }
      return 0;
  }
  
  sub is_litteral_status {
      my ($self, %options) = @_;
      # $options{status} = string status
  
      if (defined($self->{errors}->{uc($options{status})})) {
          return 1;
      }
  
      return 0;
  }
  
  sub create_json_document {
      my ($self) = @_;
  
      if (centreon::plugins::misc::mymodule_load(no_quit => 1, module => 'JSON',
                                             error_msg => "Cannot load module 'JSON'.")) {
          print "Cannot load module 'JSON'\n";
          $self->exit(exit_litteral => 'unknown');
      }
      $self->{is_output_json} = 1;
      $self->{json_output} = JSON->new->utf8();
  }
  
  sub create_xml_document {
      my ($self) = @_;
  
      if (centreon::plugins::misc::mymodule_load(no_quit => 1, module => 'XML::LibXML',
                                             error_msg => "Cannot load module 'XML::LibXML'.")) {
          print "Cannot load module 'XML::LibXML'\n";
          $self->exit(exit_litteral => 'unknown');
      }
      $self->{is_output_xml} = 1;
      $self->{xml_output} = XML::LibXML::Document->new('1.0', 'utf-8');
  }
  
  sub plugin {
      my ($self, %options) = @_;
      # $options{name} = string name
      
      if (defined($options{name})) {
          $self->{plugin} = $options{name};
      }
      return $self->{plugin};
  }
  
  sub mode {
      my ($self, %options) = @_;
      # $options{name} = string name
  
      if (defined($options{name})) {
          $self->{mode} = $options{name};
      }
      return $self->{mode};
  }
  
  sub add_disco_format {
      my ($self, %options) = @_;
  
      push @{$self->{disco_elements}}, @{$options{elements}};
  }
  
  sub display_disco_format {
      my ($self, %options) = @_;
      
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
      
          my $root = $self->{xml_output}->createElement('data');
          $self->{xml_output}->setDocumentElement($root);
  
          foreach (@{$self->{disco_elements}}) {
              my $child = $self->{xml_output}->createElement("element");
              $child->appendText($_);
              $root->addChild($child);
          }
  
          print $self->{xml_output}->toString(1);
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          my $json_content = {data => [] };
          foreach (@{$self->{disco_elements}}) {
              push @{$json_content->{data}}, $_;
          }
          
          print $self->{json_output}->encode($json_content);
      }
  }
  
  sub display_disco_show {
      my ($self, %options) = @_;
      
       if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          
          my $root = $self->{xml_output}->createElement('data');
          $self->{xml_output}->setDocumentElement($root);
  
          foreach (@{$self->{disco_entries}}) {
              my $child = $self->{xml_output}->createElement('label');
              foreach my $key (keys %$_) {
                  $child->setAttribute($key, $_->{$key});
              }
              $root->addChild($child);
          }
  
          print $self->{xml_output}->toString(1);
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          my $json_content = {data => [] };
          foreach (@{$self->{disco_entries}}) {
              my %values = ();
              foreach my $key (keys %$_) {
                  $values{$key} = $_->{$key};
              }
              push @{$json_content->{data}}, {%values};
          }
          
          print $self->{json_output}->encode($json_content);
      }
  }
  
  sub to_utf8 {
      my ($self, $value) = @_;
      
      if ($self->{encode_utf8_import} == 0) {
          # Some Perl version dont have the following module (like Perl 5.6.x)
          if (centreon::plugins::misc::mymodule_load(no_quit => 1, module => 'Encode',
                                                     error_msg => "Cannot load module 'Encode'.")) {
              print "Cannot load module 'Encode'\n";
              $self->exit(exit_litteral => 'unknown');
          }
          
          $self->{encode_utf8_import} = 1;
          eval '$self->{perlqq} = Encode::PERLQQ';
      }
      
      return centreon::plugins::misc::trim(Encode::decode('UTF-8', $value, $self->{perlqq}));
  }
  
  sub add_disco_entry {
      my ($self, %options) = @_;
      
      push @{$self->{disco_entries}}, {%options};
  }
  
  sub is_disco_format {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{disco_format})) {
          return 1;
      }
      return 0;
  }
  
  sub is_disco_show {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{disco_show})) {
          return 1;
      }
      return 0;
  }
  
  sub is_verbose {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{verbose})) {
          return 1;
      }
      return 0;
  }
  
  sub is_debug {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{debug})) {
          return 1;
      }
      return 0;
  }
  
  sub use_new_perfdata {
      my ($self, %options) = @_;
  
      $self->{option_results}->{use_new_perfdata} = $options{value}
          if (defined($options{value}));
      if (defined($self->{option_results}->{use_new_perfdata})) {
          return 1;
      }
      return 0;
  }
  
  sub get_instance_perfdata_separator {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{use_new_perfdata})) {
          return '~';
      }
      return '_';
  }
  
  sub parse_pfdata_scale {
      my ($self, %options) = @_;
      
      # --extend-perfdata=traffic_in,,scale(Mbps),mbps
      my $args = { unit => 'auto' };
      if ($options{args} =~ /^([KMGTPEkmgtpe])?(B|b|bps|Bps|b\/s|auto)$/) {
          $args->{quantity} = defined($1) ? $1 : '';
          $args->{unit} = $2;
      } elsif ($options{args} ne '') {
          return 1;
      }
      
      return (0, $args);
  }
  
  sub parse_pfdata_math {
      my ($self, %options) = @_;
  
      # --extend-perfdata=perfx,,math(current + 10 - 100, 1)
      my $args = { math => undef, apply_threshold => 0 };
      my ($math, $apply_threshold) = split /\|/, $options{args};
      if ($math =~ /^((?:[\s\.\-\+\*\/0-9\(\)]|current)+)$/) {
          $args->{math} = $1;
      } elsif ($options{args} ne '') {
          return 1;
      }
      
      if (defined($apply_threshold) && $apply_threshold =~ /^\s*(0|1)\s*$/ ) {
          $args->{apply_threshold} = $1;
      }
      
      return (0, $args);
  }
  
  sub parse_group_pfdata {
      my ($self, %options) = @_;
      
      $options{args} =~ s/^\s+//;
      $options{args} =~ s/\s+$//;
      my $args = { pattern_pf => $options{args} };
      return $args;
  }
  
  sub parse_pfdata_min {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_max {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_average {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_sum {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub apply_pfdata_scale {
      my ($self, %options) = @_;
      
      return if (${$options{perf}}->{unit} !~ /^([KMGTPEkmgtpe])?(B|b|bps|Bps|b\/s)$/);
      
      my ($src_quantity, $src_unit) = ($1, $2);
      my ($value, $dst_quantity, $dst_unit) = centreon::plugins::misc::scale_bytesbit(value => ${$options{perf}}->{value},
          src_quantity => $src_quantity, src_unit => $src_unit, dst_quantity => $options{args}->{quantity}, dst_unit => $options{args}->{unit});
      ${$options{perf}}->{value} = sprintf("%.2f", $value);
      if (defined($dst_unit)) {
         ${$options{perf}}->{unit} = $dst_quantity . $dst_unit;
      } else {
          ${$options{perf}}->{unit} = $options{args}->{quantity} . $options{args}->{unit};
      }
      
      if (defined(${$options{perf}}->{max}) && ${$options{perf}}->{max} ne '') {
          ($value) = centreon::plugins::misc::scale_bytesbit(value => ${$options{perf}}->{max},
              src_quantity => $src_quantity, src_unit => $src_unit, 
              dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity}, 
              dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          ${$options{perf}}->{max} = sprintf('%.2f', $value);
      }
      
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              ($result->{start}) = centreon::plugins::misc::scale_bytesbit(value => $result->{start},
                  src_quantity => $src_quantity, src_unit => $src_unit, 
                  dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity}, 
                  dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              ($result->{end}) = centreon::plugins::misc::scale_bytesbit(value => $result->{end},
                  src_quantity => $src_quantity, src_unit => $src_unit, 
                  dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity}, 
                  dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
  }
  
  sub apply_pfdata_invert {
      my ($self, %options) = @_;
      
      return if (!defined(${$options{perf}}->{max}) || ${$options{perf}}->{max} eq '');
      
      ${$options{perf}}->{value} = ${$options{perf}}->{max} - ${$options{perf}}->{value};
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
          
          my $tmp = { arobase => $result->{arobase}, infinite_pos => 0, infinite_neg => 0, start => $result->{start}, end => $result->{end} };
          $tmp->{infinite_neg} = 1 if ($result->{infinite_pos} == 1);
          $tmp->{infinite_pos} = 1 if ($result->{infinite_neg} == 1);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $tmp->{end} = ${$options{perf}}->{max} - $result->{start};
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $tmp->{start} = ${$options{perf}}->{max} - $result->{end};
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$tmp);
      }
  }
  
  sub apply_pfdata_percent {
      my ($self, %options) = @_;
  
      return if (!defined(${$options{perf}}->{max}) || ${$options{perf}}->{max} eq '');
      
      ${$options{perf}}->{value} = sprintf('%.2f', ${$options{perf}}->{value} * 100 / ${$options{perf}}->{max});
      ${$options{perf}}->{unit} = '%';
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $result->{start} = sprintf('%.2f', $result->{start} * 100 / ${$options{perf}}->{max});
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $result->{end} = sprintf('%.2f', $result->{end} * 100 / ${$options{perf}}->{max});
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
      
      ${$options{perf}}->{max} = 100; 
  }
  
  sub apply_pfdata_math {
      my ($self, %options) = @_;
      
      my $math = $options{args}->{math};
      $math =~ s/current/\$value/g;
      
      my $value = ${$options{perf}}->{value};
      eval "\${\$options{perf}}->{value} = $math";
      
      return if ($options{args}->{apply_threshold} == 0);
      
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $value = $result->{start};
              eval "\$result->{start} = $math";
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $value = $result->{end};
              eval "\$result->{end} = $math";
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
      
      ${$options{perf}}->{max} = 100;
  }
  
  sub apply_pfdata_min {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my $min;
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $min = $self->{perfdatas}->[$i]->{value}
              if (!defined($min) || $min > $self->{perfdatas}->[$i]->{value});
      }
  
      ${$options{perf}}->{value} = $min
          if (defined($min));
  }
  
  sub apply_pfdata_max {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my $max;
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $max = $self->{perfdatas}->[$i]->{value}
              if (!defined($max) || $max < $self->{perfdatas}->[$i]->{value});
      }
  
      ${$options{perf}}->{value} = $max
          if (defined($max));
  }
  
  sub apply_pfdata_sum {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my ($sum, $num) = (0, 0);
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $sum += $self->{perfdatas}->[$i]->{value};
          $num++;
      }
  
      ${$options{perf}}->{value} = $sum
          if ($num > 0);
  }
  
  sub apply_pfdata_average {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my ($sum, $num) = (0, 0);
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $sum += $self->{perfdatas}->[$i]->{value};
          $num++;
      }
  
      ${$options{perf}}->{value} = sprintf("%.2f", ($sum / $num))
          if ($num > 0);
  }
  
  sub load_perfdata_extend_args {
      my ($self, %options) = @_;
  
      foreach (
          [$self->{option_results}->{change_perfdata}, 1],
          [$self->{option_results}->{extend_perfdata}, 2],
          [$self->{option_results}->{extend_perfdata_group}, 3],
      ) {
          next if (!defined($_->[0]));
          foreach my $arg (@{$_->[0]}) {
              $self->parse_perfdata_extend_args(arg => $arg, type => $_->[1]);
          }
      }
  }
  
  sub parse_perfdata_extend_args {
      my ($self, %options) = @_;
      
      # --extend-perfdata=searchlabel,newlabel,method[,[newuom],[min],[max]]
      my ($pfdata_match, $pfdata_substitute, $method, $uom_sub, $min_sub, $max_sub) = 
          split /,/, $options{arg};
      return if ((!defined($pfdata_match) || $pfdata_match eq '') && $options{type} != 3);
      
      $self->{pfdata_extends} = [] if (!defined($self->{pfdata_extends}));
      my $pfdata_extends = {
          pfdata_match => defined($pfdata_match) && $pfdata_match ne '' ? $pfdata_match : undef,
          pfdata_substitute => defined($pfdata_substitute) && $pfdata_substitute ne '' ? $pfdata_substitute : undef,
          uom_sub => defined($uom_sub) && $uom_sub ne '' ? $uom_sub : undef,
          min_sub => defined($min_sub) && $min_sub ne '' ? $min_sub : undef,
          max_sub => defined($max_sub) && $max_sub ne '' ? $max_sub : undef,
          type => $options{type}
      };
  
      if (defined($method) && $method ne '') {
          if ($method !~ /^\s*(invert|percent|scale|math|min|max|average|sum)\s*\(\s*(.*?)\s*\)\s*$/) {
              $self->output_add(long_msg => "method in argument '$options{arg}' is unknown", debug => 1);
              return ;
          }
          
          $pfdata_extends->{method_name} = $1;
          my $args = $2;
          if (my $func = $self->can('parse_pfdata_' . $pfdata_extends->{method_name})) {
              (my $status, $pfdata_extends->{method_args}) = $func->($self, args => $args);
              if ($status == 1) {
                  $self->output_add(long_msg => "argument in method '$options{arg}' is unknown", debug => 1);
                  return ;
              }
          }
      }
  
      push  @{$self->{pfdata_extends}}, $pfdata_extends;
  }
  
  sub apply_perfdata_explode {
      my ($self, %options) = @_;
      
      return if ($self->{explode_perfdata_total} == 0);
      foreach (@{$self->{perfdatas}}) {
          next if ($_->{max} eq '');
          if ($self->{explode_perfdata_total} == 2) {
              $self->perfdata_add(label => $_->{label} . '_max', value => $_->{max});
              next;
          }
          foreach my $regexp (keys %{$self->{explode_perfdatas}}) {
              if ($_->{label} =~ /$regexp/) {
                  $self->perfdata_add(label => $self->{explode_perfdatas}->{$regexp}, value => $_->{max});
                  last;
              }
          }
      }
  }
  
  sub apply_perfdata_extend {
      my ($self, %options) = @_;
  
      foreach my $extend (@{$self->{pfdata_extends}}) {
          my $new_pfdata = [];
          
          # Manage special case when type group and pfdata_match empty
          if ($extend->{type} == 3 && (!defined($extend->{pfdata_match}) || $extend->{pfdata_match} eq '')) {
              next if (!defined($extend->{pfdata_substitute}) || $extend->{pfdata_substitute} eq '');
              my $new_perf = {
                  label => $extend->{pfdata_substitute}, value => '',
                  unit => defined($extend->{uom_sub}) ? $extend->{uom_sub} : '',
                  warning => '', critical => '',
                  min => defined($extend->{min_sub}) ? $extend->{min_sub} : '',
                  max => defined($extend->{max_sub}) ? $extend->{max_sub} : ''
              };
  
              if (defined($extend->{method_name})) {
                  my $func = $self->can('apply_pfdata_' . $extend->{method_name});
                  $func->($self, perf => \$new_perf, args => $extend->{method_args});
              }
  
              if (length($new_perf->{value})) {
                  push @{$self->{perfdatas}}, $new_perf;
              }
              next;
          }
          
          for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
              next if ($self->{perfdatas}->[$i]->{label} !~ /$extend->{pfdata_match}/);
              
              my $new_perf = { %{$self->{perfdatas}->[$i]} };
              if ($extend->{type} == 3) {
                  $new_perf = { label => $self->{perfdatas}->[$i]->{label}, value => '', unit => '', warning => '', critical => '', min => '', max => '' };
              }
              
              if (defined($extend->{pfdata_substitute})) {
                  eval "\$new_perf->{label} =~ s{$extend->{pfdata_match}}{$extend->{pfdata_substitute}}";
              }
  
              if (defined($extend->{method_name})) {
                  my $func = $self->can('apply_pfdata_' . $extend->{method_name});
                  $func->($self, perf => \$new_perf, args => $extend->{method_args});
              }
              
              $new_perf->{unit} = $extend->{uom_sub} if (defined($extend->{uom_sub}));
              $new_perf->{min} = $extend->{min_sub} if (defined($extend->{min_sub}));
              $new_perf->{max} = $extend->{max_sub} if (defined($extend->{max_sub}));
  
              if ($extend->{type} == 1) {
                  $self->{perfdatas}->[$i] = $new_perf;
              } else {
                  push @$new_pfdata, $new_perf if (length($new_perf->{value}));
              }
          }
  
          push @{$self->{perfdatas}}, @$new_pfdata;
      }
  }
  
  sub change_perfdata {
      my ($self, %options) = @_;
      
      $self->apply_perfdata_extend();
      $self->apply_perfdata_explode();
  }
  
  1;
  
  
  =head1 NAME
  
  Output class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 OUTPUT OPTIONS
  
  =over 8
  
  =item B<--verbose>
  
  Display long output.
  
  =item B<--debug>
  
  Display also debug messages.
  
  =item B<--filter-perfdata>
  
  Filter perfdata that match the regexp.
  
  =item B<--explode-perfdata-max>
  
  Put max perfdata (if it exist) in a specific perfdata 
  (without values: same with '_max' suffix) (Multiple options)
  
  =item B<--change-perfdata> B<--extend-perfdata> 
  
  Change or extend perfdata. 
  Syntax: --extend-perfdata=searchlabel,newlabel,target[,[newuom],[min],[max]]
  
  Common examples:
  
  =over 4
  
  Change storage free perfdata in used: --change-perfdata=free,used,invert()
  
  Change storage free perfdata in used: --change-perfdata=used,free,invert()
  
  Scale traffic values automaticaly: --change-perfdata=traffic,,scale(auto)
  
  Scale traffic values in Mbps: --change-perfdata=traffic_in,,scale(Mbps),mbps
  
  Change traffic values in percent: --change-perfdata=traffic_in,,percent()
  
  =back
  
  =item B<--extend-perfdata-group> 
  
  Extend perfdata from multiple perfdatas (methods in target are: min, max, average, sum)
  Syntax: --extend-perfdata-group=searchlabel,newlabel,target[,newuom]
  
  Common examples:
  
  =over 4
  
  Sum wrong packets from all interfaces (with interface need  --units-errors=absolute): --extend-perfdata-group=',packets_wrong,sum(packets_(discard|error)_(in|out))'
  
  Sum traffic by interface: --extend-perfdata-group='traffic_in_(.*),traffic_$1,sum(traffic_(in|out)_$1)'
  
  =back
  
  =item B<--change-short-output>
  
  Change short output display. --change-short-output=pattern~replace~modifier
  
  =item B<--range-perfdata>
  
  Change perfdata range thresholds display: 
  1 = start value equals to '0' is removed, 2 = threshold range is not display.
  
  =item B<--filter-uom>
  
  Filter UOM that match the regexp.
  
  =item B<--opt-exit>
  
  Optional exit code for an execution error (i.e. wrong option provided,
  SSH connection refused, timeout, etc)
  (Default: unknown).
  
  =item B<--output-xml>
  
  Display output in XML format.
  
  =item B<--output-json>
  
  Display output in JSON format.
  
  =item B<--output-openmetrics>
  
  Display metrics in OpenMetrics format.
  
  =item B<--output-file>
  
  Write output in file (can be used with json and xml options)
  
  =item B<--disco-format>
  
  Display discovery arguments (if the mode manages it).
  
  =item B<--disco-show>
  
  Display discovery values (if the mode manages it).
  
  =item B<--float-precision>
  
  Set the float precision for thresholds (Default: 8).
  
  =head1 DESCRIPTION
  
  B<output>.
  
  =cut
CENTREON_PLUGINS_OUTPUT

$fatpacked{"centreon/plugins/perfdata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PERFDATA';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::perfdata;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{output} = $options{output};
      # Typical Nagios Perfdata 'with ~ @ ..'
      $self->{threshold_label} = {};
      $self->{float_precision} = defined($self->{output}->{option_results}->{float_precision}) && $self->{output}->{option_results}->{float_precision} =~ /\d+/ ?  
          int($self->{output}->{option_results}->{float_precision}) : 8;
  
      return $self;
  }
  
  sub get_perfdata_for_output {
      my ($self, %options) = @_;
      # $options{label} : threshold label
      # $options{total} : percent threshold to transform in global
      # $options{cast_int} : cast absolute to int
      # $options{op} : operator to apply to start/end value (uses with 'value'})
      # $options{value} : value to apply with 'op' option
      
      if (!defined($self->{threshold_label}->{$options{label}}->{value}) || $self->{threshold_label}->{$options{label}}->{value} eq '') {
          return '';
      }
      
      my %perf_value = %{$self->{threshold_label}->{$options{label}}};
      
      if (defined($options{op}) && defined($options{value})) {
          eval "\$perf_value{start} = \$perf_value{start} $options{op} \$options{value}" if ($perf_value{infinite_neg} == 0);
          eval "\$perf_value{end} = \$perf_value{end} $options{op} \$options{value}" if ($perf_value{infinite_pos} == 0);
      }
      if (defined($options{total})) {
          $perf_value{start} = $perf_value{start} * $options{total} / 100 if ($perf_value{infinite_neg} == 0);
          $perf_value{end} = $perf_value{end} * $options{total} / 100 if ($perf_value{infinite_pos} == 0);
          $perf_value{start} = sprintf("%.2f", $perf_value{start}) if ($perf_value{infinite_neg} == 0 && (!defined($options{cast_int}) || $options{cast_int} != 1));
          $perf_value{end} = sprintf("%.2f", $perf_value{end}) if ($perf_value{infinite_pos} == 0 && (!defined($options{cast_int}) || $options{cast_int} != 1));
      }
      
      $perf_value{start} = int($perf_value{start}) if ($perf_value{infinite_neg} == 0 && defined($options{cast_int}) && $options{cast_int} == 1);
      $perf_value{end} = int($perf_value{end}) if ($perf_value{infinite_pos} == 0 && defined($options{cast_int}) && $options{cast_int} == 1);
      
      my $perf_output = ($perf_value{arobase} == 1 ? '@' : '') . 
                        (($perf_value{infinite_neg} == 0) ? $perf_value{start} : '~') . 
                        ':' . 
                        (($perf_value{infinite_pos} == 0) ? $perf_value{end} : '');
  
      return $perf_output;
  }
  
  sub threshold_validate {
      my ($self, %options) = @_;
      # $options{label} : threshold label
      # $options{value} : threshold value
  
      my $status = 1;
      $self->{threshold_label}->{$options{label}} = { value => $options{value}, start => undef, end => undef, arobase => undef, infinite_neg => undef, infinite_pos => undef };
      if (!defined($options{value}) || $options{value} eq '') {
          return $status;
      }
  
      ($status, my $result_perf) = 
          centreon::plugins::misc::parse_threshold(threshold => $options{value});
      $self->{threshold_label}->{$options{label}} = { %{$self->{threshold_label}->{$options{label}}}, %$result_perf };
      
      $self->{threshold_label}->{$options{label}}->{start_precision} = $self->{threshold_label}->{$options{label}}->{start};
      if ($self->{threshold_label}->{$options{label}}->{start} =~ /[.,]/) {
          $self->{threshold_label}->{$options{label}}->{start_precision} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $self->{threshold_label}->{$options{label}}->{start});
      }
      
      $self->{threshold_label}->{$options{label}}->{end_precision} = $self->{threshold_label}->{$options{label}}->{end};
      if ($self->{threshold_label}->{$options{label}}->{end} =~ /[.,]/) {
          $self->{threshold_label}->{$options{label}}->{end_precision} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $self->{threshold_label}->{$options{label}}->{end});
      }
      
      return $status;
  }
  
  sub threshold_check {
      my ($self, %options) = @_;
      # Can check multiple threshold. First match: out. Order is important
      # options{value}: value to compare
      # options{threshold}: ref to an array (example: [ {label => 'warning', exit_litteral => 'warning' }, {label => 'critical', exit_litteral => 'critical'} ]
      if ($options{value} =~ /[.,]/) {
          $options{value} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $options{value});
      }
      
      foreach (@{$options{threshold}}) {
          next if (!defined($self->{threshold_label}->{$_->{label}}));
          next if (!defined($self->{threshold_label}->{$_->{label}}->{value}) || $self->{threshold_label}->{$_->{label}}->{value} eq '');
          if ($self->{threshold_label}->{$_->{label}}->{arobase} == 0 && ($options{value} < $self->{threshold_label}->{$_->{label}}->{start_precision} || $options{value} > $self->{threshold_label}->{$_->{label}}->{end_precision})) {
              return $_->{exit_litteral};
          } elsif ($self->{threshold_label}->{$_->{label}}->{arobase}  == 1 && ($options{value} >= $self->{threshold_label}->{$_->{label}}->{start_precision} && $options{value} <= $self->{threshold_label}->{$_->{label}}->{end_precision})) {
              return $_->{exit_litteral};
          }
      }
  
      return 'ok';
  }
  
  sub trim {
      my ($self, $value) = @_;
      
      $value =~ s/^[ \t]+//;
      $value =~ s/[ \t]+$//;
      return $value;
  }
  
  sub change_bytes {
      my ($self, %options) = @_;
  
      my $value = $options{value};
      my $divide = defined($options{network}) ? 1000 : 1024;
      my @units = ('K', 'M', 'G', 'T');
      my $unit = '';
      my $sign = '';
  
      $sign = '-' if ($value != abs($value));
      $value = abs($value);
      
      for (my $i = 0; $i < scalar(@units); $i++) {
          last if (($value / $divide) < 1);
          $unit = $units[$i];
          $value = $value / $divide;
      }
  
      return (sprintf('%.2f', $sign . $value), $unit . (defined($options{network}) ? 'b' : 'B'));
  }
  
  1;
  
  
  =head1 NAME
  
  Perfdata class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 DESCRIPTION
  
  B<perfdata>.
  
  =cut
CENTREON_PLUGINS_PERFDATA

$fatpacked{"centreon/plugins/script.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SCRIPT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::script;
  
  use strict;
  use warnings;
  use centreon::plugins::output;
  use centreon::plugins::misc;
  use FindBin;
  use Pod::Usage;
  use Pod::Find qw(pod_where);
  
  my %handlers = (DIE => {});
  
  my $global_version = '20190704 (727d0077)';
  my $alternative_fatpacker = 1;
  
  sub new {
      my ($class) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{options} = undef;
      $self->{plugin} = undef;
      $self->{help} = undef;
  
      # Avoid to destroy because it keeps a ref on the object. 
      # A problem if we execute it multiple times in the same perl execution
      # Use prepare_destroy
      $self->set_signal_handlers;
      return $self;
  }
  
  sub prepare_destroy {
      my ($self) = @_;
  
      delete $handlers{DIE}->{$self};
  }
  
  sub set_signal_handlers {
      my $self = shift;
  
      $SIG{__DIE__} = \&class_handle_DIE;
      $handlers{DIE}->{$self} = sub { $self->handle_DIE($_[0]) };
  }
  
  sub class_handle_DIE {
      my ($msg) = @_;
  
      foreach (keys %{$handlers{DIE}}) {
          &{$handlers{DIE}->{$_}}($msg);
      }
  }
  
  sub handle_DIE {
      my ($self, $msg) = @_;
  
      return unless defined $^S and $^S == 0; # Ignore errors in eval
      $self->{output}->add_option_msg(short_msg => $msg);
      $self->{output}->die_exit();
  }
  
  sub get_global_version {
      return $global_version;
  }
  
  sub get_plugin {
      my ($self) = @_;
      
      ######
      # Need to load global 'Output' and 'Options'
      ######
      if ($alternative_fatpacker == 0) {
          require centreon::plugins::options;
          $self->{options} = centreon::plugins::options->new();
      } else {
          require centreon::plugins::alternative::FatPackerOptions;
          $self->{options} = centreon::plugins::alternative::FatPackerOptions->new();
      }
      $self->{output} = centreon::plugins::output->new(options => $self->{options});
      $self->{options}->set_output(output => $self->{output});
  
      $self->{options}->add_options(arguments => {
          'plugin:s'          => { name => 'plugin' },
          'list-plugin'       => { name => 'list_plugin' }, 
          'help'              => { name => 'help' },
          'ignore-warn-msg'   => { name => 'ignore_warn_msg' },
          'version'           => { name => 'version' },
          'runas:s'           => { name => 'runas' },
          'environment:s%'    => { name => 'environment' },
          'convert-args:s'    => { name => 'convert_args' },
      });
  
      $self->{options}->parse_options();
  
      $self->{plugin} = $self->{options}->get_option(argument => 'plugin' );
      $self->{list_plugin} = $self->{options}->get_option(argument => 'list_plugin' );
      $self->{help} = $self->{options}->get_option(argument => 'help' );
      $self->{version} = $self->{options}->get_option(argument => 'version' );
      $self->{runas} = $self->{options}->get_option(argument => 'runas' );
      $self->{environment} = $self->{options}->get_option(argument => 'environment' );
      $self->{ignore_warn_msg} = $self->{options}->get_option(argument => 'ignore_warn_msg' );
      $self->{convert_args} = $self->{options}->get_option(argument => 'convert_args' );
  
      $self->{output}->plugin(name => $self->{plugin});
      $self->{output}->check_options(option_results => $self->{options}->get_options());
  
      $self->{options}->clean();
  }
  
  sub convert_args {
      my ($self) = @_;
      
      if ($self->{convert_args} =~ /^(.+?),(.*)/) {
          my ($search, $replace) = ($1, $2);
          for (my $i = 0; $i <= $#ARGV; $i++) {
              eval "\$ARGV[\$i] =~ s/$search/$replace/g";
          }
      }
  }
  
  sub display_local_help {
      my ($self) = @_;
  
      my $stdout;
      if ($self->{help}) {
          local *STDOUT;
          open STDOUT, '>', \$stdout;
          
          if ($alternative_fatpacker == 0) {
              pod2usage(-exitval => 'NOEXIT', -input => pod_where({-inc => 1}, __PACKAGE__));
          } else {
              my $pp = __PACKAGE__ . '.pm';
              $pp =~ s{::}{/}g;
              my $content_class = $INC{$pp}->{$pp};
              open my $str_fh, '<', \$content_class;
              pod2usage(-exitval => 'NOEXIT', -input => $str_fh);
              close $str_fh;
          }
      }
      
      $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
  }
  
  sub check_directory {
      my ($self, $directory) = @_;
      
      opendir(my $dh, $directory) || return ;
      while (my $filename = readdir $dh) {
          $self->check_directory($directory . '/' . $filename) if ($filename !~ /^\./ && -d $directory . '/' . $filename);
          if ($filename eq 'plugin.pm') {
              my $stdout = '';
              
              {
                  local *STDOUT;
                  open STDOUT, '>', \$stdout;
                  pod2usage(-exitval => 'NOEXIT', -input => $directory . "/" . $filename,
                            -verbose => 99, 
                            -sections => "PLUGIN DESCRIPTION");
              }
              $self->{plugins_result}->{$directory . "/" . $filename} = $stdout;
          }
      }
      closedir $dh;
  }
  
  sub fatpacker_find_plugin {
      my ($self) = @_;
      
      my $plugins = [];
      foreach (@INC) {
          next if (ref($_) !~ /FatPacked/);
          foreach my $name (keys %$_) {
              if ($name =~ /plugin.pm$/) {
                  push @$plugins, $name;
              }
          }
      }
      
      return $plugins;
  }
  
  sub check_plugin_option {
      my ($self) = @_;
      
      if (defined($self->{version})) {
          $self->{output}->add_option_msg(short_msg => 'Global Version: ' . $global_version);
          $self->{output}->option_exit(nolabel => 1);
      }
      
      my $no_plugin = 1;
      if ($alternative_fatpacker == 1) {
          my $integrated_plugins = $self->fatpacker_find_plugin();
          if (scalar(@$integrated_plugins) == 1) {
              $self->{plugin} = $integrated_plugins->[0];
              $no_plugin = 0;
          }
      }
      
      if ($no_plugin == 1) {
          $self->{output}->add_option_msg(short_msg => "Need to specify '--plugin' option.");
          $self->{output}->option_exit();
      }
  }
  
  sub display_list_plugin {
      my ($self) = @_;
      $self->{plugins_result} = {};
      
      if ($alternative_fatpacker == 1) {
          my $integrated_plugins = $self->fatpacker_find_plugin();
          
          foreach my $key (@$integrated_plugins) {
              # Need to load it to get the description
              centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $key, 
                                                     error_msg => 'Cannot load module --plugin.');
                                                 
              my $name = $key;
              $name =~ s/\.pm//g;
              $name =~ s/\//::/g;
              $self->{output}->add_option_msg(long_msg => '-----------------');
              $self->{output}->add_option_msg(long_msg => 'PLUGIN: ' . $name);
              {
                  my $stdout = '';
                  local *STDOUT;
                  open STDOUT, '>', \$stdout;
                  my $content_class = $INC{$key}->{$key};
                  open my $str_fh, '<', \$content_class;
                  pod2usage(-exitval => 'NOEXIT', -input => $str_fh, -verbose => 99, -sections => 'PLUGIN DESCRIPTION');
                  close $str_fh;
                  $self->{output}->add_option_msg(long_msg => $stdout);
              }
          }
          return ;
      }
      
      # Search file 'plugin.pm'
      $self->check_directory($FindBin::Bin);
      foreach my $key (keys %{$self->{plugins_result}}) {
          my $name = $key;
          $name =~ s/^$FindBin::Bin\/(.*)\.pm/$1/;
          $name =~ s/\//::/g;
          $self->{plugins_result}->{$key} =~ s/^Plugin Description/DESCRIPTION/i;
          
          $self->{output}->add_option_msg(long_msg => '-----------------');
          $self->{output}->add_option_msg(long_msg => 'PLUGIN: ' . $name);
          $self->{output}->add_option_msg(long_msg => $self->{plugins_result}->{$key});
      }
  }
  
  sub check_relaunch {
      my $self = shift;
      my $need_restart = 0;
      my $cmd = $FindBin::Bin . "/" . $FindBin::Script;
      my @args = ();
      
      if (defined($self->{environment})) {
          foreach (keys %{$self->{environment}}) {
              if ($_ ne '' && (!defined($ENV{$_}) || $ENV{$_} ne $self->{environment}->{$_})) {
                  $ENV{$_} = $self->{environment}->{$_};
                  $need_restart = 1;
              }
          }
      }
      
      if (defined($self->{runas}) && $self->{runas} ne '') {
          # Check if it's already me and user exist ;)
          my ($name, $passwd, $uid) = getpwnam($self->{runas});
          if (!defined($uid)) {
              $self->{output}->add_option_msg(short_msg => "Runas user '" . $self->{runas} . "' not exist.");
              $self->{output}->option_exit();
          }
          if ($uid != $>) {
              if ($> == 0) {
                  unshift @args, "-s", "/bin/bash", "-l", $self->{runas}, "-c", join(" ", $cmd, "--plugin=" . $self->{plugin}, @ARGV);
                  $cmd = "su";
              } else {
                  unshift @args, "-S", "-u", $self->{runas}, $cmd, "--plugin=" . $self->{plugin}, @ARGV;
                  $cmd = "sudo";
              }
              $need_restart = 1;
          }
      }
  
      if ($need_restart == 1) {
          if (scalar(@args) <= 0) {
              unshift @args, @ARGV, '--plugin=' . $self->{plugin}
          }
  
          my ($lerror, $stdout, $exit_code) = centreon::plugins::misc::backtick(
              command => $cmd,
              arguments => [@args],
              timeout => 30,
              wait_exit => 1
          );
  
          if ($exit_code <= -1000) {
              if ($exit_code == -1000) {
                  $self->{output}->output_add(severity => 'UNKNOWN', 
                                              short_msg => $stdout);
              }
              $self->{output}->display();
              $self->{output}->exit();
          }
          print $stdout;
          # We put unknown
          if (!($exit_code >= 0 && $exit_code <= 4)) {
              exit 3;
          }
          exit $exit_code;
      }
  }
  
  sub run {
      my ($self) = @_;
  
      $self->get_plugin();
  
      if (defined($self->{help}) && !defined($self->{plugin})) {
          $self->display_local_help();
          $self->{output}->option_exit();
      }
      if (defined($self->{list_plugin})) {
          $self->display_list_plugin();
          $self->{output}->option_exit();
      }
      $self->check_plugin_option() if (!defined($self->{plugin}) || $self->{plugin} eq '');
      if (defined($self->{ignore_warn_msg})) {
          $SIG{__WARN__} = sub {};
      }
      $self->convert_args() if (defined($self->{convert_args}));
  
      $self->check_relaunch();
      
      (undef, $self->{plugin}) = 
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{plugin}, 
                                                 error_msg => 'Cannot load module --plugin.');
      my $plugin = $self->{plugin}->new(options => $self->{options}, output => $self->{output});
      $plugin->init(help => $self->{help},
                    version => $self->{version});
      $plugin->run();
  }
  
  1;
  
  
  =head1 NAME
  
  centreon_plugins.pl - main program to call Centreon plugins.
  
  =head1 SYNOPSIS
  
  centreon_plugins.pl [options]
  
  =head1 OPTIONS
  
  =over 8
  
  =item B<--plugin>
  
  Specify the path to the plugin.
  
  =item B<--list-plugin>
  
  Print available plugins.
  
  =item B<--version>
  
  Print global version.
  
  =item B<--help>
  
  Print a brief help message and exits.
  
  =item B<--ignore-warn-msg>
  
  Perl warn messages are ignored (not displayed).
  
  =item B<--runas>
  
  Run the script as a different user (prefer to use directly the good user).
  
  =item B<--environment>
  
  Set environment variables for the script (prefer to set it before running it for better performance).
  
  =item B<--convert-args>
  
  Change strings of arguments. Useful to use '!' in nrpe protocol.
  Example: --convert-args='##,\x21'
  
  =back
  
  =head1 DESCRIPTION
  
  B<centreon_plugins.pl> .
  
  =cut
CENTREON_PLUGINS_SCRIPT

$fatpacked{"centreon/plugins/script_snmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SCRIPT_SNMP';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::script_snmp;
  
  use strict;
  use warnings;
  use centreon::plugins::snmp;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      # $options{package} = parent package caller
      # $options{options} = options object
      # $options{output} = output object
      $self->{options} = $options{options};
      $self->{output} = $options{output};
      
      $self->{options}->add_options(
          arguments => {
              'mode:s'         => { name => 'mode_name' },
              'dyn-mode:s'     => { name => 'dynmode_name' },
              'list-mode'      => { name => 'list_mode' },
              'mode-version:s' => { name => 'mode_version' },
              'sanity-options' => { name => 'sanity_options' }, # keep it for 6 month before remove it
              'pass-manager:s' => { name => 'pass_manager' },
          }
      );
      $self->{version} = '1.0';
      %{$self->{modes}} = ();
      $self->{default} = undef;
      
      $self->{options}->parse_options();
      $self->{option_results} = $self->{options}->get_options();
      foreach (keys %{$self->{option_results}}) {
          $self->{$_} = $self->{option_results}->{$_};
      }
      $self->{options}->clean();
  
      $self->{options}->add_help(package => $options{package}, sections => 'PLUGIN DESCRIPTION');
      $self->{options}->add_help(package => __PACKAGE__, sections => 'GLOBAL OPTIONS');
      $self->{output}->mode(name => $self->{mode_name});
  
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      # $options{version} = string version
      # $options{help} = string help
  
      if (defined($options{help}) && !defined($self->{mode_name}) && !defined($self->{dynmode_name})) {
          $self->{options}->display_help();
          $self->{output}->option_exit();
      }
      if (defined($options{version}) && !defined($self->{mode_name}) && !defined($self->{dynmode_name})) {
          $self->version();
      }
      if (defined($self->{list_mode})) {
          $self->list_mode();
      }
      $self->{options}->set_sanity();
  
      # Output HELP
      $self->{options}->add_help(package => 'centreon::plugins::output', sections => 'OUTPUT OPTIONS');
  
      $self->load_password_mgr();
  
      # SNMP
      $self->{snmp} = centreon::plugins::snmp->new(options => $self->{options}, output => $self->{output});
  
      # Load mode
      if (defined($self->{mode_name}) && $self->{mode_name} ne '') {
          $self->is_mode(mode => $self->{mode_name});
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{modes}{$self->{mode_name}}, 
                                                 error_msg => "Cannot load module --mode.");
          $self->{mode} = $self->{modes}{$self->{mode_name}}->new(options => $self->{options}, output => $self->{output}, mode => $self->{mode_name});
      } elsif (defined($self->{dynmode_name}) && $self->{dynmode_name} ne '') {
          (undef, $self->{dynmode_name}) = centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{dynmode_name}, 
                                                                                  error_msg => "Cannot load module --dyn-mode.");
          $self->{mode} = $self->{dynmode_name}->new(options => $self->{options}, output => $self->{output}, mode => $self->{dynmode_name});
      } else {
          $self->{output}->add_option_msg(short_msg => "Need to specify '--mode' or '--dyn-mode' option.");
          $self->{output}->option_exit();
      }
  
      if (defined($options{help})) {
          if (defined($self->{mode_name}) && $self->{mode_name} ne '') {
              $self->{options}->add_help(package => $self->{modes}{$self->{mode_name}}, sections => 'MODE');
          } else {
              $self->{options}->add_help(package => $self->{dynmode_name}, sections => 'MODE');
          }
          $self->{options}->display_help();
          $self->{output}->option_exit();
      }
      if (defined($options{version})) {
          $self->{mode}->version();
          $self->{output}->option_exit(nolabel => 1);
      }
      if (centreon::plugins::misc::minimal_version($self->{mode}->{version}, $self->{mode_version}) == 0) {
          $self->{output}->add_option_msg(short_msg => "Not good version for plugin mode. Excepted at least: " . $self->{mode_version} . ". Get: ".  $self->{mode}->{version});
          $self->{output}->option_exit();
      }
      
      $self->{options}->parse_options();
      $self->{option_results} = $self->{options}->get_options();
      
      $self->{pass_mgr}->manage_options(option_results => $self->{option_results}) if (defined($self->{pass_mgr}));
      $self->{snmp}->check_options(option_results => $self->{option_results});
      $self->{mode}->check_options(option_results => $self->{option_results}, default => $self->{default}, snmp => $self->{snmp});
  }
  
  sub load_password_mgr {
      my ($self, %options) = @_;
      
      return if (!defined($self->{option_results}->{pass_manager}) || $self->{option_results}->{pass_manager} eq '');
  
      (undef, my $pass_mgr_name) = centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => "centreon::plugins::passwordmgr::" . $self->{option_results}->{pass_manager}, 
          error_msg => "Cannot load module 'centreon::plugins::passwordmgr::" . $self->{option_results}->{pass_manager} . "'"
      );
      $self->{pass_mgr} = $pass_mgr_name->new(options => $self->{options}, output => $self->{output});
  }
  
  sub run {
      my ($self) = @_;
  
      if ($self->{output}->is_disco_format()) {
          $self->{mode}->disco_format();
          $self->{output}->display_disco_format();
          $self->{output}->exit(exit_litteral => 'ok');
      }
  
      $self->{snmp}->connect();
      if ($self->{output}->is_disco_show()) {
          $self->{mode}->disco_show(snmp => $self->{snmp});
          $self->{output}->display_disco_show();
          $self->{output}->exit(exit_litteral => 'ok');
      } else {
          $self->{mode}->run(snmp => $self->{snmp});
      }
  }
  
  sub is_mode {
      my ($self, %options) = @_;
      
      # $options->{mode} = mode
      if (!defined($self->{modes}{$options{mode}})) {
          $self->{output}->add_option_msg(short_msg => "mode '" . $options{mode} . "' doesn't exist (use --list-mode option to show available modes).");
          $self->{output}->option_exit();
      }
  }
  
  sub version {
      my ($self) = @_;    
      $self->{output}->add_option_msg(short_msg => "Plugin Version: " . $self->{version});
      $self->{output}->option_exit(nolabel => 1);
  }
  
  sub list_mode {
      my ($self) = @_;
      $self->{options}->display_help();
      
      $self->{output}->add_option_msg(long_msg => "Modes Available:");
      foreach (sort keys %{$self->{modes}}) {
          $self->{output}->add_option_msg(long_msg => "   " . $_);
      }
      $self->{output}->option_exit(nolabel => 1);
  }
  
  1;
  
  
  =head1 NAME
  
  -
  
  =head1 SYNOPSIS
  
  -
  
  =head1 GLOBAL OPTIONS
  
  =over 8
  
  =item B<--mode>
  
  Choose a mode.
  
  =item B<--dyn-mode>
  
  Specify a mode with the path (separated by '::').
  
  =item B<--list-mode>
  
  List available modes.
  
  =item B<--mode-version>
  
  Check minimal version of mode. If not, unknown error.
  
  =item B<--version>
  
  Display plugin version.
  
  =item B<--pass-manager>
  
  Use a password manager.
  
  =back
  
  =head1 DESCRIPTION
  
  B<>.
  
  =cut
CENTREON_PLUGINS_SCRIPT_SNMP

$fatpacked{"centreon/plugins/snmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SNMP';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::snmp;
  
  use strict;
  use warnings;
  use SNMP;
  use Socket;
  use POSIX;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      # $options{options} = options object
      # $options{output} = output object
      # $options{exit_value} = integer
      
      if (!defined($options{output})) {
          print "Class SNMP: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class SNMP: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      if (!defined($options{noptions})) {
          $options{options}->add_options(arguments => {
              "hostname|host:s"           => { name => 'host' },
              "snmp-community:s"          => { name => 'snmp_community', default => 'public' },
              "snmp-version:s"            => { name => 'snmp_version', default => 1 },
              "snmp-port:s"               => { name => 'snmp_port', default => 161 },
              "snmp-timeout:s"            => { name => 'snmp_timeout', default => 1 },
              "snmp-retries:s"            => { name => 'snmp_retries', default => 5 },
              "maxrepetitions:s"          => { name => 'maxrepetitions', default => 50 },
              "subsetleef:s"              => { name => 'subsetleef', default => 50 },
              "subsettable:s"             => { name => 'subsettable', default => 100 },
              "snmp-autoreduce:s"         => { name => 'snmp_autoreduce' },
              "snmp-force-getnext"        => { name => 'snmp_force_getnext' },
              "snmp-username:s"           => { name => 'snmp_security_name' },
              "authpassphrase:s"          => { name => 'snmp_auth_passphrase' },
              "authprotocol:s"            => { name => 'snmp_auth_protocol' },
              "privpassphrase:s"          => { name => 'snmp_priv_passphrase' },
              "privprotocol:s"            => { name => 'snmp_priv_protocol' },
              "contextname:s"             => { name => 'snmp_context_name' },
              "contextengineid:s"         => { name => 'snmp_context_engine_id' },
              "securityengineid:s"        => { name => 'snmp_security_engine_id' },
              "snmp-errors-exit:s"        => { name => 'snmp_errors_exit', default => 'unknown' },
          });
      }
      $options{options}->add_help(package => __PACKAGE__, sections => 'SNMP OPTIONS');
  
      #####
      $self->{session} = undef;
      $self->{output} = $options{output};
      $self->{snmp_params} = {};
      
      # Dont load MIB
      $SNMP::auto_init_mib = 0;
      $ENV{MIBS} = '';
      # For snmpv v1 - get request retries when you have "NoSuchName"
      $self->{RetryNoSuch} = 1;
      # Dont try to translate OID (we keep value)
      $self->{UseNumeric} = 1;
      
      $self->{error_msg} = undef;
      $self->{error_status} = 0;
      
      return $self;
  }
  
  sub connect {
      my ($self, %options) = @_;
      
      $self->{snmp_params}->{RetryNoSuch} = $self->{RetryNoSuch};
      $self->{snmp_params}->{UseNumeric} = $self->{UseNumeric};
  
      if (!$self->{output}->is_litteral_status(status => $self->{snmp_errors_exit})) {
          $self->{output}->add_option_msg(short_msg => "Unknown value '" . $self->{snmp_errors_exit}  . "' for --snmp-errors-exit.");
          $self->{output}->option_exit(exit_litteral => 'unknown');
      }
      
      $self->{session} = new SNMP::Session(%{$self->{snmp_params}});
      if (!defined($self->{session})) {
          $self->{output}->add_option_msg(short_msg => 'SNMP Session : unable to create');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
      if ($self->{session}->{ErrorNum}) {
          $self->{output}->add_option_msg(short_msg => 'SNMP Session : ' . $self->{session}->{ErrorStr});
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  }
  
  sub load {
      my ($self, %options) = @_;
      # $options{oids} = ref to array of oids (example: ['.1.2', '.1.2'])
      # $options{instances} = ref to array of oids instances
      # $options{begin}, $args->{end} = integer instance end
      # $options{instance_regexp} = str
      # 3 way to use: with instances, with end, none
      
      if (defined($options{end})) {
          for (my $i = $options{begin}; $i <= $options{end}; $i++) {
              foreach (@{$options{oids}}) {
                  push @{$self->{oids_loaded}}, $_ . "." . $i;
              }
          }
          return ;
      }
      
      if (defined($options{instances})) {
          $options{instance_regexp} = defined($options{instance_regexp}) ? $options{instance_regexp} : '(\d+)$';
          foreach my $instance (@{$options{instances}}) {
              $instance =~ /$options{instance_regexp}/;
              foreach (@{$options{oids}}) {
                  push @{$self->{oids_loaded}}, $_ . "." . $1;
              }
          }
          return ;
      }
      
      push @{$self->{oids_loaded}}, @{$options{oids}};
  }
  
  sub autoreduce_table {
      my ($self, %options) = @_;
      
      return 1 if (defined($self->{snmp_force_getnext}) || $self->is_snmpv1());
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      
      return 1 if (${$options{repeat_count}} == 1);
      ${$options{repeat_count}} = int(${$options{repeat_count}} / $self->{snmp_autoreduce_divisor});
      ${$options{repeat_count}} = 1 if (${$options{repeat_count}} < 1);
      return 0;
  }
  
  sub autoreduce_multiple_table {
      my ($self, %options) = @_;
      
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      return 1 if (${$options{repeat_count}} == 1);
      
      ${$options{repeat_count}} = int(${$options{repeat_count}} / $self->{snmp_autoreduce_divisor});
      $self->{subsettable} = int($self->{subsettable} / $self->{snmp_autoreduce_divisor});
      ${$options{repeat_count}} = 1 if (${$options{repeat_count}} < 1);
      return 0;
  }
  
  sub autoreduce_leef {
      my ($self, %options) = @_;
      
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      
      return 1 if ($self->{subsetleef} == 1);
      $self->{subsetleef} = int($self->{subsetleef} / $self->{snmp_autoreduce_divisor});
      $self->{subsetleef} = 1 if ($self->{subsetleef} < 1);
      
      my $array_ref = [];
      my $subset_current = 0;
      my $subset_construct = [];
      foreach ([@{$options{current}}], @{$self->{array_ref_ar}}) {
          foreach my $entry (@$_) {;
              push @$subset_construct, [$entry->[0], $entry->[1]];
              $subset_current++;
              if ($subset_current == $self->{subsetleef}) {
                  push @$array_ref, \@$subset_construct;
                  $subset_construct = [];
                  $subset_current = 0;
              }
          }
      }
      
      if ($subset_current) {
          push @$array_ref, \@$subset_construct;
      }
  
      $self->{array_ref_ar} = \@$array_ref;
      return 0;
  }
  
  sub get_leef {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{nothing_quit} = integer
      # $options{oids} = ref to array of oids (example: ['.1.2', '.1.2'])
      
      # Returns array
      #    'undef' value for an OID means NoSuchValue
      
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
      
      if (!defined($options{oids})) {
          if ($#{$self->{oids_loaded}} < 0) {
              if ($dont_quit == 1) {
                  $self->set_error(error_status => -1, error_msg => "Need to specify OIDs");
                  return undef;
              }
              $self->{output}->add_option_msg(short_msg => 'Need to specify OIDs');
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
          push @{$options{oids}}, @{$self->{oids_loaded}};
          @{$self->{oids_loaded}} = ();
      }
      
      my $results = {};
      $self->{array_ref_ar} = [];
      my $subset_current = 0;
      my $subset_construct = [];
      foreach my $oid (@{$options{oids}}) {
          # Get last value
          next if ($oid !~ /(.*)\.(\d+)([\.\s]*)$/);
          
          my ($oid, $instance) = ($1, $2);
          $results->{$oid . "." . $instance} = undef;
          push @$subset_construct, [$oid, $instance];
          $subset_current++;
          if ($subset_current == $self->{subsetleef}) {
              push @{$self->{array_ref_ar}}, \@$subset_construct;
              $subset_construct = [];
              $subset_current = 0;
          }
      }
      if ($subset_current) {
          push @{$self->{array_ref_ar}}, \@$subset_construct;
      }
      
      ############################
      # If wrong oid with SNMP v1, packet resent (2 packets more). Not the case with SNMP > 1.
      # Can have "NoSuchName", if nothing works...
      # = v1: wrong oid
      #   bless( [
      #       '.1.3.6.1.2.1.1.3',
      #       '0',
      #       '199720062',
      #       'TICKS'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #       '.1.3.6.1.2.1.1.999',
      #       '0'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #       '.1.3.6.1.2.1.1',
      #       '1000'
      #       ], 'SNMP::Varbind' )
      # > v1: wrong oid
      #   bless( [
      #        '.1.3.6.1.2.1.1.3',
      #        '0',
      #        '199728713',
      #        'TICKS'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #         '.1.3.6.1.2.1.1',
      #         '3',
      #         'NOSUCHINSTANCE',
      #        'TICKS'
      #    ], 'SNMP::Varbind' )
      #   bless( [
      #        '.1.3.6.1.2.1.1.999',
      #        '0',
      #        'NOSUCHOBJECT',
      #        'NOSUCHOBJECT'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #        '.1.3.6.1.2.1.1',
      #        '1000',
      #        'NOSUCHOBJECT',
      #        'NOSUCHOBJECT'
      #       ], 'SNMP::Varbind' )
      ############################
      
      my $total = 0;
      while (my $entry = shift(@{$self->{array_ref_ar}})) {
          my $vb = new SNMP::VarList(@{$entry});
          $self->{session}->get($vb);
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              # -24  Timeout
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. We next.
                  next;
              }
  
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_leef(current => $entry) == 0);
              }
              my $msg = 'SNMP GET Request : ' . $self->{session}->{ErrorStr};    
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
              
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
          
          # Some equipments gives a partial response and no error.
          # We look the last value if it's empty or not
          # In snmpv1 we have the retryNoSuch
          if (((scalar(@$vb) != scalar(@{$entry})) || (scalar(@{@$vb[-1]}) < 3)) && !$self->is_snmpv1()) {
              next if ($self->{snmp_autoreduce} == 1 && $self->autoreduce_leef(current => $entry) == 0);
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => "SNMP partial response. Please try --snmp-autoreduce option");
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
              
              $self->set_error(error_status => -1, error_msg => "SNMP partial response");
              return undef;
          }
  
          foreach my $entry (@$vb) {
              if ($#$entry < 3) {
                  # Can be snmpv1 not find
                  next;
              }
              if (${$entry}[2] eq 'NOSUCHOBJECT' || ${$entry}[2] eq 'NOSUCHINSTANCE') {
                  # Error in snmp > 1
                  next;
              }
              
              $total++;
              $results->{${$entry}[0] . "." . ${$entry}[1]} = ${$entry}[2];
          }
      }
      
      if ($nothing_quit == 1 && $total == 0) {
          $self->{output}->add_option_msg(short_msg => "SNMP GET Request : Cant get a single value.");
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
      
      return $results;
  }
  
  sub multiple_find_bigger {
      my ($self, %options) = @_;
      
      my $getting = {};
      my @values = ();
      foreach my $key (keys %{$options{working_oids}}) {
          push @values, $options{working_oids}->{$key}->{start};
          $getting->{ $options{working_oids}->{$key}->{start} } = $key;
      }
      @values = $self->oid_lex_sort(@values);
      
      return $getting->{pop(@values)};
  }
  
  sub get_multiple_table {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oids} = refs array
      #     [ { oid => 'x.x.x.x', start => '', end => ''}, { oid => 'y.y.y.y', start => '', end => ''} ]
      # $options{return_type} = integer
      
      my ($return_type) = (defined($options{return_type}) && $options{return_type} == 1) ? 1 : 0;
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
      
      my $working_oids = {};
      my $results = {};
      # Check overlap
      foreach my $entry (@{$options{oids}}) {
          # Transform asking
          if ($entry->{oid} !~ /(.*)\.(\d+)([\.\s]*)$/) {
              if ($dont_quit == 1) {
                  $self->set_error(error_status => -1, error_msg => "Method 'get_multiple_table': Wrong OID '" . $entry->{oid} . "'.");
                  return undef;
              }
              $self->{output}->add_option_msg(short_msg => "Method 'get_multiple_table': Wrong OID '" . $entry->{oid} . "'.");
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      
          if (defined($entry->{start})) {
              $working_oids->{$entry->{oid}} = { start => $entry->{start}, end => $entry->{end} }; # last in it
          } else {
              $working_oids->{$entry->{oid}} = { start => $entry->{oid}, end => $entry->{end} };
          }
          
          if ($return_type == 0) {
              $results->{$entry->{oid}} = {};
          }
      }
      
      # we use a medium (UDP have a PDU limit. SNMP protcol cant send multiples for one request)
      # So we need to manage
      # It's for "bulk". We ask 50 next values. If you set 1, it's like a getnext (snmp v1)
      my $repeat_count = 50;
      if (defined($self->{maxrepetitions}) && 
          $self->{maxrepetitions} =~ /^\d+$/) {
          $repeat_count = $self->{maxrepetitions};
      }
          
      # Quit if base not the same or 'ENDOFMIBVIEW' value. Need all oid finish otherwise we continue :)
      while (1) {
          my $current_oids = 0;
          my @bindings = ();
          my @bases = ();
          foreach my $key (keys %{$working_oids}) {
              $working_oids->{$key}->{start} =~ /(.*)\.(\d+)([\.\s]*)$/;
              push @bindings, [$1, $2];
              push @bases, $key;
              
              $current_oids++;
              last if ($current_oids > $self->{subsettable});
          }
          
          # Nothing more to check. We quit
          last if ($current_oids == 0);
          
          my $vb = new SNMP::VarList(@bindings);
          
          if ($self->is_snmpv1() || defined($self->{snmp_force_getnext})) {
              $self->{session}->getnext($vb);
          } else {
              my $current_repeat_count = floor($repeat_count / $current_oids);
              $current_repeat_count = 1 if ($current_repeat_count == 0);
              $self->{session}->getbulk(0, $current_repeat_count, $vb);
          }
          
          # Error
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. Need to find the most up oid ;)
                  my $oid_base = $self->multiple_find_bigger(working_oids => $working_oids);
                  delete $working_oids->{$oid_base};
                  next;
              }
              
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_multiple_table(repeat_count => \$repeat_count) == 0);
              }
              
              my $msg = 'SNMP Table Request : ' . $self->{session}->{ErrorStr};
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
              
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
          
          # Manage
          # step by step: [ 1 => 1, 2 => 1, 3 => 1 ], [ 1 => 2, 2 => 2, 3 => 2 ],...
          
          my $pos = -1;
          foreach my $entry (@$vb) {
              $pos++;
          
              # Already destruct. we continue
              next if (!defined($working_oids->{ $bases[$pos % $current_oids] }));
          
              # ENDOFMIBVIEW is on each iteration. So we need to delete and skip after that
              if (${$entry}[2] eq 'ENDOFMIBVIEW') {
                  delete $working_oids->{ $bases[$pos % $current_oids] };
                  # END mib
                  next;
              }
          
              # Not in same table
              my $complete_oid = ${$entry}[0] . "." . ${$entry}[1];
              my $base = $bases[$pos % $current_oids];
              if ($complete_oid !~ /^$base\./ ||
                  (defined($working_oids->{ $bases[$pos % $current_oids] }->{end}) && 
                   $self->check_oid_up(current => $complete_oid, end => $working_oids->{ $bases[$pos % $current_oids] }->{end}))) {
                  delete $working_oids->{ $bases[$pos % $current_oids] };
                  next;
              }
          
              if ($return_type == 0) {
                  $results->{$bases[$pos % $current_oids]}->{$complete_oid} = ${$entry}[2];
              } else {
                  $results->{$complete_oid} = ${$entry}[2];
              }
  
              $working_oids->{ $bases[$pos % $current_oids] }->{start} = $complete_oid;
          }
          
          # infinite loop. Some equipments it returns nothing!!??
          if ($pos == -1) {
              $self->{output}->add_option_msg(short_msg => "SNMP Table Request: problem to get values (try --snmp-force-getnext option)");
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      }
      
      my $total = 0;
      if ($nothing_quit == 1) {
          if ($return_type == 1) {
              $total = scalar(keys %{$results});
          } else {
              foreach (keys %{$results}) {
                  $total += scalar(keys %{$results->{$_}});
              }
          }
          
          if ($total == 0) {
              $self->{output}->add_option_msg(short_msg => "SNMP Table Request: Cant get a single value.");
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      }
      
      return $results;
  }
  
  sub get_table {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oid} = string (example: '.1.2')
      # $options{start} = string (example: '.1.2')
      # $options{end} = string (example: '.1.2')
      
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
      
      if (defined($options{start})) {
          $options{start} = $self->clean_oid($options{start});
      }
      if (defined($options{end})) {
          $options{end} = $self->clean_oid($options{end});
      }
      
      # we use a medium (UDP have a PDU limit. SNMP protcol cant send multiples for one request)
      # So we need to manage
      # It's for "bulk". We ask 50 next values. If you set 1, it's like a getnext (snmp v1)
      my $repeat_count = 50;
      if (defined($self->{maxrepetitions}) && 
          $self->{maxrepetitions} =~ /^\d+$/) {
          $repeat_count = $self->{maxrepetitions};
      }
      
      # Transform asking
      if ($options{oid} !~ /(.*)\.(\d+)([\.\s]*)$/) {
          if ($dont_quit == 1) {
              $self->set_error(error_status => -1, error_msg => "Method 'get_table': Wrong OID '" . $options{oid} . "'.");
              return undef;
          }
          $self->{output}->add_option_msg(short_msg => "Method 'get_table': Wrong OID '" . $options{oid} . "'.");
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
      
      my $main_indice = $1 . "." . $2;
      my $results = {};
      
      # Quit if base not the same or 'ENDOFMIBVIEW' value
      my $leave = 1;
      my $last_oid;
  
      if (defined($options{start})) {
          $last_oid = $options{start};
      } else {
          $last_oid = $options{oid};
      }
      while ($leave) {
          $last_oid =~ /(.*)\.(\d+)([\.\s]*)$/;
          my $vb = new SNMP::VarList([$1, $2]);
      
          if ($self->is_snmpv1() || defined($self->{snmp_force_getnext})) {
              $self->{session}->getnext($vb);
          } else {
              $self->{session}->getbulk(0, $repeat_count, $vb);
          }
          
          # Error
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              # -24  Timeout
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. We quit.
                  last;
              }
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_table(repeat_count => \$repeat_count) == 0);
              }
              
              my $msg = 'SNMP Table Request : ' . $self->{session}->{ErrorStr};
          
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
              
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
          
          # Manage
          foreach my $entry (@$vb) {
              if (${$entry}[2] eq 'ENDOFMIBVIEW') {
                  # END mib
                  $leave = 0;
                  last;
              }
          
              # Not in same table
              my $complete_oid = ${$entry}[0] . "." . ${$entry}[1];
              if ($complete_oid !~ /^$main_indice\./ ||
                  (defined($options{end}) && $self->check_oid_up(current => $complete_oid, end => $options{end}))) {
                  $leave = 0;
                  last;
              }
          
              $results->{$complete_oid} = ${$entry}[2];
              $last_oid = $complete_oid;
          }
      }
      
      if ($nothing_quit == 1 && scalar(keys %$results) == 0) {
          $self->{output}->add_option_msg(short_msg => "SNMP Table Request: Cant get a single value.");
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
      
      return $results;
  }
  
  sub set {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oids} = ref to hash table
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      $self->set_error();
  
      my $vars = [];
      foreach my $oid (keys %{$options{oids}}) {
          # Get last value
          next if ($oid !~ /(.*)\.(\d+)([\.\s]*)$/);
          
          my $value = $options{oids}->{$oid}->{value};
          my $type = $options{oids}->{$oid}->{type};
          my ($oid, $instance) = ($1, $2);
         
          push @$vars, [$oid, $instance, $value, $type];
      }
      
      $self->{session}->set($vars);
      if ($self->{session}->{ErrorNum}) {
          # 0    noError       Pas d'erreurs.
          # 1    tooBig        Reponse de taille trop grande.
          # 2    noSuchName    Variable inexistante.
      
          my $msg = 'SNMP SET Request : ' . $self->{session}->{ErrorStr};
          if ($dont_quit == 0) {
              $self->{output}->add_option_msg(short_msg => $msg);
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
          
          $self->set_error(error_status => -1, error_msg => $msg);
          return undef;
      }
  
      return 0;
  }
  
  sub is_snmpv1 {
      my ($self) = @_;
      
      if ($self->{snmp_params}->{Version} eq '1') {
          return 1;
      }
      return 0;
  }
  
  sub clean_oid {
      my ($self, $oid) = @_;
      
      $oid =~ s/\.$//;
      $oid =~ s/^(\d)/\.$1/;
      return $oid;
  }
  
  sub check_oid_up {
      my ($self, %options) = @_;
  
      my $current_oid = $options{current};
      my $end_oid = $options{end};
      
      my @current_oid_splitted = split /\./, $current_oid;
      my @end_oid_splitted = split /\./, $end_oid;
      # Skip first value (before first '.' empty)
      for (my $i = 1; $i <= $#current_oid_splitted && $i <= $#end_oid_splitted; $i++) {
          if (int($current_oid_splitted[$i]) > int($end_oid_splitted[$i])) {
              return 1;
          }
      }
      
      return 0;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      # $options{option_results} = ref to options result
      
      if (!defined($options{option_results}->{host})) {
          $self->{output}->add_option_msg(short_msg => "Missing parameter --hostname.");
          $self->{output}->option_exit();
      }
  
      $options{option_results}->{snmp_version} =~ s/^v//;
      if ($options{option_results}->{snmp_version} !~ /1|2c|2|3/) {
          $self->{output}->add_option_msg(short_msg => "Unknown snmp version.");
          $self->{output}->option_exit();
      }
  
      $self->{snmp_force_getnext} = $options{option_results}->{snmp_force_getnext};
      $self->{maxrepetitions} = $options{option_results}->{maxrepetitions};
      $self->{subsetleef} = (defined($options{option_results}->{subsetleef}) && $options{option_results}->{subsetleef} =~ /^[0-9]+$/) ? $options{option_results}->{subsetleef} : 50;
      $self->{subsettable} = (defined($options{option_results}->{subsettable}) && $options{option_results}->{subsettable} =~ /^[0-9]+$/) ? $options{option_results}->{subsettable} : 100;
      $self->{snmp_errors_exit} = $options{option_results}->{snmp_errors_exit};
      $self->{snmp_autoreduce} = 0;
      $self->{snmp_autoreduce_divisor} = 2;
      if (defined($options{option_results}->{snmp_autoreduce})) {
          $self->{snmp_autoreduce} = 1;
          $self->{snmp_autoreduce_divisor} = $1 if ($options{option_results}->{snmp_autoreduce} =~ /(\d+(\.\d+)?)/ && $1 > 1);
      }
  
      %{$self->{snmp_params}} = (DestHost => $options{option_results}->{host},
                                 Community => $options{option_results}->{snmp_community},
                                 Version => $options{option_results}->{snmp_version},
                                 RemotePort => $options{option_results}->{snmp_port},
                                 Retries => 5);
      
      if (defined($options{option_results}->{snmp_timeout}) && $options{option_results}->{snmp_timeout} =~ /^[0-9]+$/) {
          $self->{snmp_params}->{Timeout} = $options{option_results}->{snmp_timeout} * (10**6);
      }
      
      if (defined($options{option_results}->{snmp_retries}) && $options{option_results}->{snmp_retries} =~ /^[0-9]+$/) {
          $self->{snmp_params}->{Retries} = $options{option_results}->{snmp_retries};
      }
  
      if ($options{option_results}->{snmp_version} eq "3") {
  
          $self->{snmp_params}->{Context} = $options{option_results}->{snmp_context_name} if (defined($options{option_results}->{snmp_context_name}));
          $self->{snmp_params}->{ContextEngineId} = $options{option_results}->{snmp_context_engine_id} if (defined($options{option_results}->{snmp_context_engine_id}));
          $self->{snmp_params}->{SecEngineId} = $options{option_results}->{snmp_security_engine_id} if (defined($options{option_results}->{snmp_security_engine_id}));
          $self->{snmp_params}->{SecName} = $options{option_results}->{snmp_security_name} if (defined($options{option_results}->{snmp_security_name}));
          
          # Certificate SNMPv3. Need net-snmp > 5.6
          if ($options{option_results}->{host} =~ /^(dtls|tls|ssh).*:/) {
              $self->{snmp_params}->{OurIdentity} = $options{option_results}->{snmp_our_identity} if (defined($options{option_results}->{snmp_our_identity}));
              $self->{snmp_params}->{TheirIdentity} = $options{option_results}->{snmp_their_identity} if (defined($options{option_results}->{snmp_their_identity}));
              $self->{snmp_params}->{TheirHostname} = $options{option_results}->{snmp_their_hostname} if (defined($options{option_results}->{snmp_their_hostname}));
              $self->{snmp_params}->{TrustCert} = $options{option_results}->{snmp_trust_cert} if (defined($options{option_results}->{snmp_trust_cert}));
              $self->{snmp_params}->{SecLevel} = 'authPriv';
              return ;
          }
          
  
          if (!defined($options{option_results}->{snmp_security_name}) || $options{option_results}->{snmp_security_name} eq '') {
              $self->{output}->add_option_msg(short_msg => "Missing parameter Security Name.");
              $self->{output}->option_exit();
          }
          
          # unauthenticated and unencrypted
          $self->{snmp_params}->{SecLevel} = 'noAuthNoPriv';
          
          my $user_activate = 0;
          if (defined($options{option_results}->{snmp_auth_passphrase}) && $options{option_results}->{snmp_auth_passphrase} ne '') {
              if (!defined($options{option_results}->{snmp_auth_protocol})) {
                  $self->{output}->add_option_msg(short_msg => "Missing parameter authenticate protocol.");
                  $self->{output}->option_exit();
              }
              $options{option_results}->{snmp_auth_protocol} = uc($options{option_results}->{snmp_auth_protocol});
              if ($options{option_results}->{snmp_auth_protocol} ne "MD5" && $options{option_results}->{snmp_auth_protocol} ne "SHA") {
                  $self->{output}->add_option_msg(short_msg => "Wrong authentication protocol. Must be MD5 or SHA.");
                  $self->{output}->option_exit();
              }
              
              $self->{snmp_params}->{SecLevel} = 'authNoPriv';
              $self->{snmp_params}->{AuthProto} = $options{option_results}->{snmp_auth_protocol};
              $self->{snmp_params}->{AuthPass} = $options{option_results}->{snmp_auth_passphrase};
              $user_activate = 1;
          }
  
          if (defined($options{option_results}->{snmp_priv_passphrase}) && $options{option_results}->{snmp_priv_passphrase} ne '') {
              if (!defined($options{option_results}->{snmp_priv_protocol})) {
                  $self->{output}->add_option_msg(short_msg => "Missing parameter privacy protocol.");
                  $self->{output}->option_exit();
              }
              
              $options{option_results}->{snmp_priv_protocol} = uc($options{option_results}->{snmp_priv_protocol});
              if ($options{option_results}->{snmp_priv_protocol} ne 'DES' && $options{option_results}->{snmp_priv_protocol} ne 'AES') {
                  $self->{output}->add_option_msg(short_msg => "Wrong privacy protocol. Must be DES or AES.");
                  $self->{output}->option_exit();
              }
              if ($user_activate == 0) {
                  $self->{output}->add_option_msg(short_msg => "Cannot use snmp v3 privacy option without snmp v3 authentification options.");
                  $self->{output}->option_exit();
              }
              $self->{snmp_params}->{SecLevel} = 'authPriv';
              $self->{snmp_params}->{PrivPass} = $options{option_results}->{snmp_priv_passphrase};
              $self->{snmp_params}->{PrivProto} = $options{option_results}->{snmp_priv_protocol};
          }
      }
  }
  
  sub set_snmp_connect_params {
      my ($self, %options) = @_;
      
      foreach (keys %options) {
          $self->{snmp_params}->{$_} = $options{$_};
      }
  }
  
  sub set_snmp_params {
      my ($self, %options) = @_;
      
      foreach (keys %options) {
          $self->{$_} = $options{$_};
      }
  }
  
  sub set_error {
      my ($self, %options) = @_;
      # $options{error_msg} = string error
      # $options{error_status} = integer status
      
      $self->{error_status} = defined($options{error_status}) ? $options{error_status} : 0;
      $self->{error_msg} = defined($options{error_msg}) ? $options{error_msg} : undef;
  }
  
  sub error_status {
       my ($self) = @_;
      
      return $self->{error_status};
  }
  
  sub error {
      my ($self) = @_;
      
      return $self->{error_msg};
  }
  
  sub get_hostname {
      my ($self) = @_;
  
      my $host = $self->{snmp_params}->{DestHost};
      $host =~ s/.*://;
      return $host;
  }
  
  sub get_port {
      my ($self) = @_;
  
      return $self->{snmp_params}->{RemotePort};
  }
  
  sub map_instance {
      my ($self, %options) = @_;
      
      my $results = {};
      my $instance = '';
      $instance = '.' . $options{instance} if (defined($options{instance}));
      foreach my $name (keys %{$options{mapping}}) {
          my $entry = $options{mapping}->{$name}->{oid} . $instance;
          if (defined($options{results}->{$entry})) {
              $results->{$name} = $options{results}->{$entry};
          } elsif (defined($options{results}->{$options{mapping}->{$name}->{oid}}->{$entry})) {
              $results->{$name} = $options{results}->{$options{mapping}->{$name}->{oid}}->{$entry};
          } elsif (defined($options{mapping}->{$name}->{location}) && 
                  defined($options{results}->{$options{mapping}->{$name}->{location}}->{$entry})) {
              $results->{$name} = $options{results}->{$options{mapping}->{$name}->{location}}->{$entry};
          } else {
              $results->{$name} = defined($options{default}) ? $options{default} : undef;
          }
          
          if (defined($options{mapping}->{$name}->{map})) {
              if (defined($results->{$name})) {
                  $results->{$name} = defined($options{mapping}->{$name}->{map}->{$results->{$name}}) ? $options{mapping}->{$name}->{map}->{$results->{$name}} : (defined($options{default}) ? $options{default} : 'unknown');
              }
          }
      }
      
      return $results;
  }
  
  sub oid_lex_sort {
      my $self = shift;
  
      if (@_ <= 1) {
          return @_;
      }
  
      return map { $_->[0] }
              sort { $a->[1] cmp $b->[1] }
                  map
                  {
                     my $oid = $_;
                     $oid =~ s/^\.//;
                     $oid =~ s/ /\.0/g;
                     [$_, pack 'N*', split m/\./, $oid]
                  } @_;
  }
  
  1;
  
  
  =head1 NAME
  
  SNMP global
  
  =head1 SYNOPSIS
  
  snmp class
  
  =head1 SNMP OPTIONS
  
  =over 8
  
  =item B<--hostname>
  
  Hostname to query (required).
  
  =item B<--snmp-community>
  
  Read community (defaults to public).
  
  =item B<--snmp-version>
  
  Version: 1 for SNMP v1 (default), 2 for SNMP v2c, 3 for SNMP v3.
  
  =item B<--snmp-port>
  
  Port (default: 161).
  
  =item B<--snmp-timeout>
  
  Timeout in secondes (default: 1) before retries.
  
  =item B<--snmp-retries>
  
  Set the number of retries (default: 5) before failure.
  
  =item B<--maxrepetitions>
  
  Max repetitions value (default: 50) (only for SNMP v2 and v3).
  
  =item B<--subsetleef>
  
  How many oid values per SNMP request (default: 50) (for get_leef method. Be cautious whe you set it. Prefer to let the default value).
  
  =item B<--snmp-autoreduce>
   
  Auto reduce SNMP request size in case of SNMP errors (By default, the divisor is 2).
  
  =item B<--snmp-force-getnext>
  
  Use snmp getnext function (even in snmp v2c and v3).
  
  =item B<--snmp-username>
  
  Security name (only for SNMP v3).
  
  =item B<--authpassphrase>
  
  Authentication protocol pass phrase.
  
  =item B<--authprotocol>
  
  Authentication protocol (MD5|SHA)
  
  =item B<--privpassphrase>
  
  Privacy protocol pass phrase
  
  =item B<--privprotocol>
  
  Privacy protocol (DES|AES)
  
  =item B<--contextname>
  
  Context name
  
  =item B<--contextengineid>
  
  Context engine ID
  
  =item B<--securityengineid>
  
  Security engine ID
  
  =item B<--snmp-errors-exit>
  
  Exit code for SNMP Errors (default: unknown)
  
  =back
  
  =head1 DESCRIPTION
  
  B<snmp>.
  
  =cut
CENTREON_PLUGINS_SNMP

$fatpacked{"centreon/plugins/statefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_STATEFILE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::statefile;
  
  use strict;
  use warnings;
  use Data::Dumper;
  use vars qw($datas);
  use centreon::plugins::misc;
  
  my $default_dir = '/var/lib/centreon/centplugins';
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (defined($options{options})) {
          $options{options}->add_options(arguments => {
              'memcached:s'           => { name => 'memcached' },
              'redis-server:s'        => { name => 'redis_server' },
              'redis-attribute:s%'    => { name => 'redis_attribute' },
              'redis-db:s'            => { name => 'redis_db' },
              'memexpiration:s'       => { name => 'memexpiration', default => 86400 },
              'statefile-dir:s'       => { name => 'statefile_dir', default => $default_dir },
              'statefile-suffix:s'    => { name => 'statefile_suffix', default => '' },
              'statefile-concat-cwd'  => { name => 'statefile_concat_cwd' },
              'statefile-storable'    => { name => 'statefile_storable' },
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'RETENTION OPTIONS', once => 1);
      }
      
      $self->{error} = 0;
      $self->{output} = $options{output};
      $self->{datas} = {};
      $self->{storable} = 0;
      $self->{memcached_ok} = 0;
      $self->{memcached} = undef;
      
      $self->{statefile_dir} = undef;
      $self->{statefile_suffix} = undef;
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      if (defined($options{option_results}) && defined($options{option_results}->{memcached})) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Memcached::libmemcached',
                                                 error_msg => "Cannot load module 'Memcached::libmemcached'.");
          $self->{memcached} = Memcached::libmemcached->new();
          Memcached::libmemcached::memcached_server_add($self->{memcached}, $options{option_results}->{memcached});
      }
      
      # Check redis
      if (defined($options{option_results}->{redis_server})) {
          $self->{redis_attributes} = '';
          if (defined($options{option_results}->{redis_attribute})) {
              foreach (keys %{$options{option_results}->{redis_attribute}}) {
                  $self->{redis_attributes} .= "$_ => " . $options{option_results}->{redis_attribute}->{$_} . ', ';
              }
          }
          
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Redis',
                                                 error_msg => "Cannot load module 'Redis'.");
          eval {
              $self->{redis_cnx} = Redis->new(server => $options{option_results}->{redis_server}, 
                                              eval $self->{redis_attributes});
              if (defined($self->{redis_cnx}) && 
                  defined($options{option_results}->{redis_db}) &&
                  $options{option_results}->{redis_db} ne ''
                  ) {
                  $self->{redis_cnx}->select($options{option_results}->{redis_db});
              }
          };
      }
      
      $self->{statefile_dir} = $options{option_results}->{statefile_dir};
      if ($self->{statefile_dir} ne $default_dir && defined($options{option_results}->{statefile_concat_cwd})) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Cwd',
                                                 error_msg => "Cannot load module 'Cwd'.");
          $self->{statefile_dir} = Cwd::cwd() . '/' . $self->{statefile_dir};
      }
      if (defined($options{option_results}->{statefile_storable})) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Storable',
                                                 error_msg => "Cannot load module 'Storable'.");
          $self->{storable} = 1;
      }
      $self->{statefile_suffix} = $options{option_results}->{statefile_suffix};
      $self->{memexpiration} = $options{option_results}->{memexpiration};
  }
  
  sub error {
      my ($self) = shift;
       
      if (@_) {
          $self->{error} = $_[0];
      }
      return $self->{error};
  }
  
  sub read {
      my ($self, %options) = @_;
      $self->{statefile_suffix} = defined($options{statefile_suffix}) ? $options{statefile_suffix} : $self->{statefile_suffix};
      $self->{statefile_dir} = defined($options{statefile_dir}) ? $options{statefile_dir} : $self->{statefile_dir};
      $self->{statefile} = defined($options{statefile}) ? $options{statefile} . $self->{statefile_suffix} : 
                              $self->{statefile};
      $self->{no_quit} = defined($options{no_quit}) && $options{no_quit} == 1 ? 1 : 0;
  
      if (defined($self->{memcached})) {
          # if "SUCCESS" or "NOT FOUND" is ok. Other with use the file
          my $val = Memcached::libmemcached::memcached_get($self->{memcached}, $self->{statefile_dir} . "/" . $self->{statefile});
          if (defined($self->{memcached}->errstr) && $self->{memcached}->errstr =~ /^SUCCESS|NOT FOUND$/i) {
              $self->{memcached_ok} = 1;
              if (defined($val)) {
                  eval( $val );
                  $self->{datas} = $datas;
                  $datas = {};
                  return 1;
              }
              return 0;
          }
      }
      
      if (defined($self->{redis_cnx})) {
          my $val = $self->{redis_cnx}->get($self->{statefile_dir} . "/" . $self->{statefile});
          if (defined($val)) {
              eval($val);
              $self->{datas} = $datas;
              $datas = {};
              return 1;
          }
          
          return 0;
      }
      
      if (! -e $self->{statefile_dir} . '/' . $self->{statefile}) {
          if (! -w $self->{statefile_dir} || ! -x $self->{statefile_dir}) {
              $self->error(1);
              $self->{output}->add_option_msg(short_msg =>  "Cannot write statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'. Need write/exec permissions on directory.");
              if ($self->{no_quit} == 0) {
                  $self->{output}->option_exit();
              }
          }
          return 0;
      } elsif (! -w $self->{statefile_dir} . '/' . $self->{statefile}) {
          $self->error(1);
          $self->{output}->add_option_msg(short_msg => "Cannot write statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'. Need write permissions on file.");
          if ($self->{no_quit} == 0) {
              $self->{output}->option_exit();
          }
          return 1;
      } elsif (! -s $self->{statefile_dir} . '/' . $self->{statefile}) {
          # Empty file. Not a problem. Maybe plugin not manage not values
          return 0;
      }
      
      if ($self->{storable} == 1) {
          open FILE, $self->{statefile_dir} . '/' . $self->{statefile};
          eval {
              $self->{datas} = Storable::fd_retrieve(*FILE);
          };
          # File is corrupted surely. We'll reset it
          if ($@) {
              close FILE;
              return 0;
          }
          close FILE;
      } else {
          unless (my $return = do $self->{statefile_dir} . '/' . $self->{statefile}) {
              # File is corrupted surely. We'll reset it
              return 0;
              #if ($@) {
              #    $self->{output}->add_option_msg(short_msg => "Couldn't parse '" . $self->{statefile_dir} . "/" . $self->{statefile} . "': $@");
              #    $self->{output}->option_exit();
              #}
              #unless (defined($return)) {
              #    $self->{output}->add_option_msg(short_msg => "Couldn't do '" . $self->{statefile_dir} . "/" . $self->{statefile} . "': $!");
              #    $self->{output}->option_exit();
              #}
              #unless ($return) {
              #    $self->{output}->add_option_msg(short_msg => "Couldn't run '" . $self->{statefile_dir} . "/" . $self->{statefile} . "': $!");
              #    $self->{output}->option_exit();
          }
          $self->{datas} = $datas;
          $datas = {};
      }
  
      return 1;
  }
  
  sub get_string_content {
      my ($self, %options) = @_;
  
      return Data::Dumper::Dumper($self->{datas});
  }
  
  sub get {
      my ($self, %options) = @_;
  
      if (defined($self->{datas}->{$options{name}})) {
          return $self->{datas}->{$options{name}};
      }
      return undef;
  }
  
  sub write {
      my ($self, %options) = @_;
  
      if ($self->{memcached_ok} == 1) {
          Memcached::libmemcached::memcached_set($self->{memcached}, $self->{statefile_dir} . '/' . $self->{statefile}, 
                                                 Data::Dumper->Dump([$options{data}], ['datas']), $self->{memexpiration});
          if (defined($self->{memcached}->errstr) && $self->{memcached}->errstr =~ /^SUCCESS$/i) {
              return ;
          }
      }
      if (defined($self->{redis_cnx})) {
          return if (defined($self->{redis_cnx}->set($self->{statefile_dir} . '/' . $self->{statefile}, Data::Dumper->Dump([$options{data}], ['datas']),
                                                    'EX', $self->{memexpiration})));
      }
      open FILE, '>', $self->{statefile_dir} . '/' . $self->{statefile};
      if ($self->{storable} == 1) {
          Storable::store_fd($options{data}, *FILE);
      } else {
          print FILE Data::Dumper->Dump([$options{data}], ['datas']);
      }
      close FILE;
  }
  
  1;
  
  
  =head1 NAME
  
  Statefile class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 RETENTION OPTIONS
  
  =over 8
  
  =item B<--memcached>
  
  Memcached server to use (only one server).
  
  =item B<--redis-server>
  
  Redis server to use (only one server).
  
  =item B<--redis-attribute>
  
  Set Redis Options (--redis-attribute="cnx_timeout=5").
  
  =item B<--redis-db>
  
  Set Redis database index.
  
  =item B<--memexpiration>
  
  Time to keep data in seconds (Default: 86400).
  
  =item B<--statefile-dir>
  
  Directory for statefile (Default: '/var/lib/centreon/centplugins').
  
  =item B<--statefile-suffix>
  
  Add a suffix for the statefile name (Default: '').
  
  =item B<--statefile-concat-cwd>
  
  Concat current working directory with option '--statefile-dir'.
  Useful on Windows when plugin is compiled.
  
  =item B<--statefile-storable>
  
  Use Perl Module 'Storable' (instead Data::Dumper) to store datas.
  
  =back
  
  =head1 DESCRIPTION
  
  B<statefile>.
  
  =cut
CENTREON_PLUGINS_STATEFILE

$fatpacked{"centreon/plugins/templates/catalog_functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_CATALOG_FUNCTIONS';
  #
  # Copyright 2018 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::catalog_functions;
  
  use strict;
  use warnings;
  use Exporter;
  
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(catalog_status_threshold catalog_status_calc);
  
  sub catalog_status_threshold {
      my ($self, %options) = @_;
      my $status = 'ok';
      my $message;
  
      eval {
          local $SIG{__WARN__} = sub { $message = $_[0]; };
          local $SIG{__DIE__} = sub { $message = $_[0]; };
  
          my $label = $self->{label};
          $label =~ s/-/_/g;
          if (defined($self->{instance_mode}->{option_results}->{'ok_' . $label}) && $self->{instance_mode}->{option_results}->{'ok_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'ok_' . $label}") {
              $status = 'ok';
          } elsif (defined($self->{instance_mode}->{option_results}->{'critical_' . $label}) && $self->{instance_mode}->{option_results}->{'critical_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'critical_' . $label}") {
              $status = 'critical';
          } elsif (defined($self->{instance_mode}->{option_results}->{'warning_' . $label}) && $self->{instance_mode}->{option_results}->{'warning_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'warning_' . $label}") {
              $status = 'warning';
          } elsif (defined($self->{instance_mode}->{option_results}->{'unknown_' . $label}) && $self->{instance_mode}->{option_results}->{'unknown_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'unknown_' . $label}") {
              $status = 'unknown';
          }
      };
      if (defined($message)) {
          $self->{output}->output_add(long_msg => 'filter status issue: ' . $message);
      }
  
      return $status;
  }
  
  sub catalog_status_calc {
      my ($self, %options) = @_;
  
      foreach (keys %{$options{new_datas}}) {
          if (/^\Q$self->{instance}\E_(.*)/) {
              $self->{result_values}->{$1} = $options{new_datas}->{$_};
          }
      }
  }
  
  1;
  
  
CENTREON_PLUGINS_TEMPLATES_CATALOG_FUNCTIONS

$fatpacked{"centreon/plugins/templates/counter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_COUNTER';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::counter;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  use centreon::plugins::values;
  use centreon::plugins::misc;
  
  my $sort_subs = {
      num => sub { $a <=> $b },
      cmp => sub { $a cmp $b },
  };
  
  sub set_counters {
      my ($self, %options) = @_;
      
      if (!defined($self->{maps_counters})) {
          $self->{maps_counters} = {};
      }
      
      $self->{maps_counters_type} = [];
      
      # 0 = mode total
      # 1 = mode instances
      #push @{$self->{maps_counters_type}}, { 
      #    name => 'global', type => 0, message_separator => ', ', cb_prefix_output => undef, cb_init => undef,
      #};
  
      #$self->{maps_counters}->{global} = [
      #    { label => 'client', set => {
      #           key_values => [ { name => 'client' } ],
      #           output_template => 'Current client connections : %s',
      #           perfdatas => [
      #               { label => 'Client', value => 'client_absolute', template => '%s', 
      #                 min => 0, unit => 'con' },
      #           ],
      #       }
      #    },
      #];
      
      # Example for instances
      #push @{$self->{maps_counters_type}}, { 
      #    name => 'cpu', type => 1, message_separator => ', ', cb_prefix_output => undef, cb_init => undef,
      #    message_multiple => 'All CPU usages are ok',
      #};    
  }
  
  sub get_callback {
      my ($self, %options) = @_;
  
      if (defined($options{method_name})) {
          return $self->can($options{method_name});
      }
      
      return undef;
  }
  
  sub call_object_callback {
      my ($self, %options) = @_;
      
      if (defined($options{method_name})) {
          my $method = $self->can($options{method_name});
          if ($method) {
              return $self->$method(%options);
          }
      }
      
      return undef;
  }
  
  sub get_threshold_prefix {
      my ($self, %options) = @_;
      
      my $prefix = '';
      END_LOOP: foreach (@{$self->{maps_counters_type}}) {
          if ($_->{name} eq $options{name}) {
              $prefix = 'instance-' if ($_->{type} == 1);
              last;
          }
          
          if ($_->{type} == 3) {
              foreach (@{$_->{group}}) {
                  if ($_->{name} eq $options{name}) {
                      $prefix = 'instance-' if ($_->{type} == 0);
                      $prefix = 'subinstance-' if ($_->{type} == 1);
                      last END_LOOP;
                  }
              }
          }
      }
  
      return $prefix;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $self->{version} = '1.0';
      $options{options}->add_options(arguments => {
          'filter-counters:s'     => { name => 'filter_counters' },
          'display-ok-counters:s' => { name => 'display_ok_counters' },
          'list-counters'         => { name => 'list_counters' },
      });
      $self->{statefile_value} = undef;
      if (defined($options{statefile}) && $options{statefile}) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'centreon::plugins::statefile',
                                                 error_msg => "Cannot load module 'centreon::plugins::statefile'.");
          $self->{statefile_value} = centreon::plugins::statefile->new(%options);
      }
      
      $self->{maps_counters} = {} if (!defined($self->{maps_counters}));
      $self->set_counters(%options);
      
      foreach my $key (keys %{$self->{maps_counters}}) {
          foreach (@{$self->{maps_counters}->{$key}}) {
              my $label = $_->{label};
              my $thlabel = $label;
              if ($self->{output}->use_new_perfdata() && defined($_->{nlabel})) {
                  $label = $_->{nlabel};
                  $thlabel = $self->get_threshold_prefix(name => $key) . $label;
              }
              $thlabel =~ s/\./-/g;
              
              if (!defined($_->{threshold}) || $_->{threshold} != 0) {
                  $options{options}->add_options(arguments => {
                      'warning-' . $thlabel . ':s'     => { name => 'warning-' . $thlabel },
                      'critical-' . $thlabel . ':s'    => { name => 'critical-' . $thlabel },
                  });
  
                  if (defined($_->{nlabel})) {
                      $options{options}->add_options(arguments => {
                          'warning-' . $_->{label} . ':s'     => { name => 'warning-' . $_->{label}, redirect => 'warning-' . $thlabel },
                          'critical-' . $_->{label} . ':s'    => { name => 'critical-' . $_->{label}, redirect => 'critical-' . $thlabel },
                      });
                  }
              }
              $_->{obj} = centreon::plugins::values->new(
                  statefile => $self->{statefile_value},
                  output => $self->{output}, perfdata => $self->{perfdata},
                  label => $_->{label}, nlabel => $_->{nlabel}, thlabel => $thlabel,
              );
              $_->{obj}->set(%{$_->{set}});
          }
      }
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (defined($self->{option_results}->{list_counters})) {
          my $list_counter = 'counter list:';
          my $th_counter = '';
          foreach my $key (keys %{$self->{maps_counters}}) {
              foreach (@{$self->{maps_counters}->{$key}}) {
                  my $label = $_->{label};
                  $label =~ s/-//g;
                  $list_counter .= " " . $_->{label};
                  $th_counter .= " --warning-$_->{label}='\$_SERVICEWARNING" . uc($label) . "\$' --critical-$_->{label}='\$_SERVICECRITICAL" . uc($label) . "\$'";  
              }
          }
          $self->{output}->output_add(short_msg => $list_counter);
          $self->{output}->output_add(long_msg => 'configuration: ' . $th_counter); 
          $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1);
          $self->{output}->exit();
      }
      foreach my $key (keys %{$self->{maps_counters}}) {
          foreach (@{$self->{maps_counters}->{$key}}) {
              $_->{obj}->{instance_mode} = $self;
              $_->{obj}->init(option_results => $self->{option_results});
          }
      }
      
      if (defined($self->{statefile_value})) {
          $self->{statefile_value}->check_options(%options);
      }
  }
  
  sub run_global {
      my ($self, %options) = @_;
      
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $resume = defined($options{resume}) && $options{resume} == 1 ? 1 : 0;
      # Can be set when it comes from type 3 counters
      my $called_multiple = defined($options{called_multiple}) && $options{called_multiple} == 1 ? 1 : 0;
      my $multiple_parent = defined($options{multiple_parent}) && $options{multiple_parent} == 1 ? 1 : 0;
      my $force_instance = defined($options{force_instance}) ? $options{force_instance} : undef;
      
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator}: ', ';
      my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
      my @exits;
      foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
          my $obj = $_->{obj};
  
          next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
              $_->{label} !~ /$self->{option_results}->{filter_counters}/);
      
          $obj->set(instance => defined($force_instance) ? $force_instance : $options{config}->{name});
      
          my ($value_check) = $obj->execute(new_datas => $self->{new_datas}, values => $self->{$options{config}->{name}});
  
          next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
          if ($value_check != 0) {
              $long_msg .= $long_msg_append . $obj->output_error();
              $long_msg_append = $message_separator;
              next;
          }
          my $exit2 = $obj->threshold_check();
          push @exits, $exit2;
  
          my $output = $obj->output();
          if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
              (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
               $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
              $long_msg .= $long_msg_append . $output;
              $long_msg_append = $message_separator;
          }
  
          if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
              $short_msg .= $short_msg_append . $output;
              $short_msg_append = $message_separator;
          }
          
          $obj->perfdata(extra_instance => $multiple_parent);
      }
  
      my ($prefix_output, $suffix_output);
      $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}) 
          if (defined($options{config}->{cb_prefix_output}));
      $prefix_output = '' if (!defined($prefix_output));
      
      $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
      $suffix_output = '' if (!defined($suffix_output));
      
      if ($called_multiple == 1 && $long_msg ne '') {
          $self->{output}->output_add(long_msg => $options{indent_long_output} . $prefix_output. $long_msg . $suffix_output);
      }
      
      my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
      if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
          if ($called_multiple == 0) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => $prefix_output . $short_msg . $suffix_output);
          } else {
              $self->run_multiple_prefix_output(severity => $exit,
                                                short_msg => $prefix_output . $short_msg . $suffix_output);
          }
      } else {
          if ($long_msg ne '' && $multiple_parent == 0) {
              if ($called_multiple == 0) {
                  $self->{output}->output_add(short_msg => $prefix_output . $long_msg . $suffix_output) ;
              } else {
                  $self->run_multiple_prefix_output(severity => 'ok',
                                                    short_msg => $prefix_output . $long_msg . $suffix_output);
              }
          }
      }
  }
  
  sub run_instances {
      my ($self, %options) = @_;
      
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $cb_init_counters = $self->get_callback(method_name => $options{config}->{cb_init_counters});
      my $display_status_lo = defined($options{display_status_long_output}) && $options{display_status_long_output} == 1 ? 1 : 0;
      my $resume = defined($options{resume}) && $options{resume} == 1 ? 1 : 0;
      my $no_message_multiple = 1;
      
      $self->{lproblems} = 0;
      $self->{multiple} = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $self->{multiple} = 0;
      }
      
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator}: ', ';
  
      my $sort_method = 'cmp';
      $sort_method = $options{config}->{sort_method}
          if (defined($options{config}->{sort_method}));
      foreach my $id (sort { $sort_subs->{$sort_method}->() } keys %{$self->{$options{config}->{name}}}) {
          my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
          my @exits = ();
          foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
              my $obj = $_->{obj};
  
              next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
                  $_->{label} !~ /$self->{option_results}->{filter_counters}/);
              next if ($cb_init_counters && $self->$cb_init_counters(%$_) == 1);
  
              $no_message_multiple = 0;
              $obj->set(instance => $id);
          
              my ($value_check) = $obj->execute(new_datas => $self->{new_datas},
                                                values => $self->{$options{config}->{name}}->{$id});
              next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
              if ($value_check != 0) {
                  $long_msg .= $long_msg_append . $obj->output_error();
                  $long_msg_append = $message_separator;
                  next;
              }
              my $exit2 = $obj->threshold_check();
              push @exits, $exit2;
  
              my $output = $obj->output();
              if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
                  (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
                   $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
                  $long_msg .= $long_msg_append . $output;
                  $long_msg_append = $message_separator;
              }
              
              if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
                  $self->{lproblems}++;
                  $short_msg .= $short_msg_append . $output;
                  $short_msg_append = $message_separator;
              }
              
              $obj->perfdata(extra_instance => $self->{multiple});
          }
  
          my ($prefix_output, $suffix_output);
          $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
          $prefix_output = '' if (!defined($prefix_output));
          
          $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
          $suffix_output = '' if (!defined($suffix_output));
  
          my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
          # in mode grouped, we don't display 'ok'
          my $debug = 0;
          $debug = 1 if ($display_status_lo == 1 && $self->{output}->is_status(value => $exit, compare => 'OK', litteral => 1));
          if (scalar @{$self->{maps_counters}->{$options{config}->{name}}} > 0 && $long_msg ne '') {
              $self->{output}->output_add(long_msg => ($display_status_lo == 1 ? lc($exit) . ': ' : '') . $prefix_output . $long_msg . $suffix_output, debug => $debug);
          }
          if ($resume == 1) {
              $self->{most_critical_instance} = $self->{output}->get_most_critical(status => [ $self->{most_critical_instance},  $exit ]);  
              next;
          }
          
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => $prefix_output . $short_msg . $suffix_output);
          }
          
          if ($self->{multiple} == 0)  {
              $self->{output}->output_add(short_msg => $prefix_output . $long_msg . $suffix_output);
          }
      }
      
      if ($no_message_multiple == 0 && $self->{multiple} == 1 && $resume == 0) {
          $self->{output}->output_add(short_msg => $options{config}->{message_multiple});
      }
  }
  
  sub run_group {
      my ($self, %options) = @_;
  
      my $multiple = 1;
      return if (scalar(keys %{$self->{$options{config}->{name}}}) <= 0);
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $multiple = 0;
      }
      
      if ($multiple == 1) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => $options{config}->{message_multiple});
      }
      
      my $format_output = defined($options{config}->{format_output}) ? $options{config}->{format_output} : '%s problem(s) detected';
      
      my ($global_exit, $total_problems) = ([], 0);
      foreach my $id (sort keys %{$self->{$options{config}->{name}}}) {
          $self->{most_critical_instance} = 'ok';
          if (defined($options{config}->{cb_long_output})) {
              $self->{output}->output_add(long_msg => $self->call_object_callback(method_name => $options{config}->{cb_long_output},
                                                                                  instance_value => $self->{$options{config}->{name}}->{$id}));
          }
          
          foreach my $group (@{$options{config}->{group}}) {
              $self->{$group->{name}} = $self->{$options{config}->{name}}->{$id}->{$group->{name}};
              
              # we resume datas
              $self->run_instances(config => $group, display_status_long_output => 1, resume => 1);
              
              push @{$global_exit}, $self->{most_critical_instance};
              $total_problems += $self->{lproblems};
              
              my $prefix_output;
              $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
              $prefix_output = '' if (!defined($prefix_output));
              
              if ($multiple == 0 && (!defined($group->{display}) || $group->{display} != 0)) {
                  $self->{output}->output_add(severity => $self->{most_critical_instance},
                                              short_msg => sprintf("${prefix_output}" . $format_output, $self->{lproblems}));
              }
          }
      }
      
      if ($multiple == 1) {
          my $exit = $self->{output}->get_most_critical(status => [ @{$global_exit} ]);
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf($format_output, $total_problems));
          }
      }
      
      if (defined($options{config}->{display_counter_problem})) {
          $self->{output}->perfdata_add(
              label => $options{config}->{display_counter_problem}->{label},
              nlabel => $options{config}->{display_counter_problem}->{nlabel},
              unit => $options{config}->{display_counter_problem}->{unit},
              value => $total_problems,
              min => $options{config}->{display_counter_problem}->{min}, max => $options{config}->{display_counter_problem}->{max}
          );
      }
  }
  
  sub run_multiple_instances {
      my ($self, %options) = @_;
      
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $use_new_perfdata = $self->{output}->use_new_perfdata();
      my $multiple_parent = defined($options{multiple_parent}) && $options{multiple_parent} == 1 ? $options{multiple_parent} : 0;
      my $indent_long_output = defined($options{indent_long_output}) ? $options{indent_long_output} : '';
      my $no_message_multiple = 1;
      
      my $multiple = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $multiple = 0;
      }
      
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator} : ', ';
      my $sort_method = 'cmp';
      $sort_method = $options{config}->{sort_method}
          if (defined($options{config}->{sort_method}));
      foreach my $id (sort { $sort_subs->{$sort_method}->() } keys %{$self->{$options{config}->{name}}}) {
          my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
          my @exits = ();
          foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
              my $obj = $_->{obj};
              
              next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
                  $_->{label} !~ /$self->{option_results}->{filter_counters}/);
              
              my $instance = $id;
              if ($use_new_perfdata || ($multiple_parent == 1 && $multiple == 1)) {
                  $instance = $options{instance_parent} . ($self->{output}->get_instance_perfdata_separator()) . $id;
              } elsif ($multiple_parent == 1 && $multiple == 0) {
                  $instance = $options{instance_parent};
              }
              
              $no_message_multiple = 0;
              $obj->set(instance => $instance);
          
              my ($value_check) = $obj->execute(new_datas => $self->{new_datas},
                                                values => $self->{$options{config}->{name}}->{$id});
              next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
              if ($value_check != 0) {
                  $long_msg .= $long_msg_append . $obj->output_error();
                  $long_msg_append = $message_separator;
                  next;
              }
              my $exit2 = $obj->threshold_check();
              push @exits, $exit2;
  
              my $output = $obj->output();
              $long_msg .= $long_msg_append . $output;
              $long_msg_append = $message_separator;
              
              if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
                  $short_msg .= $short_msg_append . $output;
                  $short_msg_append = $message_separator;
              }
              
              if ($multiple_parent == 1 && $multiple == 0) {
                  $obj->perfdata(extra_instance => 1);
              } else {
                  $obj->perfdata(extra_instance => $multiple);
              }
          }
  
          my ($prefix_output, $suffix_output);
          $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
          $prefix_output = '' if (!defined($prefix_output));
          
          $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
          $suffix_output = '' if (!defined($suffix_output));
  
          my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
          if (scalar @{$self->{maps_counters}->{$options{config}->{name}}} > 0 && $long_msg ne '') {
              $self->{output}->output_add(long_msg => $indent_long_output . $prefix_output . $long_msg . $suffix_output)
                  if (!defined($options{config}->{display_long}) || $options{config}->{display_long} != 0);
          }
          
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->run_multiple_prefix_output(severity => $exit,
                  short_msg => $prefix_output . $short_msg . $suffix_output);
          }
          
          if ($multiple == 0 && $multiple_parent == 0) {
              $self->run_multiple_prefix_output(severity => 'ok', short_msg => $prefix_output . $long_msg . $suffix_output);            
          }
      }
      
      if ($no_message_multiple == 0 && $multiple == 1 && $multiple_parent == 0) {
          $self->{output}->output_add(short_msg => $options{config}->{message_multiple});
      }
  }
  
  sub run_multiple_prefix_output {
      my ($self, %options) = @_;
      
      my %separator;
      if ($self->{prefix_multiple_output_done}->{lc($options{severity})} == 0) {
          $self->{output}->output_add(severity => $options{severity}, short_msg => $self->{prefix_multiple_output});
          $self->{prefix_multiple_output_done}->{lc($options{severity})} = 1;
          $separator{separator} = '';
      }
      
      $self->{output}->output_add(severity => $options{severity}, short_msg => "$options{short_msg}", %separator);
  }
  
  sub run_multiple {
      my ($self, %options) = @_;
  
      my $multiple = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $multiple = 0;
      }
      
      if ($multiple == 1) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => $options{config}->{message_multiple});
      }
      
      foreach my $instance (sort keys %{$self->{$options{config}->{name}}}) {
          if (defined($options{config}->{cb_long_output})) {
              $self->{output}->output_add(long_msg => $self->call_object_callback(method_name => $options{config}->{cb_long_output},
                                                                                  instance_value => $self->{$options{config}->{name}}->{$instance}));
          }
          
          $self->{prefix_multiple_output} = '';
          $self->{prefix_multiple_output_done} = { ok => 0, warning => 0, critical => 0, unknown => 0 };
          $self->{prefix_multiple_output} = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$instance})
               if (defined($options{config}->{cb_prefix_output}));
          my $indent_long_output = '';
          $indent_long_output = $options{config}->{indent_long_output}
              if (defined($options{config}->{indent_long_output}));
          
          foreach my $group (@{$options{config}->{group}}) {
              next if (!defined($self->{$options{config}->{name}}->{$instance}->{$group->{name}}));
              $self->{$group->{name}} = $self->{$options{config}->{name}}->{$instance}->{$group->{name}};
              
              if ($group->{type} == 1) {
                  $self->run_multiple_instances(config => $group, multiple_parent => $multiple, instance_parent => $instance, indent_long_output => $indent_long_output);
              } elsif ($group->{type} == 0) {
                  $self->run_global(config => $group, multiple_parent => $multiple, called_multiple => 1, force_instance => $instance, indent_long_output => $indent_long_output);
              }
          }
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      
      $self->manage_selection(%options);
      
      $self->{new_datas} = undef;
      if (defined($self->{statefile_value})) {
          $self->{new_datas} = {};
          $self->{statefile_value}->read(statefile => $self->{cache_name}) if (defined($self->{cache_name}));
          $self->{new_datas}->{last_timestamp} = time();
      }
      
      foreach my $entry (@{$self->{maps_counters_type}}) {
          if ($entry->{type} == 0) {
              $self->run_global(config => $entry);
          } elsif ($entry->{type} == 1) {
              $self->run_instances(config => $entry);
          } elsif ($entry->{type} == 2) {
              $self->run_group(config => $entry);
          } elsif ($entry->{type} == 3) {
              $self->run_multiple(config => $entry);
          }
      }
          
      if (defined($self->{statefile_value})) {
          $self->{statefile_value}->write(data => $self->{new_datas});
      }
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      # example for snmp
      #use Digest::MD5 qw(md5_hex);
      #$self->{cache_name} = "choose_name_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
      #    (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  sub change_macros {
      my ($self, %options) = @_;
  
      foreach (@{$options{macros}}) {
          if (defined($self->{option_results}->{$_})) {
              $self->{option_results}->{$_} =~ s/%\{(.*?)\}/\$self->{result_values}->{$1}/g;
          }
      }
  }
      
  1;
  
  
  =head1 MODE
  
  Default template for counters. Should be extended.
  
  =over 8
  
  =item B<--filter-counters>
  
  Only display some counters (regexp can be used).
  Example to check SSL connections only : --filter-counters='^xxxx|yyyy$'
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'xxx', 'xxx'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'xxx', 'xxx'.
  
  =back
  
  =cut
CENTREON_PLUGINS_TEMPLATES_COUNTER

$fatpacked{"centreon/plugins/templates/hardware.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_HARDWARE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::hardware;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub set_system {
      my ($self, %options) = @_;
      
      # To check with a regexp
      #$self->{regexp_threshold_overload_check_section_option} = '';
      #$self->{cb_threshold_overload_check_section_option} = 'callbackname';
      
      #$self->{regexp_threshold_numeric_check_section_option} = '';
      #$self->{cb_threshold_numeric_check_section_option} = 'callbackname';
      
      # Some callbacks 
      #$self->{cb_hook1} = 'callbackname'; # before the loads
      #$self->{cb_hook2} = 'callbackname'; # between loads and requests
      #$self->{cb_hook3} = 'callbackname'; # after requests
      #$self->{cb_hook4} = 'callbackname'; # after output
      
      # Example for threshold:
      #$self->{thresholds} = {
      #    fan => [
      #        ['bad', 'CRITICAL'],
      #        ['good', 'OK'],
      #        ['notPresent', 'OK'],
      #    ],
      #};
      
      # Unset the call to load components
      #$self->{components_exec_load} = 0;
      
      # Set the path_info
      #$self->{components_path} = 'network::xxxx::mode::components';
      
      # Set the components
      #$self->{components_module} = ['cpu', 'memory', ...];
  }
  
  sub call_object_callback {
      my ($self, %options) = @_;
      
      if (defined($options{method_name})) {
          my $method = $self->can($options{method_name});
          if ($method) {
              return $self->$method(%options);
          }
      }
      
      return undef;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $self->{version} = '1.0';
      $options{options}->add_options(arguments => {
          'component:s'             => { name => 'component', default => '.*' },
          'no-component:s'          => { name => 'no_component' },
          'threshold-overload:s@'   => { name => 'threshold_overload' },
          'add-name-instance'       => { name => 'add_name_instance' },
      });
      
      $self->{performance} = (defined($options{no_performance}) && $options{no_performance} == 1) ?
          0 : 1;
      if ($self->{performance} == 1) {
          $options{options}->add_options(arguments => {
              'warning:s@'     => { name => 'warning' },
              'critical:s@'   => { name => 'critical' },
          });
      }
      
      $self->{filter_exclude} = (defined($options{no_filter_exclude}) && $options{no_filter_exclude} == 1) ?
          0 : 1;
      if ($self->{filter_exclude} == 1) {
          $options{options}->add_options(arguments => {
              'exclude:s'     => { name => 'exclude' },
              'filter:s@'     => { name => 'filter' },
          });
      }
      $self->{absent} = (defined($options{no_absent}) && $options{no_absent} == 1) ?
          0 : 1;
      if ($self->{absent} == 1) {
          $options{options}->add_options(arguments => {
              'absent-problem:s@'       => { name => 'absent_problem' },
          });
      }
      
      $self->{load_components} = (defined($options{no_load_components}) && $options{no_load_components} == 1) ?
          0 : 1;
      $self->{components} = {};
      $self->{no_components} = undef;
      
      $self->{components_module} = [];
      $self->{components_exec_load} = 1;
      $self->set_system();
  
      $self->{count} = (defined($options{no_count}) && $options{no_count} == 1) ?
          0 : 1;
      if ($self->{count} == 1) {
          foreach my $component (@{$self->{components_module}}) {
              $options{options}->add_options(arguments => {
                  'warning-count-' . $component . ':s'    => { name => 'warning_count_' . $component },
                  'critical-count-' . $component . ':s'    => { name => 'critical_count_' . $component },
              });
          }
      }
  
      $self->{request} = [];
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (defined($self->{option_results}->{no_component})) {
          if ($self->{option_results}->{no_component} ne '') {
              $self->{no_components} = $self->{option_results}->{no_component};
          } else {
              $self->{no_components} = 'critical';
          }
      }
      
      if ($self->{filter_exclude} == 1) {
          $self->{filter} = [];
          foreach my $val (@{$self->{option_results}->{filter}}) {
              next if (!defined($val) || $val eq '');
              my @values = split (/,/, $val);
              push @{$self->{filter}}, { filter => $values[0], instance => $values[1] }; 
          }
      }
      
      if ($self->{absent} == 1) {
          $self->{absent_problem} = [];
          foreach my $val (@{$self->{option_results}->{absent_problem}}) {
              next if (!defined($val) || $val eq '');
              my @values = split (/,/, $val);
              push @{$self->{absent_problem}}, { filter => $values[0], instance => $values[1] }; 
          }
      }
      
      $self->{overload_th} = {};
      foreach my $val (@{$self->{option_results}->{threshold_overload}}) {
          next if (!defined($val) || $val eq '');
          my @values = split (/,/, $val);
          if (scalar(@values) < 3) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload option '" . $val . "'.");
              $self->{output}->option_exit();
          }
          my ($section, $instance, $status, $filter);
          if (scalar(@values) == 3) {
              ($section, $status, $filter) = @values;
              $instance = '.*';
          } else {
               ($section, $instance, $status, $filter) = @values;
          }
          if (defined($self->{regexp_threshold_overload_check_section_option}) && 
              $section !~ /$self->{regexp_threshold_overload_check_section_option}/) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload section '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->call_object_callback(method_name => $self->{cb_threshold_overload_check_section_option}, 
                                      section => $section, option_value => $val);
  
          if ($self->{output}->is_litteral_status(status => $status) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload status '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->{overload_th}->{$section} = [] if (!defined($self->{overload_th}->{$section}));
          push @{$self->{overload_th}->{$section}}, {filter => $filter, status => $status, instance => $instance };
      }
      
      if ($self->{performance} == 1) {
          $self->{numeric_threshold} = {};
          foreach my $option (('warning', 'critical')) {
              foreach my $val (@{$self->{option_results}->{$option}}) {
                  next if (!defined($val) || $val eq '');
                  if ($val !~ /^(.*?),(.*?),(.*)$/) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option option '" . $val . "'.");
                      $self->{output}->option_exit();
                  }
                  my ($section, $instance, $value) = ($1, $2, $3);                
                  if (defined($self->{regexp_threshold_numeric_check_section_option}) && 
                      $section !~ /$self->{regexp_threshold_numeric_check_section_option}/) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option option '" . $val . "'.");
                      $self->{output}->option_exit();
                  }   
                  $self->call_object_callback(method_name => $self->{cb_threshold_numeric_check_section_option}, 
                                              section => $section, option_name => $option, option_value => $val);
  
                  my $position = 0;
                  if (defined($self->{numeric_threshold}->{$section})) {
                      $position = scalar(@{$self->{numeric_threshold}->{$section}});
                  }
                  if (($self->{perfdata}->threshold_validate(label => $option . '-' . $section . '-' . $position, value => $value)) == 0) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option threshold '" . $value . "'.");
                      $self->{output}->option_exit();
                  }
                  $self->{numeric_threshold}->{$section} = [] if (!defined($self->{numeric_threshold}->{$section}));
                  push @{$self->{numeric_threshold}->{$section}}, { label => $option . '-' . $section . '-' . $position, threshold => $option, instance => $instance };
              }
          }
      }
      
      if ($self->{count} == 1) {
          foreach my $comp (@{$self->{components_module}}) {
              foreach my $threshold (('warning', 'critical')) {
                  if (($self->{perfdata}->threshold_validate(label => $threshold . '-count-' . $comp, value => $self->{option_results}->{$threshold . '_count_' . $comp})) == 0) {
                      $self->{output}->add_option_msg(short_msg => "Wrong " . $threshold . " threshold '" . $self->{option_results}->{$threshold . '_count_' . $comp} . "'.");
                      $self->{output}->option_exit();
                  }
              }
          }
      }
  }
  
  sub load_components {
      my ($self, %options) = @_;
      
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $mod_name,
                                                     error_msg => "Cannot load module '$mod_name'.") if ($self->{load_components} == 1);
              $self->{loaded} = 1;
              if ($self->{components_exec_load} == 1) {
                  my $func = $mod_name->can('load');
                  $func->($self);
              }
          }
      }
  }
  
  sub exec_components {
      my ($self, %options) = @_;
      
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              my $func = $mod_name->can('check');
              $func->($self); 
          }
      }
  }
  
  sub display {
      my ($self, %options) = @_;
      
      my $total_components = 0;
      my $display_by_component = '';
      my $display_by_component_append = '';
      my $exit = 'OK';
      my $exits = [];
      my ($warn, $crit);
  
      foreach my $comp (sort(keys %{$self->{components}})) {
          # Skipping short msg when no components
          next if ($self->{components}->{$comp}->{total} == 0 && $self->{components}->{$comp}->{skip} == 0);
  
          if ($self->{count} == 1) {
              ($exit, $warn, $crit) = $self->get_severity_count(label => $comp, value => $self->{components}->{$comp}->{total});
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("'%s' components '%s' checked",
                                                              $self->{components}->{$comp}->{total},
                                                              $comp));
              }
              $self->{output}->perfdata_add(
                  label => 'count_' . $comp,
                  nlabel => 'hardware.' . $comp . '.count',
                  value => $self->{components}->{$comp}->{total},
                  warning => $warn,
                  critical => $crit
              );
              push @{$exits}, $exit;
          }
  
          $total_components += $self->{components}->{$comp}->{total} + $self->{components}->{$comp}->{skip};
          my $count_by_components = $self->{components}->{$comp}->{total} + $self->{components}->{$comp}->{skip}; 
          $display_by_component .= $display_by_component_append . $self->{components}->{$comp}->{total} . '/' . $count_by_components . ' ' . $self->{components}->{$comp}->{name};
          $display_by_component_append = ', ';
      }
  
      $exit = $self->{output}->get_most_critical(status => $exits) if (scalar(@{$exits}) > 0);
      
      if ($self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
          $self->{output}->output_add(short_msg => sprintf('All %s components are ok [%s].', 
                                                          $total_components,
                                                          $display_by_component)
                                      );
      }
  
      if (defined($self->{option_results}->{no_component}) && $total_components == 0) {
          $self->{output}->output_add(severity => $self->{no_components},
                                      short_msg => 'No components are checked.');
      }
  }
  
  sub run {
      my ($self, %options) = @_;
  
      $self->{loaded} = 0;  
      $self->call_object_callback(method_name => $self->{cb_hook1}, %options);
  
      $self->load_components(%options);
      if ($self->{loaded} == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong option. Cannot find component '" . $self->{option_results}->{component} . "'.");
          $self->{output}->option_exit();
      }
      
      $self->call_object_callback(method_name => $self->{cb_hook2}, %options);
      $self->exec_components(%options);
      $self->call_object_callback(method_name => $self->{cb_hook3}, %options);
      
      $self->display();
  
      $self->call_object_callback(method_name => $self->{cb_hook4}, %options);
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub check_filter {
      my ($self, %options) = @_;
      
      # Old compatibility variable. We'll be deleted
      if (defined($self->{option_results}->{exclude})) {
          if (defined($options{instance})) {
              if ($self->{option_results}->{exclude} =~ /(^|\s|,)${options{section}}[^,]*#\Q$options{instance}\E#/) {
                  $self->{components}->{$options{section}}->{skip}++;
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section $options{instance} instance."));
                  return 1;
              }
          } elsif (defined($self->{option_results}->{exclude}) && $self->{option_results}->{exclude} =~ /(^|\s|,)$options{section}(\s|,|$)/) {
              $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section."));
              return 1;
          }
      }
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));   
      foreach (@{$self->{filter}}) {
          if ($options{section} =~ /$_->{filter}/) {
              if (!defined($options{instance}) && !defined($_->{instance})) {
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section."));
                  return 1;
              } elsif (defined($options{instance}) && $options{instance} =~ /$_->{instance}/) {
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section $options{instance} instance."));
                  return 1;
              }
          }
      }
      
      return 0;
  }
  
  sub absent_problem {
      my ($self, %options) = @_;
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
      foreach (@{$self->{absent_problem}}) {
          if ($options{section} =~ /$_->{filter}/) {
              if (!defined($_->{instance}) || $options{instance} =~ /$_->{instance}/) {
                  $self->{output}->output_add(severity => 'CRITICAL',
                                              short_msg => sprintf("Component '%s' instance '%s' is not present", 
                                                                   $options{section}, $options{instance}));
                  $self->{output}->output_add(long_msg => sprintf("Skipping $options{section} section $options{instance} instance (not present)"));
                  $self->{components}->{$options{section}}->{skip}++;
                  return 1;
              }
          }
      }
      
      return 0;
  }
  
  sub get_severity_count {
      my ($self, %options) = @_;
      my $status = 'OK'; # default
      my $thresholds = { warning => undef, critical => undef };
      
      $status = $self->{perfdata}->threshold_check(value => $options{value},
                                                   threshold => [ { label => 'critical-count-' . $options{label}, 'exit_litteral' => 'critical' }, 
                                                                  { label => 'warning-count-' . $options{label}, 'exit_litteral' => 'warning' } ]);
      $thresholds->{critical} = $self->{perfdata}->get_perfdata_for_output(label => 'critical-count-' . $options{label});
      $thresholds->{warning} = $self->{perfdata}->get_perfdata_for_output(label => 'warning-count-' . $options{label});
  
      return ($status, $thresholds->{warning}, $thresholds->{critical});
  }
  
  sub get_severity_numeric {
      my ($self, %options) = @_;
      my $status = 'OK'; # default
      my $thresholds = { warning => undef, critical => undef };
      my $checked = 0;
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
      if (defined($self->{numeric_threshold}->{$options{section}})) {
          my $exits = [];
          foreach (@{$self->{numeric_threshold}->{$options{section}}}) {
              if ($options{instance} =~ /$_->{instance}/) {
                  push @{$exits}, $self->{perfdata}->threshold_check(value => $options{value}, threshold => [ { label => $_->{label}, exit_litteral => $_->{threshold} } ]);
                  $thresholds->{$_->{threshold}} = $self->{perfdata}->get_perfdata_for_output(label => $_->{label});
                  $checked = 1;
              }
          }
          $status = $self->{output}->get_most_critical(status => $exits) if (scalar(@{$exits}) > 0);
      }
      
      return ($status, $thresholds->{warning}, $thresholds->{critical}, $checked);
  }
  
  sub get_severity {
      my ($self, %options) = @_;
      my $status = 'UNKNOWN'; # default 
      
      if (defined($self->{overload_th}->{$options{section}})) {
          foreach (@{$self->{overload_th}->{$options{section}}}) {            
              if ($options{value} =~ /$_->{filter}/i && 
                  (!defined($options{instance}) || $options{instance} =~ /$_->{instance}/)) {
                  $status = $_->{status};
                  return $status;
              }
          }
      }
      my $label = defined($options{label}) ? $options{label} : $options{section};
      foreach (@{$self->{thresholds}->{$label}}) {
          if ($options{value} =~ /$$_[0]/i) {
              $status = $$_[1];
              return $status;
          }
      }
      
      return $status;
  }
      
  1;
  
  
  =head1 MODE
  
  Default template for hardware. Should be extended.
  
  =over 8
  
  =item B<--component>
  
  Which component to check (Default: '.*').
  Can be: 'xxx', 'yyy'.
  
  =item B<--filter>
  
  Exclude some parts (comma seperated list) (Example: --filter=xxx --filter=yyyy)
  Can also exclude specific instance: --filter=xxxxx,instancevalue
  
  =item B<--absent-problem>
  
  Return an error if an entity is not 'present' (default is skipping) (comma seperated list)
  Can be specific or global: --absent-problem=xxxx,instancevalue
  
  =item B<--no-component>
  
  Return an error if no compenents are checked.
  If total (with skipped) is 0. (Default: 'critical' returns).
  
  =item B<--threshold-overload>
  
  Set to overload default threshold values (syntax: section,[instance,]status,regexp)
  It used before default thresholds (order stays).
  Example: --threshold-overload='xxxxx,CRITICAL,^(?!(normal)$)'
  
  =item B<--warning>
  
  Set warning threshold for temperatures (syntax: type,instance,threshold)
  Example: --warning='xxxxx,.*,30'
  
  =item B<--critical>
  
  Set critical threshold for temperatures (syntax: type,instance,threshold)
  Example: --critical='xxxxx,.*,40'
  
  =item B<--warning-count-xxxx>
  
  Set warning threshold for component count.
  
  =item B<--critical-count-xxxx>
  
  Set critical threshold for component count.
  
  =back
  
  =cut
CENTREON_PLUGINS_TEMPLATES_HARDWARE

$fatpacked{"centreon/plugins/values.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_VALUES';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::values;
  
  use strict;
  use warnings;
  # Warning message with sprintf and too much arguments.
  # Really annoying. Need to disable that warning
  no if ($^V gt v5.22.0), 'warnings' => 'redundant';
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{statefile} = $options{statefile};
      $self->{output} = $options{output};
      $self->{perfdata} = $options{perfdata};
      $self->{label} = $options{label};
      $self->{nlabel} = $options{nlabel};
      $self->{thlabel} = defined($options{thlabel}) ? $options{thlabel} : $self->{label};
  
      $self->{perfdatas} = [];
      
      $self->{output_template} = $self->{label} . ' : %s';
      $self->{output_use} = undef;
      $self->{output_change_bytes} = 0;
      $self->{output_absolute_unit} = '';
      $self->{output_per_second_unit} = '';
      
      $self->{output_error_template} = $self->{label} . ' : %s';
      
      $self->{threshold_use} = undef;
      $self->{threshold_warn} = undef;
      $self->{threshold_crit} = undef;
  
      $self->{per_second} = 0;
      $self->{manual_keys} = 0;
      $self->{last_timestamp} = undef;
  
      $self->{result_values} = {};
      
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel}; 
      
      if (($self->{perfdata}->threshold_validate(label => $warn, value => $options{option_results}->{$warn})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $warn threshold '" . $options{option_results}->{$warn} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => $crit, value => $options{option_results}->{$crit})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $crit threshold '" . $options{option_results}->{$crit} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub set {
      my ($self, %options) = @_;
  
      foreach (keys %options) {
          $self->{$_} = $options{$_};
      }
  }
  
  sub calc {
      my ($self, %options) = @_;
  
      # manage only one value ;)
      foreach my $value (@{$self->{key_values}}) {
          if (defined($value->{diff}) && $value->{diff} == 1) { 
              if (defined($self->{per_second}) && $self->{per_second} == 1) {
                  $self->{result_values}->{$value->{name} . '_per_second'} = ($options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}}) / $options{delta_time};
              }
              $self->{result_values}->{$value->{name} . '_absolute'} = $options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}};
          } else {
              # absolute one. nothing to do. Can be used for values.
              $self->{result_values}->{$value->{name} . '_absolute'} = $options{new_datas}->{$self->{instance} . '_' . $value->{name}};
          }
      }
  
      return 0;
  }
  
  sub threshold_check {
      my ($self, %options) = @_;
      
      if (defined($self->{closure_custom_threshold_check})) {
          return &{$self->{closure_custom_threshold_check}}($self, %options);
      }
      
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel};
      
      my $first = defined($self->{key_values}->[0]) ? $self->{key_values}->[0]->{name} : '';
      my $value;
  
      if (!defined($self->{threshold_use})) {
          $value = $self->{result_values}->{$first . '_absolute'};
          if (defined($self->{per_second}) && $self->{per_second} == 1) {
              $value = $self->{result_values}->{$first . '_per_second'};
          }
      } else {
          $value = $self->{result_values}->{$self->{threshold_use}};
      }
  
      return $self->{perfdata}->threshold_check(value => $value, threshold => [ { label => $crit, 'exit_litteral' => 'critical' },
                                                                                { label => $warn, 'exit_litteral' => 'warning' }]);
  }
  
  sub output_error {
      my ($self, %options) = @_;
      
      return sprintf($self->{output_error_template}, $self->{error_msg});
  }
  
  sub output {
      my ($self, %options) = @_;
       
      if (defined($self->{closure_custom_output})) {
          return $self->{closure_custom_output}->($self);
      }
      my $first = $self->{key_values}->[0]->{name};
      my ($value, $unit) = (defined($first) ? $self->{result_values}->{$first . '_absolute'} : '', $self->{output_absolute_unit});
      
      if (!defined($self->{output_use})) {
          if ($self->{per_second} == 1) {
              $value = $self->{result_values}->{$first . '_per_second'};
              $unit = $self->{output_per_second_unit};
          }
      } else {
          $value = $self->{result_values}->{$self->{output_use}};
      }
  
      if ($self->{output_change_bytes} == 1) {
          ($value, $unit) = $self->{perfdata}->change_bytes(value => $value);
      } elsif ($self->{output_change_bytes} == 2) {
          ($value, $unit) = $self->{perfdata}->change_bytes(value => $value, network => 1);
      }
      
      return sprintf($self->{output_template}, $value, $unit);
  }
  
  sub use_instances {
      my ($self, %options) = @_;
  
      if (!defined($options{extra_instance}) || $options{extra_instance} != 0 || $self->{output}->use_new_perfdata()) {
          return 1;
      }
      
      return 0;
  }
  
  sub perfdata {
      my ($self, %options) = @_;
      
      if (defined($self->{closure_custom_perfdata})) {
          return &{$self->{closure_custom_perfdata}}($self, %options);
      }
      
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel}; 
      
      foreach my $perf (@{$self->{perfdatas}}) {
          my ($label, $extra_label, $min, $max, $th_total) = ($self->{label}, '');
          my $cast_int = (defined($perf->{cast_int}) && $perf->{cast_int} == 1) ? 1 : 0;
          my $template = '%s';
          
          $template = $perf->{template} if (defined($perf->{template}));
          $label = $perf->{label} if (defined($perf->{label}));
          if (defined($perf->{min})) {
              $min = ($perf->{min} =~ /[^0-9]/) ? $self->{result_values}->{$perf->{min}} : $perf->{min};
          }
          if (defined($perf->{max})) {
              $max = ($perf->{max} =~ /[^0-9]/) ? $self->{result_values}->{$perf->{max}} : $perf->{max};
          }
          if (defined($perf->{threshold_total})) {
              $th_total = ($perf->{threshold_total} =~ /[^0-9]/) ? $self->{result_values}->{$perf->{threshold_total}} : $perf->{threshold_total};
          }
          
          my $instances;
          if (defined($perf->{label_extra_instance}) && $perf->{label_extra_instance} == 1) {
              my $instance = '';
              if (defined($perf->{instance_use})) {
                  $instance = $self->{result_values}->{$perf->{instance_use}};
              } else {
                  $instance = $self->{instance};
              }
              
              if (!defined($options{extra_instance}) || $options{extra_instance} != 0 || $self->{output}->use_new_perfdata()) {
                  $instances = $instance;
              }
          }
  
          $self->{output}->perfdata_add(
              label => $label,
              instances => $instances,
              nlabel => $self->{nlabel},
              unit => $perf->{unit},
              value => $cast_int == 1 ? int($self->{result_values}->{$perf->{value}}) : sprintf($template, $self->{result_values}->{$perf->{value}}),
              warning => $self->{perfdata}->get_perfdata_for_output(label => $warn, total => $th_total, cast_int => $cast_int),
              critical => $self->{perfdata}->get_perfdata_for_output(label => $crit, total => $th_total, cast_int => $cast_int),
              min => $min, max => $max
          );
      }
  }
  
  sub execute {
      my ($self, %options) = @_;
      my $old_datas = {};
  
      $self->{result_values} = {},
      $self->{error_msg} = undef;
      my $quit = 0;
      my $per_second = 0;
      
      $options{new_datas} = {} if (!defined($options{new_datas}));
      foreach my $value (@{$self->{key_values}}) {
          if (!defined($options{values}->{$value->{name}}) || 
              defined($value->{no_value}) && $options{values}->{$value->{name}} eq $value->{no_value}) {
              $quit = 2;
              last;
          }
      
          if (defined($value->{diff}) && $value->{diff} == 1) {            
              $options{new_datas}->{$self->{instance} . '_' . $value->{name}} = $options{values}->{$value->{name}};
              $old_datas->{$self->{instance} . '_' . $value->{name}} = $self->{statefile}->get(name => $self->{instance} . '_' . $value->{name});
              if (!defined($old_datas->{$self->{instance} . '_' . $value->{name}})) {
                  $quit = 1;
                  next;
              }
              if ($old_datas->{$self->{instance} . '_' . $value->{name}} > $options{new_datas}->{$self->{instance} . '_' . $value->{name}}) {
                  $old_datas->{$self->{instance} . '_' . $value->{name}} = 0;
              }
          } else {
              $options{new_datas}->{$self->{instance} . '_' . $value->{name}} = $options{values}->{$value->{name}};
              if (defined($self->{statefile})) {
                  $old_datas->{$self->{instance} . '_' . $value->{name}} = $self->{statefile}->get(name => $self->{instance} . '_' . $value->{name});
              }
          }
      }
      
      # Very manual
      if ($self->{manual_keys} == 1) {
          foreach my $name (keys %{$options{values}}) {
              $options{new_datas}->{$self->{instance} . '_' . $name} = $options{values}->{$name};
              if (defined($self->{statefile})) {
                  $old_datas->{$self->{instance} . '_' . $name} = $self->{statefile}->get(name => $self->{instance} . '_' . $name);
              }
          }
      }
  
      if ($quit == 2) {
          $self->{error_msg} = "skipped (no value(s))";
          return -10;
      }
      
      if ($quit == 1) {
          $self->{error_msg} = "Buffer creation";
          return -1;
      }
      
      if (defined($self->{per_second}) && $self->{per_second} == 1) {
          if (!defined($self->{last_timestamp})) {
              $self->{last_timestamp} = $self->{statefile}->get(name => 'last_timestamp');
          }
          if (!defined($self->{last_timestamp})) {
              $self->{error_msg} = "Buffer creation";
              return -1;
          }
      }
     
      my $delta_time;
      if (defined($self->{per_second}) && $self->{per_second} == 1) {
          $delta_time = $options{new_datas}->{last_timestamp} - $self->{last_timestamp};
          if ($delta_time <= 0) {
              $delta_time = 1;
          }
      }
  
      if (defined($self->{closure_custom_calc})) {
          return $self->{closure_custom_calc}->($self, old_datas => $old_datas, new_datas => $options{new_datas}, delta_time => $delta_time, extra_options => $self->{closure_custom_calc_extra_options});
      }
      return $self->calc(old_datas => $old_datas, new_datas => $options{new_datas}, delta_time => $delta_time);
  }
  
  1;
  
  
CENTREON_PLUGINS_VALUES

$fatpacked{"network/cisco/standard/snmp/plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NETWORK_CISCO_STANDARD_SNMP_PLUGIN';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package network::cisco::standard::snmp::plugin;
  
  use strict;
  use warnings;
  use base qw(centreon::plugins::script_snmp);
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $self->{version} = '1.0';
      %{$self->{modes}} = (
          'arp'                  => 'snmp_standard::mode::arp',
          'configuration'        => 'centreon::common::cisco::standard::snmp::mode::configuration',
          'cpu'                  => 'centreon::common::cisco::standard::snmp::mode::cpu',
          'environment'          => 'centreon::common::cisco::standard::snmp::mode::environment',
          'hsrp'                 => 'centreon::common::cisco::standard::snmp::mode::hsrp',
          'interfaces'           => 'centreon::common::cisco::standard::snmp::mode::interfaces', 
          'ipsla'                => 'centreon::common::cisco::standard::snmp::mode::ipsla',
          'list-interfaces'      => 'snmp_standard::mode::listinterfaces',
          'list-spanning-trees'  => 'snmp_standard::mode::listspanningtrees',
          'memory'               => 'centreon::common::cisco::standard::snmp::mode::memory',
          'memory-flash'         => 'centreon::common::cisco::standard::snmp::mode::memoryflash',
          'qos-usage'            => 'centreon::common::cisco::standard::snmp::mode::qosusage',
          'spanning-tree'        => 'snmp_standard::mode::spanningtree',
          'stack'                => 'centreon::common::cisco::standard::snmp::mode::stack',
          'uptime'               => 'snmp_standard::mode::uptime',
      );
  
      return $self;
  }
  
  1;
  
  
  =head1 PLUGIN DESCRIPTION
  
  Check Cisco equipments (2800, 2900, 3750, Nexus,...) in SNMP.
  
  =cut
NETWORK_CISCO_STANDARD_SNMP_PLUGIN

$fatpacked{"snmp_standard/mode/interfaces.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_INTERFACES';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::interfaces;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::statefile;
  use Digest::MD5 qw(md5_hex);
  
  #########################
  # Calc functions
  #########################
  sub custom_threshold_output {
      my ($self, %options) = @_; 
      my $status = 'ok';
      my $message;
      
      eval {
          local $SIG{__WARN__} = sub { $message = $_[0]; };
          local $SIG{__DIE__} = sub { $message = $_[0]; };
          
          if (defined($self->{instance_mode}->{option_results}->{critical_status}) && $self->{instance_mode}->{option_results}->{critical_status} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{critical_status}") {
              $status = 'critical';
          } elsif (defined($self->{instance_mode}->{option_results}->{warning_status}) && $self->{instance_mode}->{option_results}->{warning_status} ne '' &&
                   eval "$self->{instance_mode}->{option_results}->{warning_status}") {
              $status = 'warning';
          }
          
          $self->{instance_mode}->{last_status} = 0;
          if (eval "$self->{instance_mode}->{check_status}") {
              $self->{instance_mode}->{last_status} = 1;
          }
      };
      if (defined($message)) {
          $self->{output}->output_add(long_msg => 'filter status issue: ' . $message);
      }
  
      return $status;
  }
  
  sub custom_status_output {
      my ($self, %options) = @_;
      my $msg = 'Status : ' . $self->{result_values}->{opstatus} . ' (admin: ' . $self->{result_values}->{admstatus} . ')';
      if (defined($self->{instance_mode}->{option_results}->{add_duplex_status})) {
          $msg .= ' (duplex: ' . $self->{result_values}->{duplexstatus} . ')';
      }
      
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
      
      $self->{result_values}->{opstatus} = $options{new_datas}->{$self->{instance} . '_opstatus'};
      $self->{result_values}->{admstatus} = $options{new_datas}->{$self->{instance} . '_admstatus'};
      $self->{result_values}->{duplexstatus} = $options{new_datas}->{$self->{instance} . '_duplexstatus'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  sub custom_cast_calc {
      my ($self, %options) = @_;
  
      return -10 if (defined($self->{instance_mode}->{last_status}) && $self->{instance_mode}->{last_status} == 0);
      if ($options{new_datas}->{$self->{instance} . '_mode_cast'} ne $options{old_datas}->{$self->{instance} . '_mode_cast'}) {
          $self->{error_msg} = "buffer creation";
          return -2;
      }
  
      my $diff_cast = ($options{new_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref}} - $options{old_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref}});
      my $total = $diff_cast
                  + ($options{new_datas}->{$self->{instance} . '_' . $options{extra_options}->{total_ref1}} - $options{old_datas}->{$self->{instance} . '_' . $options{extra_options}->{total_ref1}}) 
                  + ($options{new_datas}->{$self->{instance} . '_' . $options{extra_options}->{total_ref2}} - $options{old_datas}->{$self->{instance} . '_' . $options{extra_options}->{total_ref2}});
  
      if ($total == 0 && !defined($self->{instance_mode}->{option_results}->{no_skipped_counters})) {
          $self->{error_msg} = "skipped";
          return -2;
      }
      
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{$options{extra_options}->{label_ref} . '_prct'} = $total == 0 ? 0 : $diff_cast * 100 / $total;
      return 0;
  }
  
  ##############
  # Traffic
  sub custom_traffic_perfdata {
      my ($self, %options) = @_;
      
      if (defined($self->{instance_mode}->{option_results}->{nagvis_perfdata})) {
          $self->{result_values}->{traffic_per_seconds} /= 8;
          $self->{result_values}->{speed} /= 8 if (defined($self->{result_values}->{speed}));
      }
      
      my ($warning, $critical);
      if ($self->{instance_mode}->{option_results}->{units_traffic} eq '%' && defined($self->{result_values}->{speed})) {
          $warning = $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{label}, total => $self->{result_values}->{speed}, cast_int => 1);
          $critical = $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{label}, total => $self->{result_values}->{speed}, cast_int => 1);
      } elsif ($self->{instance_mode}->{option_results}->{units_traffic} eq 'b/s') {
          $warning = $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{label});
          $critical = $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{label});
      }
      
      if (defined($self->{instance_mode}->{option_results}->{nagvis_perfdata})) {
          $self->{output}->perfdata_add(
              label => $self->{result_values}->{label},
              instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
              value => sprintf("%.2f", $self->{result_values}->{traffic_per_seconds}),
              warning => $warning,
              critical => $critical,
              min => 0, max => $self->{result_values}->{speed}
          );
      } else {
          $self->{output}->perfdata_add(
              label => 'traffic_' . $self->{result_values}->{label}, unit => 'b/s',
              nlabel => $self->{nlabel},
              instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
              value => sprintf("%.2f", $self->{result_values}->{traffic_per_seconds}),
              warning => $warning,
              critical => $critical,
              min => 0, max => $self->{result_values}->{speed}
          );
      }
  }
  
  sub custom_traffic_threshold {
      my ($self, %options) = @_;
      
      my $exit = 'ok';
      if ($self->{instance_mode}->{option_results}->{units_traffic} eq '%' && defined($self->{result_values}->{speed})) {
          $exit = $self->{perfdata}->threshold_check(value => $self->{result_values}->{traffic_prct}, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      } elsif ($self->{instance_mode}->{option_results}->{units_traffic} eq 'b/s') {
          $exit = $self->{perfdata}->threshold_check(value => $self->{result_values}->{traffic_per_seconds}, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      }
      return $exit;
  }
  
  sub custom_traffic_output {
      my ($self, %options) = @_;
      
      my ($traffic_value, $traffic_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{traffic_per_seconds}, network => 1);    
      my $msg = sprintf("Traffic %s : %s/s (%s)",
                        ucfirst($self->{result_values}->{label}), $traffic_value . $traffic_unit,
                        defined($self->{result_values}->{traffic_prct}) ? sprintf("%.2f%%", $self->{result_values}->{traffic_prct}) : '-');
      return $msg;
  }
  
  sub custom_traffic_calc {
      my ($self, %options) = @_;
      
      return -10 if (defined($self->{instance_mode}->{last_status}) && $self->{instance_mode}->{last_status} == 0);
      if ($options{new_datas}->{$self->{instance} . '_mode_traffic'} ne $options{old_datas}->{$self->{instance} . '_mode_traffic'}) {
          $self->{error_msg} = "buffer creation";
          return -2;
      }
    
      my $diff_traffic = ($options{new_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref}} - $options{old_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref}});
      if ($diff_traffic == 0 && !defined($self->{instance_mode}->{option_results}->{no_skipped_counters})) {
          $self->{error_msg} = "skipped";
          return -2;
      }
      
      $self->{result_values}->{traffic_per_seconds} = $diff_traffic / $options{delta_time};
      if (defined($options{new_datas}->{$self->{instance} . '_speed_' . $options{extra_options}->{label_ref}}) && 
          $options{new_datas}->{$self->{instance} . '_speed_' . $options{extra_options}->{label_ref}} > 0) {
          $self->{result_values}->{traffic_prct} = $self->{result_values}->{traffic_per_seconds} * 100 / $options{new_datas}->{$self->{instance} . '_speed_' . $options{extra_options}->{label_ref}};
          $self->{result_values}->{speed} = $options{new_datas}->{$self->{instance} . '_speed_' . $options{extra_options}->{label_ref}};
      }
      
      $self->{result_values}->{label} = $options{extra_options}->{label_ref};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  ##############
  # Errors
  sub custom_errors_perfdata {
      my ($self, %options) = @_;
  
      if ($self->{instance_mode}->{option_results}->{units_errors} eq '%') {
          $self->{output}->perfdata_add(
              label => 'packets_' . $self->{result_values}->{label2} . '_' . $self->{result_values}->{label1}, unit => '%',
              nlabel => 'interface.packets.' . $self->{result_values}->{label1} . '.' . $self->{result_values}->{label2} . 's.percentage',
              instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
              value => sprintf("%.2f", $self->{result_values}->{prct}),
              warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{label}),
              critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{label}),
              min => 0, max => 100
          );
      } else {
          $self->{output}->perfdata_add(
              label => 'packets_' . $self->{result_values}->{label2} . '_' . $self->{result_values}->{label1},
              nlabel => $self->{nlabel},
              instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
              value => $self->{result_values}->{used},
              warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{label}),
              critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{label}),
              min => 0, max => $self->{result_values}->{total}
          );
      }
  }
  
  sub custom_errors_threshold {
      my ($self, %options) = @_;
      
      my $exit = 'ok';
      if ($self->{instance_mode}->{option_results}->{units_errors} eq '%') {
          $exit = $self->{perfdata}->threshold_check(value => $self->{result_values}->{prct}, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      } else {
          $exit = $self->{perfdata}->threshold_check(value => $self->{result_values}->{used}, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      }
      return $exit;
  }
  
  sub custom_errors_output {
      my ($self, %options) = @_;
      
      my $msg = sprintf("Packets %s : %.2f%% (%s)",
                        $self->{result_values}->{label},
                        $self->{result_values}->{prct}, $self->{result_values}->{used});
      return $msg;
  }
  
  sub custom_errors_calc {
      my ($self, %options) = @_;
  
      return -10 if (defined($self->{instance_mode}->{last_status}) && $self->{instance_mode}->{last_status} == 0);
      if ($options{new_datas}->{$self->{instance} . '_mode_cast'} ne $options{old_datas}->{$self->{instance} . '_mode_cast'}) {
          $self->{error_msg} = "buffer creation";
          return -2;
      }
      
      my $diff = ($options{new_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref1} . $options{extra_options}->{label_ref2}} - 
          $options{old_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref1} . $options{extra_options}->{label_ref2}});
      my $total = ($options{new_datas}->{$self->{instance} . '_total_' . $options{extra_options}->{label_ref1} . '_packets'} - 
          $options{old_datas}->{$self->{instance} . '_total_' . $options{extra_options}->{label_ref1} . '_packets'});
      if ($total == 0 && !defined($self->{instance_mode}->{option_results}->{no_skipped_counters})) {
          $self->{error_msg} = "skipped";
          return -2;
      }
      
      $self->{result_values}->{prct} = $total == 0 ? 0 : $diff * 100 / $total;
      $self->{result_values}->{used} = $diff;
      $self->{result_values}->{total} = $total;
      if (defined($options{extra_options}->{label})) {
          $self->{result_values}->{label} = $options{extra_options}->{label};
      } else {
          $self->{result_values}->{label} = ucfirst($options{extra_options}->{label_ref1}) . ' ' . ucfirst($options{extra_options}->{label_ref2});
      }
      $self->{result_values}->{label1} = $options{extra_options}->{label_ref1};
      $self->{result_values}->{label2} = $options{extra_options}->{label_ref2};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  sub custom_speed_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{speed} = $options{new_datas}->{$self->{instance} . '_speed'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  #########################
  # OIDs mapping functions
  #########################
  
  sub set_counters_global {
      my ($self, %options) = @_;
  
      push @{$self->{maps_counters}->{global}}, 
          { label => 'total-port', filter => 'add_global', nlabel => 'total.interfaces.count', set => {
                  key_values => [ { name => 'total_port' } ],
                  output_template => 'Total port : %s', output_error_template => 'Total port : %s',
                  output_use => 'total_port_absolute',  threshold_use => 'total_port_absolute',
                  perfdatas => [
                      { label => 'total_port', value => 'total_port_absolute', template => '%s',
                        min => 0, max => 'total_port_absolute' },
                 ],
              }
          },
          { label => 'global-admin-up', filter => 'add_global', nlabel => 'total.interfaces.admin.up.count', set => {
                  key_values => [ { name => 'global_admin_up' }, { name => 'total_port' } ],
                  output_template => 'AdminStatus Up : %s', output_error_template => 'AdminStatus Up : %s',
                  output_use => 'global_admin_up_absolute',  threshold_use => 'global_admin_up_absolute',
                  perfdatas => [
                      { label => 'total_admin_up', value => 'global_admin_up_absolute', template => '%s',
                        min => 0, max => 'total_port_absolute' },
                 ],
              }
          },
          { label => 'total-admin-down', filter => 'add_global', nlabel => 'total.interfaces.admin.down.count', set => {
                  key_values => [ { name => 'global_admin_down' }, { name => 'total_port' } ],
                  output_template => 'AdminStatus Down : %s', output_error_template => 'AdminStatus Down : %s',
                  output_use => 'global_admin_down_absolute',  threshold_use => 'global_admin_down_absolute',
                  perfdatas => [
                      { label => 'total_admin_down', value => 'global_admin_down_absolute', template => '%s',
                        min => 0, max => 'total_port_absolute' },
                 ],
              }
          },
          { label => 'total-oper-up', filter => 'add_global', nlabel => 'total.interfaces.operational.up.count', set => {
                  key_values => [ { name => 'global_oper_up' }, { name => 'total_port' } ],
                  output_template => 'OperStatus Up : %s', output_error_template => 'OperStatus Up : %s',
                  output_use => 'global_oper_up_absolute',  threshold_use => 'global_oper_up_absolute',
                  perfdatas => [
                      { label => 'total_oper_up', value => 'global_oper_up_absolute', template => '%s',
                        min => 0, max => 'total_port_absolute' },
                 ],
              }
          },
          { label => 'total-oper-down', filter => 'add_global', nlabel => 'total.interfaces.operational.down.count', set => {
                  key_values => [ { name => 'global_oper_down' }, { name => 'total_port' } ],
                  output_template => 'OperStatus Down : %s', output_error_template => 'OperStatus Down : %s',
                  output_use => 'global_oper_down_absolute',  threshold_use => 'global_oper_down_absolute',
                  perfdatas => [
                      { label => 'global_oper_down', value => 'global_oper_down_absolute', template => '%s',
                        min => 0, max => 'total_port_absolute' },
                 ],
              }
          },
      ;
  }
  
  sub set_counters_status {
      my ($self, %options) = @_;
  
      push @{$self->{maps_counters}->{int}}, 
          { label => 'status', filter => 'add_status', threshold => 0, set => {
                  key_values => $self->set_key_values_status(),
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => $self->can('custom_threshold_output'),
              }
          },
      ;
  }
  
  sub set_counters_traffic {
      my ($self, %options) = @_;
  
      return if ($self->{no_traffic} != 0 && $self->{no_set_traffic} != 0);
  
      push @{$self->{maps_counters}->{int}}, 
          { label => 'in-traffic', filter => 'add_traffic', nlabel => 'interface.traffic.in.bitspersecond', set => {
                  key_values => $self->set_key_values_in_traffic(),
                  per_second => 1,
                  closure_custom_calc => $self->can('custom_traffic_calc'), closure_custom_calc_extra_options => { label_ref => 'in' },
                  closure_custom_output => $self->can('custom_traffic_output'), output_error_template => 'Traffic In : %s',
                  closure_custom_perfdata => $self->can('custom_traffic_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_traffic_threshold'),
              }
          },
          { label => 'out-traffic', filter => 'add_traffic', nlabel => 'interface.traffic.out.bitspersecond', set => {
                  key_values => $self->set_key_values_out_traffic(),
                  per_second => 1,
                  closure_custom_calc => $self->can('custom_traffic_calc'), closure_custom_calc_extra_options => { label_ref => 'out' },
                  closure_custom_output => $self->can('custom_traffic_output'), output_error_template => 'Traffic Out : %s',
                  closure_custom_perfdata => $self->can('custom_traffic_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_traffic_threshold'),
              }
          },
      ;
  }
  
  sub set_counters_errors {
      my ($self, %options) = @_;
  
      return if ($self->{no_errors} != 0 && $self->{no_set_errors} != 0);
  
      push @{$self->{maps_counters}->{int}}, 
          { label => 'in-discard', filter => 'add_errors', nlabel => 'interface.packets.in.discards.count', set => {
                  key_values => [ { name => 'indiscard', diff => 1 }, { name => 'total_in_packets', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
                  closure_custom_calc => $self->can('custom_errors_calc'), closure_custom_calc_extra_options => { label_ref1 => 'in', label_ref2 => 'discard' },
                  closure_custom_output => $self->can('custom_errors_output'), output_error_template => 'Packets In Discard : %s',
                  closure_custom_perfdata => $self->can('custom_errors_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_errors_threshold'),
              }
          },
          { label => 'in-error', filter => 'add_errors', nlabel => 'interface.packets.in.errors.count', set => {
                  key_values => [ { name => 'inerror', diff => 1 }, { name => 'total_in_packets', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
                  closure_custom_calc => $self->can('custom_errors_calc'), closure_custom_calc_extra_options => { label_ref1 => 'in', label_ref2 => 'error' },
                  closure_custom_output => $self->can('custom_errors_output'), output_error_template => 'Packets In Error : %s',
                  closure_custom_perfdata => $self->can('custom_errors_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_errors_threshold'),
              }
          },
          { label => 'out-discard', filter => 'add_errors', nlabel => 'interface.packets.out.discards.count', set => {
                  key_values => [ { name => 'outdiscard', diff => 1 }, { name => 'total_out_packets', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
                  closure_custom_calc => $self->can('custom_errors_calc'), closure_custom_calc_extra_options => { label_ref1 => 'out', label_ref2 => 'discard' },
                  closure_custom_output => $self->can('custom_errors_output'), output_error_template => 'Packets Out Discard : %s',
                  closure_custom_perfdata => $self->can('custom_errors_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_errors_threshold'),
              }
          },
          { label => 'out-error', filter => 'add_errors', nlabel => 'interface.packets.out.errors.count', set => {
                  key_values => [ { name => 'outerror', diff => 1 }, { name => 'total_out_packets', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
                  closure_custom_calc => $self->can('custom_errors_calc'), closure_custom_calc_extra_options => { label_ref1 => 'out', label_ref2 => 'error' },
                  closure_custom_output => $self->can('custom_errors_output'), output_error_template => 'Packets Out Error : %s',
                  closure_custom_perfdata => $self->can('custom_errors_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_errors_threshold'),
              }
          },
      ;
  }
  
  sub set_counters_cast {
      my ($self, %options) = @_;
  
      return if ($self->{no_cast} != 0 && $self->{no_set_cast} != 0);
  
      push @{$self->{maps_counters}->{int}}, 
          { label => 'in-ucast', filter => 'add_cast', nlabel => 'interface.packets.in.unicast.count', set => {
                  key_values => [ { name => 'iucast', diff => 1 }, { name => 'imcast', diff => 1 }, { name => 'ibcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
                  closure_custom_calc => \&custom_cast_calc, closure_custom_calc_extra_options => { label_ref => 'iucast', total_ref1 => 'ibcast', total_ref2 => 'imcast' },
                  output_template => 'In Ucast : %.2f %%', output_error_template => 'In Ucast : %s',
                  output_use => 'iucast_prct',  threshold_use => 'iucast_prct',
                  perfdatas => [
                      { value => 'iucast_prct', template => '%.2f',
                        unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
          { label => 'in-bcast', filter => 'add_cast', nlabel => 'interface.packets.in.broadcast.count', set => {
                  key_values => [ { name => 'iucast', diff => 1 }, { name => 'imcast', diff => 1 }, { name => 'ibcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
                  closure_custom_calc => \&custom_cast_calc, closure_custom_calc_extra_options => { label_ref => 'ibcast', total_ref1 => 'iucast', total_ref2 => 'imcast' },
                  output_template => 'In Bcast : %.2f %%', output_error_template => 'In Bcast : %s',
                  output_use => 'ibcast_prct',  threshold_use => 'ibcast_prct',
                  perfdatas => [
                      { value => 'ibcast_prct', template => '%.2f',
                        unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
          { label => 'in-mcast', filter => 'add_cast', nlabel => 'interface.packets.in.multicast.count', set => {
                  key_values => [ { name => 'iucast', diff => 1 }, { name => 'imcast', diff => 1 }, { name => 'ibcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
                  closure_custom_calc => \&custom_cast_calc, closure_custom_calc_extra_options => { label_ref => 'imcast', total_ref1 => 'iucast', total_ref2 => 'ibcast' },
                  output_template => 'In Mcast : %.2f %%', output_error_template => 'In Mcast : %s',
                  output_use => 'imcast_prct',  threshold_use => 'imcast_prct',
                  perfdatas => [
                      { value => 'imcast_prct', template => '%.2f',
                        unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
          { label => 'out-ucast', filter => 'add_cast', nlabel => 'interface.packets.out.unicast.count', set => {
                  key_values => [ { name => 'oucast', diff => 1 }, { name => 'omcast', diff => 1 }, { name => 'obcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
                  closure_custom_calc => \&custom_cast_calc, closure_custom_calc_extra_options => { label_ref => 'oucast', total_ref1 => 'omcast', total_ref2 => 'obcast' },
                  output_template => 'Out Ucast : %.2f %%', output_error_template => 'Out Ucast : %s',
                  output_use => 'oucast_prct',  threshold_use => 'oucast_prct',
                  perfdatas => [
                      { value => 'oucast_prct', template => '%.2f',
                        unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
          { label => 'out-bcast', filter => 'add_cast', nlabel => 'interface.packets.out.broadcast.count', set => {
                  key_values => [ { name => 'oucast', diff => 1 }, { name => 'omcast', diff => 1 }, { name => 'obcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
                  closure_custom_calc => \&custom_cast_calc, closure_custom_calc_extra_options => { label_ref => 'obcast', total_ref1 => 'omcast', total_ref2 => 'oucast' },
                  output_template => 'Out Bcast : %.2f %%', output_error_template => 'Out Bcast : %s',
                  output_use => 'obcast_prct',  threshold_use => 'obcast_prct',
                  perfdatas => [
                      { value => 'obcast_prct', template => '%.2f',
                        unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
          { label => 'out-mcast', filter => 'add_cast', nlabel => 'interface.packets.out.multicast.count', set => {
                  key_values => [ { name => 'oucast', diff => 1 }, { name => 'omcast', diff => 1 }, { name => 'obcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
                  closure_custom_calc => \&custom_cast_calc, closure_custom_calc_extra_options => { label_ref => 'omcast', total_ref1 => 'oucast', total_ref2 => 'obcast' },
                  output_template => 'Out Mcast : %.2f %%', output_error_template => 'Out Mcast : %s',
                  output_use => 'omcast_prct',  threshold_use => 'omcast_prct',
                  perfdatas => [
                      { value => 'omcast_prct', template => '%.2f',
                        unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
      ;
  }
  
  sub set_counters_speed {
      my ($self, %options) = @_;
  
      return if ($self->{no_speed} != 0 && $self->{no_set_speed} != 0);
  
      push @{$self->{maps_counters}->{int}}, 
          { label => 'speed', filter => 'add_speed', nlabel => 'interface.speed.bitspersecond', set => {
                  key_values => [ { name => 'speed' }, { name => 'display' } ],
                  closure_custom_calc => $self->can('custom_speed_calc'),
                  output_template => 'Speed : %s%s/s', output_error_template => 'Speed : %s%s/s',
                  output_change_bytes => 2,
                  output_use => 'speed',  threshold_use => 'speed',
                  perfdatas => [
                      { value => 'speed', template => '%s',
                        unit => 'b/s', min => 0, label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
      ;
  }
  
  sub set_counters_volume {
      my ($self, %options) = @_;
  
      return if ($self->{no_volume} != 0 && $self->{no_set_volume} != 0);
  
      push @{$self->{maps_counters}->{int}}, 
          { label => 'in-volume', filter => 'add_volume', nlabel => 'interface.volume.in.bytes', set => {
                  key_values => [ { name => 'in_volume', diff => 1 }, { name => 'display' } ],
                  output_template => 'Volume In : %.2f %s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'volume_in', value => 'in_volume_absolute', template => '%s',
                        unit => 'B', min => 0, label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
          { label => 'out-volume', filter => 'add_volume', nlabel => 'interface.volume.out.bytes', set => {
                  key_values => [ { name => 'out_volume', diff => 1 }, { name => 'display' } ],
                  output_template => 'Volume Out : %.2f %s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'volume_out', value => 'out_volume_absolute', template => '%s',
                        unit => 'B', min => 0, label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
      ;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, cb_init => 'skip_global' },
          { name => 'int', type => 1, cb_init => 'skip_interface', cb_init_counters => 'skip_counters', cb_prefix_output => 'prefix_interface_output', message_multiple => 'All interfaces are ok', skipped_code => { -10 => 1 } },
      ];
  
      foreach (('traffic', 'errors', 'cast', 'speed', 'volume')) {
          $self->{'no_' . $_} = defined($options{'no_' . $_}) && $options{'no_' . $_} =~ /^[01]$/ ? $options{'no_' . $_} : 0;
          $self->{'no_set_' . $_} = defined($options{'no_set_' . $_}) && $options{'no_set_' . $_} =~ /^[01]$/ ? $options{'no_set_' . $_} : 0;
      }
  
      $self->{maps_counters} = { int => [], global => [] } if (!defined($self->{maps_counters}));
      $self->set_counters_global();
      $self->set_counters_status();
      $self->set_counters_traffic();
      $self->set_counters_errors();
      $self->set_counters_cast();
      $self->set_counters_speed();
      $self->set_counters_volume();
  }
  
  sub prefix_interface_output {
      my ($self, %options) = @_;
      
      return "Interface '" . $options{instance_value}->{display} . "'$options{instance_value}->{extra_display} "
  }
  
  sub skip_global {
      my ($self, %options) = @_;
  
      return (defined($self->{option_results}->{add_global}) ? 0 : 1);
  }
  
  sub skip_interface {
      my ($self, %options) = @_;
  
      return ($self->{checking} =~ /cast|errors|traffic|status|volume/ ? 0 : 1);
  }
  
  sub skip_counters {
      my ($self, %options) = @_;
  
      return (defined($self->{option_results}->{$options{filter}})) ? 0 : 1;
  }
  
  sub set_key_values_status {
      my ($self, %options) = @_;
  
      return [ { name => 'opstatus' }, { name => 'admstatus' }, { name => 'duplexstatus' }, { name => 'display' } ];
  }
  
  sub set_key_values_in_traffic {
      my ($self, %options) = @_;
      
      return [ { name => 'in', diff => 1 }, { name => 'speed_in'}, { name => 'display' }, { name => 'mode_traffic' } ];
  }
  
  sub set_key_values_out_traffic {
       my ($self, %options) = @_;
       
       return [ { name => 'out', diff => 1 }, { name => 'speed_out'}, { name => 'display' }, { name => 'mode_traffic' } ];
  }
  
  sub set_oids_label {
      my ($self, %options) = @_;
  
      $self->{oids_label} = {
          'ifdesc'  => { oid => '.1.3.6.1.2.1.2.2.1.2', cache => 'reload_cache_index_value' },
          'ifalias' => { oid => '.1.3.6.1.2.1.31.1.1.1.18', cache => 'reload_cache_index_value' },
          'ifname'  => { oid => '.1.3.6.1.2.1.31.1.1.1.1', cache => 'reload_cache_index_value', },
          'ipaddr'  => { oid => '.1.3.6.1.2.1.4.20.1.2',  cache => 'reload_cache_values_index', },
      };
  }
  
  sub set_oids_status {
      my ($self, %options) = @_;
      
      $self->{oid_adminstatus} = '.1.3.6.1.2.1.2.2.1.7';
      $self->{oid_adminstatus_mapping} = {
          1 => 'up', 2 => 'down', 3 => 'testing', 4 => 'unknown', 5 => 'dormant', 6 => 'notPresent', 7 => 'lowerLayerDown',
      };
      $self->{oid_opstatus} = '.1.3.6.1.2.1.2.2.1.8';
      $self->{oid_opstatus_mapping} = {
          1 => 'up', 2 => 'down', 3 => 'testing', 4 => 'unknown', 5 => 'dormant', 6 => 'notPresent', 7 => 'lowerLayerDown',
      };
      $self->{oid_duplexstatus} = '.1.3.6.1.2.1.10.7.2.1.19';
      $self->{oid_duplexstatus_mapping} = {
          1 => 'unknown', 2 => 'halfDuplex', 3 => 'fullDuplex',
      };
  }
  
  sub set_oids_errors {
      my ($self, %options) = @_;
      
      $self->{oid_ifInDiscards} = '.1.3.6.1.2.1.2.2.1.13';
      $self->{oid_ifInErrors} = '.1.3.6.1.2.1.2.2.1.14';
      $self->{oid_ifOutDiscards} = '.1.3.6.1.2.1.2.2.1.19';
      $self->{oid_ifOutErrors} = '.1.3.6.1.2.1.2.2.1.20';
  }
  
  sub set_oids_traffic {
      my ($self, %options) = @_;
      
      $self->{oid_speed32} = '.1.3.6.1.2.1.2.2.1.5'; # in b/s
      $self->{oid_in32} = '.1.3.6.1.2.1.2.2.1.10'; # in B
      $self->{oid_out32} = '.1.3.6.1.2.1.2.2.1.16'; # in B
      $self->{oid_speed64} = '.1.3.6.1.2.1.31.1.1.1.15'; # need multiple by '1000000'
      $self->{oid_in64} = '.1.3.6.1.2.1.31.1.1.1.6'; # in B
      $self->{oid_out64} = '.1.3.6.1.2.1.31.1.1.1.10'; # in B
  }
  
  sub set_oids_cast {
      my ($self, %options) = @_;
      
      # 32bits
      $self->{oid_ifInUcastPkts} = '.1.3.6.1.2.1.2.2.1.11';
      $self->{oid_ifInBroadcastPkts} = '.1.3.6.1.2.1.31.1.1.1.3';
      $self->{oid_ifInMulticastPkts} = '.1.3.6.1.2.1.31.1.1.1.2';
      $self->{oid_ifOutUcastPkts} = '.1.3.6.1.2.1.2.2.1.17';
      $self->{oid_ifOutMulticastPkts} = '.1.3.6.1.2.1.31.1.1.1.4';
      $self->{oid_ifOutBroadcastPkts} = '.1.3.6.1.2.1.31.1.1.1.5';
      
      # 64 bits
      $self->{oid_ifHCInUcastPkts} = '.1.3.6.1.2.1.31.1.1.1.7';
      $self->{oid_ifHCInMulticastPkts} = '.1.3.6.1.2.1.31.1.1.1.8';
      $self->{oid_ifHCInBroadcastPkts} = '.1.3.6.1.2.1.31.1.1.1.9';
      $self->{oid_ifHCOutUcastPkts} = '.1.3.6.1.2.1.31.1.1.1.11';
      $self->{oid_ifHCOutMulticastPkts} = '.1.3.6.1.2.1.31.1.1.1.12';
      $self->{oid_ifHCOutBroadcastPkts} = '.1.3.6.1.2.1.31.1.1.1.13';
  }
  
  sub set_oids_speed {
      my ($self, %options) = @_;
      
      $self->{oid_speed32} = '.1.3.6.1.2.1.2.2.1.5'; # in b/s
      $self->{oid_speed64} = '.1.3.6.1.2.1.31.1.1.1.15'; # need multiple by '1000000'
  }
  
  sub check_oids_label {
      my ($self, %options) = @_;
      
      foreach (('oid_filter', 'oid_display')) {
          $self->{option_results}->{$_} = lc($self->{option_results}->{$_}) if (defined($self->{option_results}->{$_}));
          if (!defined($self->{oids_label}->{$self->{option_results}->{$_}}->{oid})) {
              my $label = $_;
              $label =~ s/_/-/g;
              $self->{output}->add_option_msg(short_msg => "Unsupported oid in --" . $label . " option.");
              $self->{output}->option_exit();
          }
      }
      
      if (defined($self->{option_results}->{oid_extra_display})) {
          $self->{option_results}->{oid_extra_display} = lc($self->{option_results}->{oid_extra_display});
          if (!defined($self->{oids_label}->{$self->{option_results}->{oid_extra_display}}->{oid})) {
              $self->{output}->add_option_msg(short_msg => "Unsupported oid in --oid-extra-display option.");
              $self->{output}->option_exit();
          }
      }
  }
  
  sub default_check_status {
      my ($self, %options) = @_;
      
      return '%{opstatus} eq "up"';
  }
  
  sub default_warning_status {
      my ($self, %options) = @_;
      
      return '';
  }
  
  sub default_critical_status {
      my ($self, %options) = @_;
      
      return '%{admstatus} eq "up" and %{opstatus} ne "up"';
  }
  
  sub default_global_admin_up_rule {
      my ($self, %options) = @_;
      
      return '%{admstatus} eq "up"';
  }
  
  sub default_global_admin_down_rule {
      my ($self, %options) = @_;
      
      return '%{admstatus} ne "up"';
  }
  
  sub default_global_oper_up_rule {
      my ($self, %options) = @_;
      
      return '%{opstatus} eq "up"';
  }
  
  sub default_global_oper_down_rule {
      my ($self, %options) = @_;
      
      return '%{opstatus} ne "up"';
  }
  
  sub default_oid_filter_name {
      my ($self, %options) = @_;
      
      return 'ifname';
  }
  
  sub default_oid_display_name {
      my ($self, %options) = @_;
      
      return 'ifname';
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => defined($options{package}) ? $options{package} : __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
  
      $self->{no_oid_options} = defined($options{no_oid_options}) && $options{no_oid_options} =~ /^[01]$/ ? $options{no_oid_options} : 0;
      $self->{no_interfaceid_options} = defined($options{no_interfaceid_options}) && $options{no_interfaceid_options} =~ /^[01]$/ ? 
          $options{no_interfaceid_options} : 0;
  
      $options{options}->add_options(arguments => {
          'add-global'              => { name => 'add_global' },
          'add-status'              => { name => 'add_status' },
          'add-duplex-status'       => { name => 'add_duplex_status' },
          'warning-status:s'        => { name => 'warning_status', default => $self->default_warning_status() },
          'critical-status:s'       => { name => 'critical_status', default => $self->default_critical_status() },
          'global-admin-up-rule:s'    => { name => 'global_admin_up_rule', default => $self->default_global_admin_up_rule() },
          'global-oper-up-rule:s'     => { name => 'global_oper_up_rule', default => $self->default_global_oper_up_rule() },
          'global-admin-down-rule:s'  => { name => 'global_admin_down_rule', default => $self->default_global_admin_down_rule() },
          'global-oper-down-rule:s'   => { name => 'global_oper_down_rule', default => $self->default_global_oper_down_rule() },
          'interface:s'             => { name => 'interface' },
          'units-traffic:s'         => { name => 'units_traffic', default => '%' },
          'units-errors:s'          => { name => 'units_errors', default => '%' },
          'speed:s'                 => { name => 'speed' },
          'speed-in:s'              => { name => 'speed_in' },
          'speed-out:s'             => { name => 'speed_out' },
          'no-skipped-counters'     => { name => 'no_skipped_counters' },
          'display-transform-src:s' => { name => 'display_transform_src' },
          'display-transform-dst:s' => { name => 'display_transform_dst' },
          'show-cache'              => { name => 'show_cache' },
          'reload-cache-time:s'     => { name => 'reload_cache_time', default => 180 },
          'nagvis-perfdata'         => { name => 'nagvis_perfdata' },
          'force-counters32'        => { name => 'force_counters32' },
      });
      if ($self->{no_traffic} == 0) {
          $options{options}->add_options(arguments => { 'add-traffic' => { name => 'add_traffic' } });
      }
      if ($self->{no_errors} == 0) {
          $options{options}->add_options(arguments => { 'add-errors' => { name => 'add_errors' } });
      }
      if ($self->{no_cast} == 0) {
          $options{options}->add_options(arguments => { 'add-cast' => { name => 'add_cast' }, });
      }
      if ($self->{no_speed} == 0) {
          $options{options}->add_options(arguments => { 'add-speed' => { name => 'add_speed' }, });
      }
      if ($self->{no_volume} == 0) {
          $options{options}->add_options(arguments => { 'add-volume' => { name => 'add_volume' }, });
      }
      if ($self->{no_oid_options} == 0) {
          $options{options}->add_options(arguments => {
              'oid-filter:s'            => { name => 'oid_filter', default => $self->default_oid_filter_name() },
              'oid-display:s'           => { name => 'oid_display', default => $self->default_oid_display_name() },
              'oid-extra-display:s'     => { name => 'oid_extra_display' },
          });
      }
      if ($self->{no_interfaceid_options} == 0) {
          $options{options}->add_options(arguments => {
              'name'  => { name => 'use_name' },
          });
      }
      
      $self->{statefile_cache} = centreon::plugins::statefile->new(%options);
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->set_oids_label();
      $self->check_oids_label();
      
      $self->{statefile_cache}->check_options(%options);
      
      if (defined($self->{option_results}->{add_traffic}) && 
          (!defined($self->{option_results}->{units_traffic}) || $self->{option_results}->{units_traffic} !~ /^(%|b\/s)$/)) {
          $self->{output}->add_option_msg(short_msg => 'Wrong option --units-traffic.');
          $self->{output}->option_exit();
      }
      if (defined($self->{option_results}->{add_errors}) && 
          (!defined($self->{option_results}->{units_errors}) || $self->{option_results}->{units_errors} !~ /^(%|absolute|b\/s)$/)) {
          $self->{output}->add_option_msg(short_msg => 'Wrong option --units-errors.');
          $self->{output}->option_exit();
      }
      
      $self->{get_speed} = 0;
      if ((!defined($self->{option_results}->{speed}) || $self->{option_results}->{speed} eq '') &&
          ((!defined($self->{option_results}->{speed_in}) || $self->{option_results}->{speed_in} eq '') ||
          (!defined($self->{option_results}->{speed_out}) || $self->{option_results}->{speed_out} eq ''))) {
          $self->{get_speed} = 1;
      } elsif (defined($self->{option_results}->{add_speed})) {
          $self->{output}->add_option_msg(short_msg => 'Cannot use option --add-speed with --speed, --speed-in or --speed-out options.');
          $self->{output}->option_exit();
      }
      
      # If no options, we set status
      if (!defined($self->{option_results}->{add_global}) &&
          !defined($self->{option_results}->{add_status}) && !defined($self->{option_results}->{add_traffic}) &&
          !defined($self->{option_results}->{add_errors}) && !defined($self->{option_results}->{add_cast})) {
          $self->{option_results}->{add_status} = 1;
      }
      $self->{checking} = '';
      foreach (('add_global', 'add_status', 'add_errors', 'add_traffic', 'add_cast', 'add_speed', 'add_volume')) {
          if (defined($self->{option_results}->{$_})) {
              $self->{checking} .= $_;
          }
      }
      
      $self->change_macros(macros => ['warning_status', 'critical_status']);
      $self->{check_status} = $self->default_check_status();
      $self->{check_status} =~ s/%\{(.*?)\}/\$self->{result_values}->{$1}/g;
  }
  
  sub get_display_value {
      my ($self, %options) = @_;
      my $value = $self->{statefile_cache}->get(name => $self->{option_results}->{oid_display} . "_" . $options{id});
  
      if (defined($self->{option_results}->{display_transform_src})) {
          $self->{option_results}->{display_transform_dst} = '' if (!defined($self->{option_results}->{display_transform_dst}));
          eval "\$value =~ s{$self->{option_results}->{display_transform_src}}{$self->{option_results}->{display_transform_dst}}";
      }
      return $value;
  }
  
  sub check_oids_options_change {
      my ($self, %options) = @_;
      
      my ($regexp, $regexp_append) = ('', '');
      foreach (('oid_display', 'oid_filter', 'oid_extra_display')) {
          if (my $value = $self->{statefile_cache}->get(name => $_)) {
              $regexp .= $regexp_append . $value;
              $regexp_append = '|';
          }
      }
      foreach (('oid_display', 'oid_filter', 'oid_extra_display')) {
          if (defined($self->{option_results}->{$_}) && $self->{option_results}->{$_} !~ /^($regexp)$/i) {
              return 1;
          }
      }
      return 0;
  }
  
  sub reload_cache_index_value {
      my ($self, %options) = @_;
      
      my $store_index = defined($options{store_index}) && $options{store_index} == 1 ? 1 : 0;
      foreach ($self->{snmp}->oid_lex_sort(keys %{$options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }})) {
          /^$self->{oids_label}->{$options{name}}->{oid}\.(.*)$/;
          push @{$options{datas}->{all_ids}}, $1 if ($store_index == 1);
          $options{datas}->{$options{name} . "_" . $1} = $self->{output}->to_utf8($options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }->{$_});
      }
  }
  
  sub reload_cache_values_index {
      my ($self, %options) = @_;
      
      my $store_index = defined($options{store_index}) && $options{store_index} == 1 ? 1 : 0;
      foreach ($self->{snmp}->oid_lex_sort(keys %{$options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }})) {
          /^$self->{oids_label}->{$options{name}}->{oid}\.(.*)$/;
          push @{$options{datas}->{all_ids}}, $options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }->{$_} if ($store_index == 1);
          if (defined($options{datas}->{$options{name} . "_" . $options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }->{$_}})) {
              $options{datas}->{$options{name} . "_" . $options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }->{$_}} .= ', ' . $1;
          } else {
              $options{datas}->{$options{name} . "_" . $options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }->{$_}} = $1;
          }
      }
  }
  
  sub reload_cache {
      my ($self) = @_;
      my $datas = {};
  
      $datas->{oid_filter} = $self->{option_results}->{oid_filter};
      $datas->{oid_display} = $self->{option_results}->{oid_display};
      $datas->{oid_extra_display} = $self->{option_results}->{oid_extra_display};
      $datas->{last_timestamp} = time();
      $datas->{all_ids} = [];
      
      my $snmp_get = [
          { oid => $self->{oids_label}->{$self->{option_results}->{oid_filter}}->{oid} },
      ];
      if ($self->{option_results}->{oid_filter} ne $self->{option_results}->{oid_display}) {
          push @{$snmp_get}, { oid => $self->{oids_label}->{$self->{option_results}->{oid_display}}->{oid} };
      }
      if (defined($self->{option_results}->{oid_extra_display}) && $self->{option_results}->{oid_extra_display} ne $self->{option_results}->{oid_display} && 
          $self->{option_results}->{oid_extra_display} ne $self->{option_results}->{oid_filter}) {
          push @{$snmp_get}, { oid => $self->{oids_label}->{$self->{option_results}->{oid_extra_display}}->{oid} };
      }    
      
      my $result = $self->{snmp}->get_multiple_table(oids => $snmp_get);
      
      my $func = $self->can($self->{oids_label}->{$self->{option_results}->{oid_filter}}->{cache});
      $func->($self, result => $result, datas => $datas, name => $self->{option_results}->{oid_filter}, store_index => 1);
  
      if (scalar(@{$datas->{all_ids}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "Can't construct cache...");
          $self->{output}->option_exit();
      }
  
      if ($self->{option_results}->{oid_filter} ne $self->{option_results}->{oid_display}) {
          $func = $self->can($self->{oids_label}->{$self->{option_results}->{oid_display}}->{cache});
          $func->($self, result => $result, datas => $datas, name => $self->{option_results}->{oid_display});
      }
      if (defined($self->{option_results}->{oid_extra_display}) && $self->{option_results}->{oid_extra_display} ne $self->{option_results}->{oid_display} && 
          $self->{option_results}->{oid_extra_display} ne $self->{option_results}->{oid_filter}) {
          $func = $self->can($self->{oids_label}->{$self->{option_results}->{oid_extra_display}}->{cache});
          $func->($self, result => $result, datas => $datas, name => $self->{option_results}->{oid_extra_display});
      }
      
      $self->{statefile_cache}->write(data => $datas);
  }
  
  sub add_selected_interface {
      my ($self, %options) = @_;
      
      $self->{int}->{$options{id}} = { display => $self->get_display_value(id => $options{id}), extra_display => '' };
      if (defined($self->{option_results}->{oid_extra_display})) {
           $self->{int}->{$options{id}}->{extra_display} = ' [ ' . $self->{statefile_cache}->get(name => $self->{option_results}->{oid_extra_display} . "_" . $options{id}) . ' ]';
      }
  }
  
  sub get_selection {
      my ($self, %options) = @_;
      
      # init cache file
      my $has_cache_file = $self->{statefile_cache}->read(statefile => 'cache_snmpstandard_' . $self->{snmp}->get_hostname()  . '_' . $self->{snmp}->get_port() . '_' . $self->{mode});
      if (defined($self->{option_results}->{show_cache})) {
          $self->{output}->add_option_msg(long_msg => $self->{statefile_cache}->get_string_content());
          $self->{output}->option_exit();
      }
  
      $self->{int} = {};
      my $timestamp_cache = $self->{statefile_cache}->get(name => 'last_timestamp');
      
      if ($has_cache_file == 0 || $self->check_oids_options_change() ||
          !defined($timestamp_cache) || ((time() - $timestamp_cache) > (($self->{option_results}->{reload_cache_time}) * 60))) {
          $self->reload_cache();
          $self->{statefile_cache}->read();
      }
  
      my $all_ids = $self->{statefile_cache}->get(name => 'all_ids');
      if (!defined($self->{option_results}->{use_name}) && defined($self->{option_results}->{interface}) 
          && $self->{no_interfaceid_options} == 0) {
          foreach (@{$all_ids}) {
              if ($self->{option_results}->{interface} =~ /(^|\s|,)$_(\s*,|$)/) {
                  $self->add_selected_interface(id => $_);
              }
          }
      } else {
          foreach (@{$all_ids}) {
              my $filter_name = $self->{statefile_cache}->get(name => $self->{option_results}->{oid_filter} . "_" . $_);
              next if (!defined($filter_name));
              if (!defined($self->{option_results}->{interface})) {
                  $self->add_selected_interface(id => $_);
                  next;
              }
              if ($filter_name =~ /$self->{option_results}->{interface}/) {
                  $self->add_selected_interface(id => $_);
              }
          }
      }
      
      if (scalar(keys %{$self->{int}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No entry found (maybe you should reload cache file)");
          $self->{output}->option_exit();
      }
  }
  
  sub load_status {
      my ($self, %options) = @_;
      
      $self->set_oids_status();
      my $oids = [$self->{oid_adminstatus}, $self->{oid_opstatus}];
      if (defined($self->{option_results}->{add_duplex_status})) {
          push @$oids, $self->{oid_duplexstatus};
      }
      
      $self->{snmp}->load(oids => $oids, instances => $self->{array_interface_selected});
  }
  
  sub load_traffic {
      my ($self, %options) = @_;
      
      $self->set_oids_traffic();
      $self->{snmp}->load(oids => [$self->{oid_in32}, $self->{oid_out32}], instances => $self->{array_interface_selected});
      if ($self->{get_speed} == 1) {
          $self->{snmp}->load(oids => [$self->{oid_speed32}], instances => $self->{array_interface_selected});
      }
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          $self->{snmp}->load(oids => [$self->{oid_in64}, $self->{oid_out64}], instances => $self->{array_interface_selected});
          if ($self->{get_speed} == 1) {
              $self->{snmp}->load(oids => [$self->{oid_speed64}], instances => $self->{array_interface_selected});
          }
      }
  }
  
  sub load_errors {
      my ($self, %options) = @_;
      
      $self->set_oids_errors();
      $self->{snmp}->load(oids => [$self->{oid_ifInDiscards}, $self->{oid_ifInErrors},
                                   $self->{oid_ifOutDiscards}, $self->{oid_ifOutErrors}], instances => $self->{array_interface_selected});
  }
  
  sub load_cast {
      my ($self, %options) = @_;
  
      $self->set_oids_cast();    
      $self->{snmp}->load(oids => [$self->{oid_ifInUcastPkts}, $self->{oid_ifInBroadcastPkts}, $self->{oid_ifInMulticastPkts},
                                   $self->{oid_ifOutUcastPkts}, $self->{oid_ifOutMulticastPkts}, $self->{oid_ifOutBroadcastPkts}],
                          instances => $self->{array_interface_selected});
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          $self->{snmp}->load(oids => [$self->{oid_ifHCInUcastPkts}, $self->{oid_ifHCInMulticastPkts}, $self->{oid_ifHCInBroadcastPkts},
                                       $self->{oid_ifHCOutUcastPkts}, $self->{oid_ifHCOutMulticastPkts}, $self->{oid_ifHCOutBroadcastPkts}],
                              instances => $self->{array_interface_selected});
      }
  }
  
  sub load_speed {
      my ($self, %options) = @_;
      
      $self->set_oids_speed();
      $self->{snmp}->load(oids => [$self->{oid_speed32}], instances => $self->{array_interface_selected});
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          $self->{snmp}->load(oids => [$self->{oid_speed64}], instances => $self->{array_interface_selected});
      }
  }
  
  sub load_volume {
      my ($self, %options) = @_;
      
      $self->set_oids_traffic();
      $self->{snmp}->load(oids => [$self->{oid_in32}, $self->{oid_out32}], instances => $self->{array_interface_selected});
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          $self->{snmp}->load(oids => [$self->{oid_in64}, $self->{oid_out64}], instances => $self->{array_interface_selected});
      }
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $custom_load_method = $self->can('custom_load');
      my $custom_add_result_method = $self->can('custom_add_result');
  
      $self->get_selection();
      $self->{array_interface_selected} = [keys %{$self->{int}}];    
      $self->load_status() if (defined($self->{option_results}->{add_status}) || defined($self->{option_results}->{add_global}));
      $self->load_errors() if (defined($self->{option_results}->{add_errors}));
      $self->load_traffic() if (defined($self->{option_results}->{add_traffic}));
      $self->load_cast() if ($self->{no_cast} == 0 && (defined($self->{option_results}->{add_cast}) || defined($self->{option_results}->{add_errors})));
      $self->load_speed() if (defined($self->{option_results}->{add_speed}));
      $self->load_volume() if (defined($self->{option_results}->{add_volume}));
      $self->$custom_load_method() if ($custom_load_method);
  
      $self->{results} = $self->{snmp}->get_leef();
      
      $self->add_result_global() if (defined($self->{option_results}->{add_global}));    
      foreach (@{$self->{array_interface_selected}}) {
          $self->add_result_status(instance => $_) if (defined($self->{option_results}->{add_status}));
          $self->add_result_traffic(instance => $_) if (defined($self->{option_results}->{add_traffic}));
          $self->add_result_cast(instance => $_) if ($self->{no_cast} == 0 && (defined($self->{option_results}->{add_cast}) || defined($self->{option_results}->{add_errors})));
          $self->add_result_errors(instance => $_) if (defined($self->{option_results}->{add_errors}));
          $self->add_result_speed(instance => $_) if (defined($self->{option_results}->{add_speed}));
          $self->add_result_volume(instance => $_) if (defined($self->{option_results}->{add_volume}));
          $self->$custom_add_result_method(instance => $_) if ($custom_add_result_method);
      }
  
      $self->{cache_name} = 'snmpstandard_' . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all')) . '_' .
          (defined($self->{option_results}->{interface}) ? md5_hex($self->{option_results}->{interface}) : md5_hex('all')) . '_' .
          md5_hex($self->{checking});
  }
  
  sub add_result_global {
      my ($self, %options) = @_;
      
      foreach (('global_admin_up_rule', 'global_admin_down_rule', 'global_oper_up_rule', 'global_oper_down_rule')) {
          if (defined($self->{option_results}->{$_})) {
              $self->{option_results}->{$_} =~ s/%\{(.*?)\}/\$$1/g;
          }
      }
      
      $self->{global} = { total_port => 0, global_admin_up => 0, global_admin_down => 0,
                          global_oper_up => 0, global_oper_down => 0};
      foreach (@{$self->{array_interface_selected}}) {
          my $opstatus = $self->{oid_opstatus_mapping}->{$self->{results}->{$self->{oid_opstatus} . '.' . $_}};
          my $admstatus = $self->{oid_adminstatus_mapping}->{$self->{results}->{$self->{oid_adminstatus} . '.' . $_}};
          foreach (('global_admin_up', 'global_admin_down', 'global_oper_up', 'global_oper_down')) {
              eval {
                  local $SIG{__WARN__} = sub { return ; };
                  local $SIG{__DIE__} = sub { return ; };
          
                  if (defined($self->{option_results}->{$_ . '_rule'}) && $self->{option_results}->{$_ . '_rule'} ne '' &&
                      eval "$self->{option_results}->{$_ . '_rule'}") {
                      $self->{global}->{$_}++;
                  }
              };
          }
          $self->{global}->{total_port}++;
      }
  }
  
  sub add_result_status {
      my ($self, %options) = @_;
      
      $self->{int}->{$options{instance}}->{opstatus} = defined($self->{results}->{$self->{oid_opstatus} . '.' . $options{instance}}) ? $self->{oid_opstatus_mapping}->{$self->{results}->{$self->{oid_opstatus} . '.' . $options{instance}}} : undef;
      $self->{int}->{$options{instance}}->{admstatus} = defined($self->{results}->{$self->{oid_adminstatus} . '.' . $options{instance}}) ? $self->{oid_adminstatus_mapping}->{$self->{results}->{$self->{oid_adminstatus} . '.' . $options{instance}}} : undef;
      $self->{int}->{$options{instance}}->{duplexstatus} = defined($self->{results}->{$self->{oid_duplexstatus} . '.' . $options{instance}}) ? $self->{oid_duplexstatus_mapping}->{$self->{results}->{$self->{oid_duplexstatus} . '.' . $options{instance}}} : 'n/a';
  }
  
  sub add_result_errors {
      my ($self, %options) = @_;
      
      $self->{int}->{$options{instance}}->{indiscard} = $self->{results}->{$self->{oid_ifInDiscards} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{inerror} = $self->{results}->{$self->{oid_ifInErrors} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{outdiscard} = $self->{results}->{$self->{oid_ifOutDiscards} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{outerror} = $self->{results}->{$self->{oid_ifOutErrors} . '.' . $options{instance}};
  }
  
  sub add_result_traffic {
      my ($self, %options) = @_;
      
      $self->{int}->{$options{instance}}->{mode_traffic} = 32;
      $self->{int}->{$options{instance}}->{in} = $self->{results}->{$self->{oid_in32} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{out} = $self->{results}->{$self->{oid_out32} . '.' . $options{instance}};
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          if (defined($self->{results}->{$self->{oid_in64} . '.' . $options{instance}}) && $self->{results}->{$self->{oid_in64} . '.' . $options{instance}} ne '' &&
              $self->{results}->{$self->{oid_in64} . '.' . $options{instance}} != 0) {
              $self->{int}->{$options{instance}}->{mode_traffic} = 64;
              $self->{int}->{$options{instance}}->{in} = $self->{results}->{$self->{oid_in64} . '.' . $options{instance}};
              $self->{int}->{$options{instance}}->{out} = $self->{results}->{$self->{oid_out64} . '.' . $options{instance}};
          }
      }
      $self->{int}->{$options{instance}}->{in} *= 8 if (defined($self->{int}->{$options{instance}}->{in}));
      $self->{int}->{$options{instance}}->{out} *= 8 if (defined($self->{int}->{$options{instance}}->{out}));
      
      $self->{int}->{$options{instance}}->{speed_in} = 0;
      $self->{int}->{$options{instance}}->{speed_out} = 0;
      if ($self->{get_speed} == 0) {
          if (defined($self->{option_results}->{speed}) && $self->{option_results}->{speed} ne '') {
              $self->{int}->{$options{instance}}->{speed_in} = $self->{option_results}->{speed} * 1000000;
              $self->{int}->{$options{instance}}->{speed_out} = $self->{option_results}->{speed} * 1000000;
          }
          $self->{int}->{$options{instance}}->{speed_in} = $self->{option_results}->{speed_in} * 1000000 if (defined($self->{option_results}->{speed_in}) && $self->{option_results}->{speed_in} ne '');
          $self->{int}->{$options{instance}}->{speed_out} = $self->{option_results}->{speed_out} * 1000000 if (defined($self->{option_results}->{speed_out}) && $self->{option_results}->{speed_out} ne '');
      } else {
          my $interface_speed = 0;
          if (defined($self->{results}->{$self->{oid_speed64} . "." . $options{instance}}) && $self->{results}->{$self->{oid_speed64} . "." . $options{instance}} ne '') {
              $interface_speed = $self->{results}->{$self->{oid_speed64} . "." . $options{instance}} * 1000000;
              # If 0, we put the 32 bits
              if ($interface_speed == 0) {
                  $interface_speed = $self->{results}->{$self->{oid_speed32} . "." . $options{instance}};
              }
          } else {
              $interface_speed = $self->{results}->{$self->{oid_speed32} . "." . $options{instance}};
          }
          
          $self->{int}->{$options{instance}}->{speed_in} = $interface_speed;
          $self->{int}->{$options{instance}}->{speed_out} = $interface_speed;
          $self->{int}->{$options{instance}}->{speed_in} = $self->{option_results}->{speed_in} * 1000000 if (defined($self->{option_results}->{speed_in}) && $self->{option_results}->{speed_in} ne '');
          $self->{int}->{$options{instance}}->{speed_out} = $self->{option_results}->{speed_out} * 1000000 if (defined($self->{option_results}->{speed_out}) && $self->{option_results}->{speed_out} ne '');
      }
  }
      
  sub add_result_cast {
      my ($self, %options) = @_;
      
      $self->{int}->{$options{instance}}->{mode_cast} = 32;
      $self->{int}->{$options{instance}}->{iucast} = $self->{results}->{$self->{oid_ifInUcastPkts} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{ibcast} = defined($self->{results}->{$self->{oid_ifInBroadcastPkts} . '.' . $options{instance}}) ? $self->{results}->{$self->{oid_ifInBroadcastPkts} . '.' . $options{instance}} : 0;
      $self->{int}->{$options{instance}}->{imcast} = defined($self->{results}->{$self->{oid_ifInMulticastPkts} . '.' . $options{instance}}) ? $self->{results}->{$self->{oid_ifInMulticastPkts} . '.' . $options{instance}} : 0;
      $self->{int}->{$options{instance}}->{oucast} = $self->{results}->{$self->{oid_ifOutUcastPkts} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{omcast} = defined($self->{results}->{$self->{oid_ifOutMulticastPkts} . '.' . $options{instance}}) ? $self->{results}->{$self->{oid_ifOutMulticastPkts} . '.' . $options{instance}} : 0;
      $self->{int}->{$options{instance}}->{obcast} = defined($self->{results}->{$self->{oid_ifOutBroadcastPkts} . '.' . $options{instance}}) ? $self->{results}->{$self->{oid_ifOutBroadcastPkts} . '.' . $options{instance}} : 0;
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          my $iucast = $self->{results}->{$self->{oid_ifHCInUcastPkts} . '.' . $options{instance}};
          if (defined($iucast) && $iucast =~ /[1-9]/) {
              $self->{int}->{$options{instance}}->{iucast} = $iucast;
              $self->{int}->{$options{instance}}->{imcast} = defined($self->{results}->{$self->{oid_ifHCInMulticastPkts} . '.' . $options{instance}}) ? $self->{results}->{$self->{oid_ifHCInMulticastPkts} . '.' . $options{instance}} : 0;
              $self->{int}->{$options{instance}}->{ibcast} = defined($self->{results}->{$self->{oid_ifHCInBroadcastPkts} . '.' . $options{instance}}) ? $self->{results}->{$self->{oid_ifHCInBroadcastPkts} . '.' . $options{instance}} : 0;
              $self->{int}->{$options{instance}}->{oucast} = $self->{results}->{$self->{oid_ifHCOutUcastPkts} . '.' . $options{instance}};
              $self->{int}->{$options{instance}}->{omcast} = defined($self->{results}->{$self->{oid_ifHCOutMulticastPkts} . '.' . $options{instance}}) ? $self->{results}->{$self->{oid_ifHCOutMulticastPkts} . '.' . $options{instance}} : 0;
              $self->{int}->{$options{instance}}->{obcast} = defined($self->{results}->{$self->{oid_ifHCOutBroadcastPkts} . '.' . $options{instance}}) ? $self->{results}->{$self->{oid_ifHCOutBroadcastPkts} . '.' . $options{instance}} : 0;
              $self->{int}->{$options{instance}}->{mode_cast} = 64;
          }
      }
      
      foreach (('iucast', 'imcast', 'ibcast', 'oucast', 'omcast', 'obcast')) {
          $self->{int}->{$options{instance}}->{$_} = 0 if (!defined($self->{int}->{$options{instance}}->{$_}));
      }
      
      $self->{int}->{$options{instance}}->{total_in_packets} = $self->{int}->{$options{instance}}->{iucast} + $self->{int}->{$options{instance}}->{imcast} + $self->{int}->{$options{instance}}->{ibcast};
      $self->{int}->{$options{instance}}->{total_out_packets} = $self->{int}->{$options{instance}}->{oucast} + $self->{int}->{$options{instance}}->{omcast} + $self->{int}->{$options{instance}}->{obcast};
  }
  
  sub add_result_speed {
      my ($self, %options) = @_;
      
      my $interface_speed = 0;
      if (defined($self->{results}->{$self->{oid_speed64} . "." . $options{instance}}) && $self->{results}->{$self->{oid_speed64} . "." . $options{instance}} ne '') {
          $interface_speed = $self->{results}->{$self->{oid_speed64} . "." . $options{instance}} * 1000000;
          # If 0, we put the 32 bits
          if ($interface_speed == 0) {
              $interface_speed = $self->{results}->{$self->{oid_speed32} . "." . $options{instance}};
          }
      } else {
          $interface_speed = $self->{results}->{$self->{oid_speed32} . "." . $options{instance}};
      }
      
      $self->{int}->{$options{instance}}->{speed} = $interface_speed;
  }
  
  sub add_result_volume {
      my ($self, %options) = @_;
      
      $self->{int}->{$options{instance}}->{mode_traffic} = 32;
      $self->{int}->{$options{instance}}->{in_volume} = $self->{results}->{$self->{oid_in32} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{out_volume} = $self->{results}->{$self->{oid_out32} . '.' . $options{instance}};
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          if (defined($self->{results}->{$self->{oid_in64} . '.' . $options{instance}}) && $self->{results}->{$self->{oid_in64} . '.' . $options{instance}} ne '' &&
              $self->{results}->{$self->{oid_in64} . '.' . $options{instance}} != 0) {
              $self->{int}->{$options{instance}}->{mode_traffic} = 64;
              $self->{int}->{$options{instance}}->{in_volume} = $self->{results}->{$self->{oid_in64} . '.' . $options{instance}};
              $self->{int}->{$options{instance}}->{out_volume} = $self->{results}->{$self->{oid_out64} . '.' . $options{instance}};
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check interfaces.
  
  =over 8
  
  =item B<--add-global>
  
  Check global port statistics (By default if no --add-* option is set).
  
  =item B<--add-status>
  
  Check interface status.
  
  =item B<--add-duplex-status>
  
  Check duplex status (with --warning-status and --critical-status).
  
  =item B<--add-traffic>
  
  Check interface traffic.
  
  =item B<--add-errors>
  
  Check interface errors.
  
  =item B<--add-cast>
  
  Check interface cast.
  
  =item B<--add-speed>
  
  Check interface speed.
  
  =item B<--add-volume>
  
  Check interface data volume between two checks (not supposed to be graphed, useful for BI reporting).
  
  =item B<--warning-status>
  
  Set warning threshold for status.
  Can used special variables like: %{admstatus}, %{opstatus}, %{duplexstatus}, %{display}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '%{admstatus} eq "up" and %{opstatus} ne "up"').
  Can used special variables like: %{admstatus}, %{opstatus}, %{duplexstatus}, %{display}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-port', 'total-admin-up', 'total-admin-down', 'total-oper-up', 'total-oper-down',
  'in-traffic', 'out-traffic', 'in-error', 'in-discard', 'out-error', 'out-discard',
  'in-ucast' (%), 'in-bcast' (%), 'in-mcast' (%), 'out-ucast' (%), 'out-bcast' (%), 'out-mcast' (%),
  'speed' (b/s).
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-port', 'total-admin-up', 'total-admin-down', 'total-oper-up', 'total-oper-down',
  'in-traffic', 'out-traffic', 'in-error', 'in-discard', 'out-error', 'out-discard',
  'in-ucast' (%), 'in-bcast' (%), 'in-mcast' (%), 'out-ucast' (%), 'out-bcast' (%), 'out-mcast' (%),
  'speed' (b/s).
  
  =item B<--units-traffic>
  
  Units of thresholds for the traffic (Default: '%') ('%', 'b/s').
  
  =item B<--units-errors>
  
  Units of thresholds for errors/discards (Default: '%') ('%', 'absolute').
  
  =item B<--nagvis-perfdata>
  
  Display traffic perfdata to be compatible with nagvis widget.
  
  =item B<--interface>
  
  Set the interface (number expected) ex: 1,2,... (empty means 'check all interface').
  
  =item B<--name>
  
  Allows to use interface name with option --interface instead of interface oid index (Can be a regexp)
  
  =item B<--speed>
  
  Set interface speed for incoming/outgoing traffic (in Mb).
  
  =item B<--speed-in>
  
  Set interface speed for incoming traffic (in Mb).
  
  =item B<--speed-out>
  
  Set interface speed for outgoing traffic (in Mb).
  
  =item B<--no-skipped-counters>
  
  Don't skip counters when no change.
  
  =item B<--force-counters32>
  
  Force to use 32 bits counters (even in snmp v2c and v3). Should be used when 64 bits counters are buggy.
  
  =item B<--reload-cache-time>
  
  Time in minutes before reloading cache file (default: 180).
  
  =item B<--oid-filter>
  
  Choose OID used to filter interface (default: ifName) (values: ifDesc, ifAlias, ifName, IpAddr).
  
  =item B<--oid-display>
  
  Choose OID used to display interface (default: ifName) (values: ifDesc, ifAlias, ifName, IpAddr).
  
  =item B<--oid-extra-display>
  
  Add an OID to display.
  
  =item B<--display-transform-src>
  
  Regexp src to transform display value.
  
  =item B<--display-transform-dst>
  
  Regexp dst to transform display value.
  
  =item B<--show-cache>
  
  Display cache interface datas.
  
  =back
  
  =cut
SNMP_STANDARD_MODE_INTERFACES

$fatpacked{"snmp_standard/mode/listinterfaces.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_LISTINTERFACES';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::listinterfaces;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my $oid_speed32 = '.1.3.6.1.2.1.2.2.1.5'; # in b/s
  my $oid_speed64 = '.1.3.6.1.2.1.31.1.1.1.15';
  
  sub set_oids_status {
      my ($self, %options) = @_;
      
      $self->{oid_adminstatus} = '.1.3.6.1.2.1.2.2.1.7';
      $self->{oid_adminstatus_mapping} = {
          1 => 'up', 2 => 'down', 3 => 'testing', 4 => 'unknown', 5 => 'dormant', 6 => 'notPresent', 7 => 'lowerLayerDown',
      };
      $self->{oid_opstatus} = '.1.3.6.1.2.1.2.2.1.8';
      $self->{oid_opstatus_mapping} = {
          1 => 'up', 2 => 'down', 3 => 'testing', 4 => 'unknown', 5 => 'dormant', 6 => 'notPresent', 7 => 'lowerLayerDown',
      };
      $self->{oid_mac_address} = '.1.3.6.1.2.1.2.2.1.6';
  }
  
  sub check_oids_label {
      my ($self, %options) = @_;
      
      foreach (('oid_filter', 'oid_display')) {
          $self->{option_results}->{$_} = lc($self->{option_results}->{$_}) if (defined($self->{option_results}->{$_}));
          if (!defined($self->{oids_label}->{$self->{option_results}->{$_}})) {
              my $label = $_;
              $label =~ s/_/-/g;
              $self->{output}->add_option_msg(short_msg => "Unsupported oid in --" . $label . " option.");
              $self->{output}->option_exit();
          }
      }
  }
  
  sub set_oids_label {
      my ($self, %options) = @_;
  
      $self->{oids_label} = {
          'ifdesc' => '.1.3.6.1.2.1.2.2.1.2',
          'ifalias' => '.1.3.6.1.2.1.31.1.1.1.18',
          'ifname' => '.1.3.6.1.2.1.31.1.1.1.1',
      };
  }
  
  sub default_oid_filter_name {
      my ($self, %options) = @_;
      
      return 'ifname';
  }
  
  sub default_oid_display_name {
      my ($self, %options) = @_;
      
      return 'ifname';
  }
  
  sub is_admin_status_down {
      my ($self, %options) = @_;
      
      if (defined($self->{option_results}->{use_adminstatus}) && defined($options{admin_status}) && 
          $self->{oid_adminstatus_mapping}->{$options{admin_status}} ne 'up') {
          return 1;
      }
      return 0;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => defined($options{package}) ? $options{package} : __PACKAGE__, %options);
      bless $self, $class;
      
      $self->{no_speed} = defined($options{no_speed}) && $options{no_speed} =~ /^[01]$/ ? $options{no_speed} : 0;
      $options{options}->add_options(arguments => { 
          "name"                    => { name => 'use_name' },
          "interface:s"             => { name => 'interface' },
          "speed:s"                 => { name => 'speed' },
          "filter-status:s"         => { name => 'filter_status' },
          "skip-speed0"             => { name => 'skip_speed0' },
          "use-adminstatus"         => { name => 'use_adminstatus' },
          "oid-filter:s"            => { name => 'oid_filter', default => $self->default_oid_filter_name() },
          "oid-display:s"           => { name => 'oid_display', default => $self->default_oid_display_name() },
          "display-transform-src:s" => { name => 'display_transform_src' },
          "display-transform-dst:s" => { name => 'display_transform_dst' },
          "add-extra-oid:s@"        => { name => 'add_extra_oid' },
          "add-mac-address"         => { name => 'add_mac_address' },
      });
  
      $self->{interface_id_selected} = [];
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      $self->set_oids_label();
      $self->check_oids_label();
      $self->set_oids_status();
      
      $self->{extra_oids} = {};
      foreach (@{$self->{option_results}->{add_extra_oid}}) {
          next if ($_ eq '');
          my ($name, $oid, $matching) = split /,/;
          $matching = '%{instance}$' if (!defined($matching));
          if (!defined($oid) || $oid !~ /^(\.\d+){1,}$/ || $name eq '') {
              $self->{output}->add_option_msg(short_msg => "Wrong syntax for add-extra-oid '" . $_ . "' option.");
              $self->{output}->option_exit();
          }
          $self->{extra_oids}->{$name} = { oid => $oid, matching => $matching };
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      $self->manage_selection();
      my $result = $self->get_additional_information();
      foreach (sort @{$self->{interface_id_selected}}) {
          my $display_value = $self->get_display_value(id => $_);
  
          my $interface_speed = 0;
          if ($self->{no_speed} == 0) {
              $interface_speed = (defined($result->{$oid_speed64 . "." . $_}) && $result->{$oid_speed64 . "." . $_} ne '' && $result->{$oid_speed64 . "." . $_} != 0) ? 
                                  ($result->{$oid_speed64 . "." . $_}) : 
                                      (defined($result->{$oid_speed32 . "." . $_}) && $result->{$oid_speed32 . "." . $_} ne '' && $result->{$oid_speed32 . "." . $_} != 0 ?
                                          (sprintf("%g", $result->{$oid_speed32 . "." . $_} / 1000 / 1000)) : '');
          }
          if (defined($self->{option_results}->{speed}) && $self->{option_results}->{speed} ne '') {
              $interface_speed = $self->{option_results}->{speed};
          }
          
          if (defined($self->{option_results}->{skip_speed0}) && $interface_speed == 0) {
              $self->{output}->output_add(long_msg => "Skipping interface '" . $display_value . "': interface speed is 0 and option --skip-speed0 is set");
              next;
          }
          if (defined($self->{option_results}->{filter_status}) && defined($result->{$self->{oid_opstatus} . "." . $_}) && 
              $self->{oid_opstatus_mapping}->{$result->{$self->{oid_opstatus} . "." . $_}} !~ /$self->{option_results}->{filter_status}/i) {
              $self->{output}->output_add(long_msg => "Skipping interface '" . $display_value . "': no matching filter status");
              next;
          }
          if ($self->is_admin_status_down(admin_status => $result->{$self->{oid_adminstatus} . "." . $_})) {
              $self->{output}->output_add(long_msg => "Skipping interface '" . $display_value . "': adminstatus is not 'up' and option --use-adminstatus is set");
              next;
          }
          
          my $extra_values = $self->get_extra_values_by_instance(result => $result, instance => $_);
          my $extra_display = '';
          foreach my $name (keys %{$extra_values}) {
              $extra_display .= ', ' . $name . ' = ' . $extra_values->{$name};
          }
  
          $self->{output}->output_add(long_msg => "'" . $display_value . "' [speed = $interface_speed, status = " . 
              (defined($result->{$self->{oid_opstatus} . "." . $_}) ?  $self->{oid_opstatus_mapping}->{$result->{$self->{oid_opstatus} . "." . $_}} : '') . 
              ', id = ' . $_ . $extra_display . ']');
      }
  
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'List interfaces:');
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub get_additional_information {
      my ($self, %options) = @_;
  
      my $oids = [];
      push @$oids, $self->{oid_adminstatus} if (defined($self->{oid_adminstatus}));
      push @$oids, $self->{oid_opstatus} if (defined($self->{oid_opstatus}));
      push @$oids, $self->{oid_mac_address} if (defined($self->{option_results}->{add_mac_address}));
      push @$oids, $oid_speed32 if ($self->{no_speed} == 0);
      push @$oids, $oid_speed64 if (!$self->{snmp}->is_snmpv1() && $self->{no_speed} == 0);
      
      $self->{snmp}->load(oids => $oids, instances => $self->{interface_id_selected});
      return $self->{snmp}->get_leef();
  }
  
  sub get_display_value {
      my ($self, %options) = @_;
      my $value = $self->{datas}->{$self->{option_results}->{oid_display} . "_" . $options{id}};
  
      if (defined($self->{option_results}->{display_transform_src})) {
          $self->{option_results}->{display_transform_dst} = '' if (!defined($self->{option_results}->{display_transform_dst}));
          eval "\$value =~ s{$self->{option_results}->{display_transform_src}}{$self->{option_results}->{display_transform_dst}}";
      }
      return $value;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oids = [{ oid => $self->{oids_label}->{$self->{option_results}->{oid_filter}} }];
      if ($self->{option_results}->{oid_filter} ne $self->{option_results}->{oid_display}) {
          push @$oids, { oid => $self->{oids_label}->{$self->{option_results}->{oid_display}} };
      }
      if (scalar(keys %{$self->{extra_oids}}) > 0) {
          foreach (keys %{$self->{extra_oids}}) {
              push @$oids, { oid => $self->{extra_oids}->{$_}->{oid} };
          }
      }
      
      $self->{datas} = {};
      $self->{results} = $self->{snmp}->get_multiple_table(oids => $oids);
      $self->{datas}->{all_ids} = [];
      foreach my $key ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{ $self->{oids_label}->{$self->{option_results}->{oid_filter}} }})) {
          next if ($key !~ /^$self->{oids_label}->{$self->{option_results}->{oid_filter}}\.(.*)$/);
          $self->{datas}->{$self->{option_results}->{oid_filter} . "_" . $1} = $self->{output}->to_utf8($self->{results}->{$self->{oids_label}->{ $self->{option_results}->{oid_filter}} }->{$key});
          push @{$self->{datas}->{all_ids}}, $1;
      }
      
      if (scalar(@{$self->{datas}->{all_ids}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "Can't get interfaces...");
          $self->{output}->option_exit();
      }
  
      if ($self->{option_results}->{oid_filter} ne $self->{option_results}->{oid_display}) {
          foreach my $key ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{ $self->{oids_label}->{$self->{option_results}->{oid_display}} }})) {
              next if ($key !~ /^$self->{oids_label}->{$self->{option_results}->{oid_display}}\.(.*)$/);
              $self->{datas}->{$self->{option_results}->{oid_display} . "_" . $1} = $self->{output}->to_utf8($self->{results}->{$self->{oids_label}->{ $self->{option_results}->{oid_display}} }->{$key});
          }
      }
      
      if (!defined($self->{option_results}->{use_name}) && defined($self->{option_results}->{interface})) {
          foreach (@{$self->{datas}->{all_ids}}) {
              if ($self->{option_results}->{interface} =~ /(^|\s|,)$_(\s*,|$)/) {
                  push @{$self->{interface_id_selected}}, $_;
              }
          }
      } else {
          foreach (@{$self->{datas}->{all_ids}}) {
              my $filter_name = $self->{datas}->{$self->{option_results}->{oid_filter} . "_" . $_};
              next if (!defined($filter_name));
              
              if (!defined($self->{option_results}->{interface})) {
                  push @{$self->{interface_id_selected}}, $_;
                  next;
              }
              if ($filter_name =~ /$self->{option_results}->{interface}/) {
                  push @{$self->{interface_id_selected}}, $_; 
              }
          }
      }
      
      if (scalar(@{$self->{interface_id_selected}}) <= 0 && !defined($options{disco})) {
          $self->{output}->add_option_msg(short_msg => "No entry found");
          $self->{output}->option_exit();
      }
  }
  
  sub get_extra_values_by_instance {
      my ($self, %options) = @_;
      
      my $extra_values = {};
      foreach my $name (keys %{$self->{extra_oids}}) {
          my $matching = $self->{extra_oids}->{$name}->{matching};
          $matching =~ s/%\{instance\}/$options{instance}/g;
          next if (!defined($self->{results}->{ $self->{extra_oids}->{$name}->{oid} }));
          
          my $append = '';
          foreach (keys %{$self->{results}->{ $self->{extra_oids}->{$name}->{oid} }}) {
              if (/^$self->{extra_oids}->{$name}->{oid}\.$matching/) {
                  $extra_values->{$name} = '' if (!defined($extra_values->{$name}));
                  $extra_values->{$name} .= $append . $self->{results}->{$self->{extra_oids}->{$name}->{oid}}->{$_};
                  $append = ',';
              }
          }
      }
      
      if (defined($self->{option_results}->{add_mac_address})) {
          my $macaddress = defined($options{result}->{$self->{oid_mac_address} . "." . $_}) ? unpack('H*', $options{result}->{$self->{oid_mac_address} . "." . $_}) : '';
          $macaddress =~ s/(..)(?=.)/$1:/g;
          $extra_values->{macaddress} = $macaddress;
      }
      
      return $extra_values;
  }
  
  sub disco_format {
      my ($self, %options) = @_;
      
      my $names = ['name', 'total', 'status', 'interfaceid'];
      if (scalar(keys %{$self->{extra_oids}}) > 0) {
          push @$names, keys %{$self->{extra_oids}};
      }
      if (defined($self->{option_results}->{add_mac_address})) {
          push @$names, 'macaddress';
      }
      
      $self->{output}->add_disco_format(elements => $names);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      $self->manage_selection(disco => 1);
      return if (scalar(@{$self->{interface_id_selected}}) == 0);
      my $result = $self->get_additional_information();
      foreach (sort @{$self->{interface_id_selected}}) {
          my $display_value = $self->get_display_value(id => $_);
          
          my $interface_speed = 0;
          if ($self->{no_speed} == 0) {
              $interface_speed = (defined($result->{$oid_speed64 . "." . $_}) && $result->{$oid_speed64 . "." . $_} ne '' && $result->{$oid_speed64 . "." . $_} != 0) ? 
                                  ($result->{$oid_speed64 . "." . $_}) : 
                                      (defined($result->{$oid_speed32 . "." . $_}) && $result->{$oid_speed32 . "." . $_} ne '' && $result->{$oid_speed32 . "." . $_} != 0 ?
                                          (sprintf("%g", $result->{$oid_speed32 . "." . $_} / 1000 / 1000)) : '');
          }
          if (defined($self->{option_results}->{speed}) && $self->{option_results}->{speed} ne '') {
              $interface_speed = $self->{option_results}->{speed};
          }
          next if (defined($self->{option_results}->{skip_speed0}) && $interface_speed == 0);
          next if (defined($self->{option_results}->{filter_status}) && defined($result->{$self->{oid_opstatus} . "." . $_}) && 
              $self->{oid_opstatus_mapping}->{$result->{$self->{oid_opstatus} . "." . $_}} !~ /$self->{option_results}->{filter_status}/i);
          next if ($self->is_admin_status_down(admin_status => $result->{$self->{oid_adminstatus} . "." . $_}));
           
          my $extra_values = $self->get_extra_values_by_instance(result => $result, instance => $_);
          $self->{output}->add_disco_entry(name => $display_value,
                                           total => $interface_speed,
                                           status => defined($result->{$self->{oid_opstatus} . "." . $_}) ? $self->{oid_opstatus_mapping}->{$result->{$self->{oid_opstatus} . "." . $_}} : '',
                                           interfaceid => $_,
                                           %$extra_values);
      }
  }
  
  1;
  
  
  =head1 MODE
  
  =over 8
  
  =item B<--interface>
  
  Set the interface (number expected) ex: 1,2,... (empty means 'check all interface').
  
  =item B<--name>
  
  Allows to use interface name with option --interface instead of interface oid index (Can be a regexp)
  
  =item B<--speed>
  
  Set interface speed (in Mb).
  
  =item B<--skip-speed0>
  
  Don't display interface with speed 0.
  
  =item B<--filter-status>
  
  Display interfaces matching the filter (example: 'up').
  
  =item B<--use-adminstatus>
  
  Display interfaces with AdminStatus 'up'.
  
  =item B<--oid-filter>
  
  Choose OID used to filter interface (default: ifName) (values: ifDesc, ifAlias, ifName).
  
  =item B<--oid-display>
  
  Choose OID used to display interface (default: ifName) (values: ifDesc, ifAlias, ifName).
  
  =item B<--display-transform-src>
  
  Regexp src to transform display value. (security risk!!!)
  
  =item B<--display-transform-dst>
  
  Regexp dst to transform display value. (security risk!!!)
  
  =item B<--add-extra-oid>
  
  Display an OID.
  Example: --add-extra-oid='alias,.1.3.6.1.2.1.31.1.1.1.18'
  or --add-extra-oid='vlan,.1.3.6.1.2.1.31.19,%{instance}\..*'
  
  =item B<--add-mac-address>
  
  Display interface mac address.
  
  =back
  
  =cut
SNMP_STANDARD_MODE_LISTINTERFACES

$fatpacked{"snmp_standard/mode/listspanningtrees.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_LISTSPANNINGTREES';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::listspanningtrees;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                      "filter-port:s"         => { name => 'filter_port' },
                                  });
      $self->{spanningtrees} = {};
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  my %mapping_state = (
      1 => 'disabled',
      2 => 'blocking',
      3 => 'listening',
      4 => 'learning',
      5 => 'forwarding',
      6 => 'broken',
      10 => 'not defined',
  );
  my %mapping_status = (
      1 => 'enabled',
      2 => 'disabled',
  );
  
  my $mapping = {
      dot1dStpPortState   => { oid => '.1.3.6.1.2.1.17.2.15.1.3', map => \%mapping_state },
      dot1dStpPortEnable  => { oid => '.1.3.6.1.2.1.17.2.15.1.4', map => \%mapping_status },
  };
  my $oid_dot1dStpPortEntry = '.1.3.6.1.2.1.17.2.15.1';
  
  my $oid_dot1dBasePortIfIndex = '.1.3.6.1.2.1.17.1.4.1.2';
  
  my %mapping_if_status = (
      1 => 'up', 2 => 'down', 3 => 'testing', 4 => 'unknown',
      5 => 'dormant', 6 => 'notPresent', 7 => 'lowerLayerDown',
  );
  my $oid_ifDesc = '.1.3.6.1.2.1.2.2.1.2';
  my $oid_ifAdminStatus = '.1.3.6.1.2.1.2.2.1.7';
  my $oid_ifOpStatus = '.1.3.6.1.2.1.2.2.1.8';
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $results = $options{snmp}->get_table(oid => $oid_dot1dStpPortEntry, start => $mapping->{dot1dStpPortState}->{oid}, end => $mapping->{dot1dStpPortEnable}->{oid}, nothing_quit => 1);
  
      my @instances = ();
      foreach my $oid (keys %{$results}) {
          next if ($oid !~ /^$mapping->{dot1dStpPortState}->{oid}\.(.*)/);
          my $instance = $1;
          my $map_result = $options{snmp}->map_instance(mapping => $mapping, results => $results, instance => $instance);
  
          if ($map_result->{dot1dStpPortEnable} =~ /disabled/) {
              $self->{output}->output_add(long_msg => sprintf("Skipping interface '%d': Stp port disabled", $instance), debug => 1);
              next;
          }
          push @instances, $instance;
      }
  
      $options{snmp}->load(oids => [ $oid_dot1dBasePortIfIndex ], instances => [ @instances ]);
      my $result = $options{snmp}->get_leef(nothing_quit => 1);
  
      foreach my $oid (keys %{$result}) {
          next if ($oid !~ /^$oid_dot1dBasePortIfIndex\./ || !defined($result->{$oid}));
          $options{snmp}->load(oids => [ $oid_ifDesc . "." . $result->{$oid}, $oid_ifAdminStatus . "." . $result->{$oid}, $oid_ifOpStatus . "." . $result->{$oid} ]);
      }
      my $result_if = $options{snmp}->get_leef();
  
      foreach my $instance (@instances) {
          my $map_result = $options{snmp}->map_instance(mapping => $mapping, results => $results, instance => $instance);
  
          my $state = (defined($map_result->{dot1dStpPortState})) ? $map_result->{dot1dStpPortState} : 'not defined';
          my $description = (defined($result->{$oid_dot1dBasePortIfIndex . '.' . $instance}) && defined($result_if->{$oid_ifDesc . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}})) ?
              $result_if->{$oid_ifDesc . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}} : 'unknown';
          my $admin_status = (defined($result->{$oid_dot1dBasePortIfIndex . '.' . $instance}) && defined($result_if->{$oid_ifAdminStatus . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}})) ?
              $result_if->{$oid_ifAdminStatus . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}} : 'unknown';
          my $op_status = (defined($result->{$oid_dot1dBasePortIfIndex . '.' . $instance}) && defined($result_if->{$oid_ifOpStatus . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}})) ?
              $result_if->{$oid_ifOpStatus . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}} : 'unknown';
  
          if (defined($self->{option_results}->{filter_port}) && $self->{option_results}->{filter_port} ne '' &&
              $description !~ /$self->{option_results}->{filter_port}/) {
              $self->{output}->output_add(long_msg => sprintf("Skipping interface '%s': filtered with options", $description), debug => 1);
              next;
          }
  
          $self->{spanningtrees}->{$result->{$oid_dot1dBasePortIfIndex . '.' . $instance}} = {
              state => $state,
              admin_status => $mapping_if_status{$admin_status},
              op_status => $mapping_if_status{$op_status},
              index => $result->{$oid_dot1dBasePortIfIndex . '.' . $instance},
              description => $description
          };
      }
  }
  
  sub run {
      my ($self, %options) = @_;
    
      $self->manage_selection(%options);
      foreach my $instance (sort keys %{$self->{spanningtrees}}) { 
          $self->{output}->output_add(long_msg => sprintf("[port = %s] [state = %s] [op_status = %s] [admin_status = %s] [index = %s]",
              $self->{spanningtrees}->{$instance}->{description}, $self->{spanningtrees}->{$instance}->{state}, $self->{spanningtrees}->{$instance}->{op_status},
              $self->{spanningtrees}->{$instance}->{admin_status}, $self->{spanningtrees}->{$instance}->{index}));
      }
      
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'List ports with Spanning Tree Protocol:');
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
      
      $self->{output}->add_disco_format(elements => ['port', 'state', 'op_status', 'admin_status', 'index']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      $self->manage_selection(%options);
      foreach my $instance (sort keys %{$self->{spanningtrees}}) {             
          $self->{output}->add_disco_entry(
              port => $self->{spanningtrees}->{$instance}->{description},
              state => $self->{spanningtrees}->{$instance}->{state},
              op_status => $self->{spanningtrees}->{$instance}->{op_status},
              admin_status => $self->{spanningtrees}->{$instance}->{admin_status},
              index => $self->{spanningtrees}->{$instance}->{index}
          );
      }
  }
  
  1;
  
  
  =head1 MODE
  
  List ports using Spanning Tree Protocol.
  
  =over 8
  
  =item B<--filter-port>
  
  Filter by port description (can be a regexp).
  
  =back
  
  =cut
      
SNMP_STANDARD_MODE_LISTSPANNINGTREES

$fatpacked{"snmp_standard/mode/spanningtree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_SPANNINGTREE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::spanningtree;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = sprintf("spanning tree state is '%s' [op status: '%s'] [admin status: '%s'] [index: '%s']",
          $self->{result_values}->{state}, $self->{result_values}->{op_status},
          $self->{result_values}->{admin_status}, $self->{result_values}->{index});
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{port} = $options{new_datas}->{$self->{instance} . '_description'};
      $self->{result_values}->{state} = $options{new_datas}->{$self->{instance} . '_state'};
      $self->{result_values}->{admin_status} = $options{new_datas}->{$self->{instance} . '_admin_status'};
      $self->{result_values}->{op_status} = $options{new_datas}->{$self->{instance} . '_op_status'};
      $self->{result_values}->{index} = $options{new_datas}->{$self->{instance} . '_index'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'spanningtrees', type => 1, cb_prefix_output => 'prefix_peers_output', message_multiple => 'All spanning trees are ok' },
      ];
      $self->{maps_counters}->{spanningtrees} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' }, { name => 'admin_status' }, { name => 'op_status' },
                                  { name => 'index' }, { name => 'description' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
  }
  
  sub prefix_peers_output {
      my ($self, %options) = @_;
  
      return "Port '" . $options{instance_value}->{description} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments =>
                                  {
                                      "filter-port:s"         => { name => 'filter_port' },
                                      "warning-status:s"      => { name => 'warning_status', default => '' },
                                      "critical-status:s"     => { name => 'critical_status', default => '%{op_status} =~ /up/ && %{state} =~ /blocking|broken/' },
                                  });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => ['warning_status', 'critical_status']);
  }
  
  my %mapping_state = (
      1 => 'disabled',
      2 => 'blocking',
      3 => 'listening',
      4 => 'learning',
      5 => 'forwarding',
      6 => 'broken',
      10 => 'not defined',
  );
  my %mapping_status = (
      1 => 'enabled',
      2 => 'disabled',
  );
  
  my $mapping = {
      dot1dStpPortState   => { oid => '.1.3.6.1.2.1.17.2.15.1.3', map => \%mapping_state },
      dot1dStpPortEnable  => { oid => '.1.3.6.1.2.1.17.2.15.1.4', map => \%mapping_status },
  };
  my $oid_dot1dStpPortEntry = '.1.3.6.1.2.1.17.2.15.1';
  
  my $oid_dot1dBasePortIfIndex = '.1.3.6.1.2.1.17.1.4.1.2';
  
  my %mapping_if_status = (
      1 => 'up', 2 => 'down', 3 => 'testing', 4 => 'unknown',
      5 => 'dormant', 6 => 'notPresent', 7 => 'lowerLayerDown',
  );
  my $oid_ifDesc = '.1.3.6.1.2.1.2.2.1.2';
  my $oid_ifAdminStatus = '.1.3.6.1.2.1.2.2.1.7';
  my $oid_ifOpStatus = '.1.3.6.1.2.1.2.2.1.8';
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      $self->{spanningtrees} = {};
      my $results = $options{snmp}->get_table(oid => $oid_dot1dStpPortEntry, start => $mapping->{dot1dStpPortState}->{oid}, end => $mapping->{dot1dStpPortEnable}->{oid}, nothing_quit => 1);
  
      my @instances = ();
      foreach my $oid (keys %{$results}) {
          next if ($oid !~ /^$mapping->{dot1dStpPortState}->{oid}\.(.*)/);
          my $instance = $1;
          my $map_result = $options{snmp}->map_instance(mapping => $mapping, results => $results, instance => $instance);
  
          if ($map_result->{dot1dStpPortEnable} =~ /disabled/) {
              $self->{output}->output_add(long_msg => sprintf("Skipping interface '%d': Stp port disabled", $instance), debug => 1);
              next;
          }
          push @instances, $instance;
      }
  
      $options{snmp}->load(oids => [ $oid_dot1dBasePortIfIndex ], instances => [ @instances ]);
      my $result = $options{snmp}->get_leef(nothing_quit => 1);
  
      foreach my $oid (keys %{$result}) {
          next if ($oid !~ /^$oid_dot1dBasePortIfIndex\./ || !defined($result->{$oid}));
          $options{snmp}->load(oids => [ $oid_ifDesc . "." . $result->{$oid}, $oid_ifAdminStatus . "." . $result->{$oid}, $oid_ifOpStatus . "." . $result->{$oid} ]);
      }
      my $result_if = $options{snmp}->get_leef();
  
      foreach my $instance (@instances) {
          my $map_result = $options{snmp}->map_instance(mapping => $mapping, results => $results, instance => $instance);
  
          my $state = (defined($map_result->{dot1dStpPortState})) ? $map_result->{dot1dStpPortState} : 'not defined';
          my $description = (defined($result->{$oid_dot1dBasePortIfIndex . '.' . $instance}) && defined($result_if->{$oid_ifDesc . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}})) ?
              $result_if->{$oid_ifDesc . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}} : 'unknown';
          my $admin_status = (defined($result->{$oid_dot1dBasePortIfIndex . '.' . $instance}) && defined($result_if->{$oid_ifAdminStatus . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}})) ?
              $result_if->{$oid_ifAdminStatus . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}} : 'unknown';
          my $op_status = (defined($result->{$oid_dot1dBasePortIfIndex . '.' . $instance}) && defined($result_if->{$oid_ifOpStatus . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}})) ?
              $result_if->{$oid_ifOpStatus . '.' . $result->{$oid_dot1dBasePortIfIndex . '.' . $instance}} : 'unknown';
  
          if (defined($self->{option_results}->{filter_port}) && $self->{option_results}->{filter_port} ne '' &&
              $description !~ /$self->{option_results}->{filter_port}/) {
              $self->{output}->output_add(long_msg => sprintf("Skipping interface '%s': filtered with options", $description), debug => 1);
              next;
          }
  
          $self->{spanningtrees}->{$result->{$oid_dot1dBasePortIfIndex . '.' . $instance}} = {
              state => $state,
              admin_status => $mapping_if_status{$admin_status},
              op_status => $mapping_if_status{$op_status},
              index => $result->{$oid_dot1dBasePortIfIndex . '.' . $instance},
              description => $description
          };
      }
  
      if (scalar(keys %{$self->{spanningtrees}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => 'No port with Spanning Tree Protocol found.');
          $self->{output}->option_exit();
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check port Spanning Tree Protocol current state (BRIDGE-MIB).
  
  =over 8
  
  =item B<--filter-port>
  
  Filter on port description (can be a regexp).
  
  =item B<--warning-status>
  
  Set warning threshold for status.
  Can used special variables like: %{state}, %{op_status},
  %{admin_status}, %{port}, %{index}.
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '%{op_status} =~ /up/ && %{state} =~ /blocking|broken/').
  Can used special variables like: %{state}, %{op_status},
  %{admin_status}, %{port}, %{index}.
  
  =back
  
  =cut
SNMP_STANDARD_MODE_SPANNINGTREE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#
# Copyright 2019 Centreon (http://www.centreon.com/)
#
# Centreon is a full-fledged industry-strength solution that meets
# the needs in IT infrastructure and application monitoring for
# service performance.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

use strict;
use warnings;
# Not perl embedded compliant at all
use FindBin;
use lib "$FindBin::Bin";
# use lib '/usr/lib/nagios/plugins/';

use centreon::plugins::script;

centreon::plugins::script->new()->run();
