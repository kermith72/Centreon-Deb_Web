#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"centreon/plugins/alternative/FatPackerOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_ALTERNATIVE_FATPACKEROPTIONS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::alternative::FatPackerOptions;
  
  use base qw(centreon::plugins::options);
  
  use strict;
  use warnings;
  use Pod::Usage;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      return $self;
  }
  
  sub display_help {
      my ($self, %options) = @_;
      
      my $stdout;
      foreach (@{$self->{pod_package}}) {
          
          {
              my $pp = $_->{package} . ".pm";
              $pp =~ s{::}{/}g;
              my $content_class = $INC{$pp}->{$pp};
              open my $str_fh, '<', \$content_class;
              
              local *STDOUT;
              open STDOUT, '>', \$stdout;
              pod2usage(-exitval => 'NOEXIT', -input => $str_fh,
                        -verbose => 99, 
                        -sections => $_->{sections});
              
              close $str_fh;
          }
          
          $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
      }
  }
  
  1;
  
CENTREON_PLUGINS_ALTERNATIVE_FATPACKEROPTIONS

$fatpacked{"centreon/plugins/alternative/Getopt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_ALTERNATIVE_GETOPT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::alternative::Getopt;
  
  use strict;
  use warnings;
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  BEGIN {
      @EXPORT    = qw(&GetOptions);
      @EXPORT_OK = qw();
  }
  
  use vars @EXPORT, @EXPORT_OK;
  
  our $warn_message = 0;
  
  sub get_assigned_value {
      my (%options) = @_;
      
      if (!defined($options{val}) || $options{val} eq '') {
          # Add defined also. Hardened code: already see: $ARGV[6] = undef for example
          if ($options{pos} + 1 < $options{num_args} && defined($ARGV[$options{pos} + 1]) && $ARGV[$options{pos} + 1] !~ /^--/) {
              my $val = $ARGV[$options{pos} + 1];
              splice @ARGV, $options{pos} + 1, 1;
              return ($options{num_args} - 1, $val);
          } else {
              return ($options{num_args}, '');
          }
      }
      
      return ($options{num_args}, $options{val});
  }
  
  sub GetOptions {
      my (%opts) = @_;
      
      my $search_str = ',' . join(',', keys %opts) . ',';
      my $num_args = scalar(@ARGV);
      for (my $i = 0; $i < $num_args;) {
          if (defined($ARGV[$i]) && $ARGV[$i] =~ /^--(.*?)(?:=|$)(.*)/) {
              my ($option, $value) = ($1, $2);
              
              # find type of option
              if ($search_str !~ /,((?:[^,]*?\|){0,}$option(?:\|.*?){0,}(:.*?){0,1}),/) {
                  warn "Unknown option: $option" if ($warn_message == 1);
                  $i++;
                  next;
              }
              
              my ($option_selected, $type_opt) = ($1, $2);
              if (!defined($type_opt)) {
                  ${$opts{$option_selected}} = 1;
              } elsif ($type_opt =~ /:s$/) {
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  ${$opts{$option_selected}} = $assigned;
              } elsif ($type_opt =~ /:s\@$/) {
                  ${$opts{$option . $type_opt}} = [] if (!defined(${$opts{$option . $type_opt}}));
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  push @{${$opts{$option_selected}}}, $assigned;
              } elsif ($type_opt =~ /:s\%$/) {
                  ${$opts{$option . $type_opt}} = {} if (!defined(${$opts{$option . $type_opt}}));
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  if ($assigned =~ /^(.*?)=(.*)/) {
                      ${$opts{$option_selected}}->{$1} = $2;
                  }
              } 
              
              splice @ARGV, $i, 1;
              $num_args--;
          } else {
              warn "argument $ARGV[$i] alone" if ($warn_message == 1 && $i != 0 && defined($ARGV[$i]));
              $i++;
          }
      }
  }
  
  1;
  
CENTREON_PLUGINS_ALTERNATIVE_GETOPT

$fatpacked{"centreon/plugins/misc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MISC';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::misc;
  
  use strict;
  use warnings;
  use utf8;
  
  sub execute {
      my (%options) = @_;
      
      if ($^O eq 'MSWin32') {
          return windows_execute(%options, timeout => $options{options}->{timeout});
      } else {
          return unix_execute(%options);
      }
  }
  
  sub windows_execute {
      my (%options) = @_;
      my $result;
      my ($stdout, $pid, $ended) = ('');
      my ($exit_code, $cmd);
      
      $cmd = $options{command_path} . '/' if (defined($options{command_path}));
      $cmd .= $options{command} . ' ' if (defined($options{command}));
      $cmd .= $options{command_options} if (defined($options{command_options}));
      
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'Win32::Job',
                                             error_msg => "Cannot load module 'Win32::Job'.");
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'Time::HiRes',
                                             error_msg => "Cannot load module 'Time::HiRes'.");
      
      $| = 1;
      pipe FROM_CHILD, TO_PARENT or do {
          $options{output}->add_option_msg(short_msg => "Internal error: can't create pipe from child to parent: $!");
          $options{output}->option_exit();
      };
      my $job = Win32::Job->new;
      my $stderr = 'NUL';
      $stderr = \*TO_PARENT if ($options{output}->is_debug());
      if (!($pid = $job->spawn(undef, $cmd,
                         { stdin => 'NUL',
                           stdout => \*TO_PARENT,
                           stderr => $stderr }))) {
          $options{output}->add_option_msg(short_msg => "Internal error: execution issue: $^E");
          $options{output}->option_exit();
      }
      close TO_PARENT;
  
      my $ein = '';
      vec($ein, fileno(FROM_CHILD), 1) = 1;
      $job->watch(
          sub {            
              my ($buffer);
              my $time = $options{timeout};
              my $last_time = Time::HiRes::time();
              $ended = 0;
              while (select($ein, undef, undef, $options{timeout})) {
                  if (sysread(FROM_CHILD, $buffer, 16384)) {
                      $buffer =~ s/\r//g;
                      $stdout .= $buffer;
                  } else {
                      $ended = 1;
                      last;
                  }
                  $options{timeout} -= Time::HiRes::time() - $last_time;
                  last if ($options{timeout} <= 0);         
                  $last_time = Time::HiRes::time();
              }
              return 1 if ($ended == 0);
              return 0;
          },
          0.1
      );
          
      $result = $job->status;
      close FROM_CHILD;    
      
      if ($ended == 0) {
          $options{output}->add_option_msg(short_msg => 'Command too long to execute (timeout)...');
          $options{output}->option_exit();
      }
      chomp $stdout;
      
      if (defined($options{no_quit}) && $options{no_quit} == 1) {
          return ($stdout, $result->{$pid}->{exitcode});
      }
      
      if ($result->{$pid}->{exitcode} != 0) {
          $stdout =~ s/\n/ - /g;
          $options{output}->add_option_msg(short_msg => "Command error: $stdout");
          $options{output}->option_exit();
      }
      
      return ($stdout, $result->{$pid}->{exitcode});
  }
  
  sub unix_execute {
      my (%options) = @_;
      my $cmd = '';
      my $args = [];
      my ($lerror, $stdout, $exit_code);
  
      my $redirect_stderr = 1;
      $redirect_stderr = $options{redirect_stderr} if (defined($options{redirect_stderr}));
      my $wait_exit = 1;
      $wait_exit = $options{wait_exit} if (defined($options{wait_exit}));
      
      # Build command line
      # Can choose which command is done remotely (can filter and use local file)
      if (defined($options{options}->{remote}) && 
          ($options{options}->{remote} eq '' || !defined($options{label}) || $options{label} =~ /$options{options}->{remote}/)) {
          my $sub_cmd;
  
          $cmd = $options{options}->{ssh_path} . '/' if (defined($options{options}->{ssh_path}));
          $cmd .= $options{options}->{ssh_command} if (defined($options{options}->{ssh_command}));
          
          foreach (@{$options{options}->{ssh_option}}) {
              my ($lvalue, $rvalue) = split /=/;
              push @$args, $lvalue if (defined($lvalue));
              push @$args, $rvalue if (defined($rvalue));
          }
          
          if (defined($options{options}->{ssh_address}) && $options{options}->{ssh_address} ne '') {
              push @$args, $options{options}->{ssh_address};
          } else {
              push @$args, $options{options}->{hostname};
          }
  		
          $sub_cmd = 'sudo ' if (defined($options{sudo}));
          $sub_cmd .= $options{command_path} . '/' if (defined($options{command_path}));
          $sub_cmd .= $options{command} . ' ' if (defined($options{command}));
          $sub_cmd .= $options{command_options} if (defined($options{command_options}));
          # On some equipment. Cannot get a pseudo terminal
          if (defined($options{ssh_pipe}) && $options{ssh_pipe} == 1) {
              $cmd = "echo '" . $sub_cmd . "' | " . $cmd . ' ' . join(' ', @$args);
              ($lerror, $stdout, $exit_code) = backtick(
                  command => $cmd,
                  timeout => $options{options}->{timeout},
                  wait_exit => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          } else {
              ($lerror, $stdout, $exit_code) = backtick(
                  command => $cmd,
                  arguments => [@$args, $sub_cmd],
                  timeout => $options{options}->{timeout},
                  wait_exit => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          }
      } else {
          $cmd = 'sudo ' if (defined($options{sudo}));
          $cmd .= $options{command_path} . '/' if (defined($options{command_path}));
          $cmd .= $options{command} . ' ' if (defined($options{command}));
          $cmd .= $options{command_options} if (defined($options{command_options}));
          
          ($lerror, $stdout, $exit_code) = backtick(
              command => $cmd,
              timeout => $options{options}->{timeout},
              wait_exit => $wait_exit,
              redirect_stderr => $redirect_stderr
          );
      }
  
      if (defined($options{options}->{show_output}) && 
          ($options{options}->{show_output} eq '' || (defined($options{label}) && $options{label} eq $options{options}->{show_output}))) {
          print $stdout;
          exit $exit_code;
      }
      
      $stdout =~ s/\r//g;
      if ($lerror <= -1000) {
          $options{output}->add_option_msg(short_msg => $stdout);
          $options{output}->option_exit();
      }
      
      if (defined($options{no_quit}) && $options{no_quit} == 1) {
          return ($stdout, $exit_code);
      }
      
      if ($exit_code != 0 && (!defined($options{no_errors}) || !defined($options{no_errors}->{$exit_code}))) {
          $stdout =~ s/\n/ - /g;
          $options{output}->add_option_msg(short_msg => "Command error: $stdout");
          $options{output}->option_exit();
      }
      
      return $stdout;
  }
  
  sub mymodule_load {
      my (%options) = @_;
      my $file;
      ($file = ($options{module} =~ /\.pm$/ ? $options{module} : $options{module} . '.pm')) =~ s{::}{/}g;
      
      eval {
          local $SIG{__DIE__} = 'IGNORE';
          require $file;
          $file =~ s{/}{::}g;
          $file =~ s/\.pm$//;
      };
      if ($@) {
          return 1 if (defined($options{no_quit}) && $options{no_quit} == 1);
          $options{output}->add_option_msg(long_msg => $@);
          $options{output}->add_option_msg(short_msg => $options{error_msg});
          $options{output}->option_exit();
      }
      return wantarray ? (0, $file) : 0;
  }
  
  sub backtick {
      my %arg = (
          command => undef,
          arguments => [],
          timeout => 30,
          wait_exit => 0,
          redirect_stderr => 0,
          @_,
      );
      my @output;
      my $pid;
      my $return_code;
      
      my $sig_do;
      if ($arg{wait_exit} == 0) {
          $sig_do = 'IGNORE';
          $return_code = undef;
      } else {
          $sig_do = 'DEFAULT';
      }
      local $SIG{CHLD} = $sig_do;
      $SIG{TTOU} = 'IGNORE';
      $| = 1;
  
      if (!defined($pid = open( KID, "-|" ))) {
          return (-1001, "Cant fork: $!", -1);
      }
  
      if ($pid) {
          
          eval {
             local $SIG{ALRM} = sub { die "Timeout by signal ALARM\n"; };
             alarm( $arg{timeout} );
             while (<KID>) {
                 chomp;
                 push @output, $_;
             }
  
             alarm(0);
          };
  
          if ($@) {
              if ($pid != -1) {
                  kill -9, $pid;
              }
  
              alarm(0);
              return (-1000, 'Command too long to execute (timeout)...', -1);
          } else {
              if ($arg{wait_exit} == 1) {
                  # We're waiting the exit code                
                  waitpid($pid, 0);
                  $return_code = ($? >> 8);
              }
              close KID;
          }
      } else {
          # child
          # set the child process to be a group leader, so that
          # kill -9 will kill it and all its descendents
          # We have ignore SIGTTOU to let write background processes
          setpgrp( 0, 0 );
  
          if ($arg{redirect_stderr} == 1) {
              open STDERR, '>&STDOUT';
          }
          if (scalar(@{$arg{arguments}}) <= 0) {
              exec($arg{command});
          } else {
              exec($arg{command}, @{$arg{arguments}});
          }
          # Exec is in error. No such command maybe.
          exit(127);
      }
  
      return (0, join("\n", @output), $return_code);
  }
  
  sub trim {
      my ($value) = $_[0];
      
      # Sometimes there is a null character
      $value =~ s/\x00$//;
      $value =~ s/^[ \t\n]+//;
      $value =~ s/[ \t\n]+$//;
      return $value;
  }
  
  sub powershell_encoded {
      my ($value) = $_[0];
  
      require Encode;
      require MIME::Base64;
      my $bytes = Encode::encode('utf16LE', $value);
      my $script = MIME::Base64::encode_base64($bytes, "\n");
      $script =~ s/\n//g;
      return $script;
  }
  
  sub powershell_escape {
      my ($value) = $_[0];
      $value =~ s/`/``/g;
      $value =~ s/#/`#/g;
      $value =~ s/'/`'/g;
      $value =~ s/"/`"/g;
      return $value;
  }
  
  sub powershell_json_sanitizer {
      my (%options) = @_;
  
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'JSON::XS',
                                             error_msg => "Cannot load module 'JSON::XS'.");
      foreach my $line (split /\n/, $options{string}) {
          eval { JSON::XS->new->utf8->decode($line) };
          return $line if (!$@);
      }
      return -1;
  }
  
  sub minimal_version {
      my ($version_src, $version_dst) = @_;
          
      # No Version. We skip   
      if (!defined($version_src) || !defined($version_dst) || 
          $version_src !~ /^[0-9]+(?:\.[0-9\.]+)*$/ || $version_dst !~ /^[0-9x]+(?:\.[0-9x]+)*$/) {
          return 1;
      }
    
      my @version_src = split /\./, $version_src;
      my @versions = split /\./, $version_dst;
      for (my $i = 0; $i < scalar(@versions); $i++) {
          return 1 if ($versions[$i] eq 'x');
          return 1 if (!defined($version_src[$i]));
          $version_src[$i] =~ /^([0-9]*)/;
          next if ($versions[$i] == int($1));
          return 0 if ($versions[$i] > int($1));
          return 1 if ($versions[$i] < int($1));
      }
      
      return 1;
  }
  
  sub change_seconds {
      my %options = @_;
      my ($str, $str_append) = ('', '');
      my $periods = [
          { unit => 'y', value => 31556926 },
          { unit => 'M', value => 2629743 },
          { unit => 'w', value => 604800 },
          { unit => 'd', value => 86400 },
          { unit => 'h', value => 3600 },
          { unit => 'm', value => 60 },
          { unit => 's', value => 1 },
      ];
      my %values = ('y' => 1, 'M' => 2, 'w' => 3, 'd' => 4, 'h' => 5, 'm' => 6, 's' => 7);
  
      foreach (@$periods) {
          next if (defined($options{start}) && $values{$_->{unit}} < $values{$options{start}});
          my $count = int($options{value} / $_->{value});
  
          next if ($count == 0);
          $str .= $str_append . $count . $_->{unit};
          $options{value} = $options{value} % $_->{value};
          $str_append = ' ';
      }
  
      return $str;
  }
  
  sub scale_bytesbit {
      my (%options) = @_;
      
      my $base = 1024;
      if (defined($options{dst_unit}) && defined($options{src_unit})) {
          $options{value} *= 8 if ($options{dst_unit} =~ /b/ && $options{src_unit} =~ /B/);
          $options{value} /= 8 if ($options{dst_unit} =~ /B/ && $options{src_unit} =~ /b/);
          if ($options{dst_unit} =~ /b/) {
              $base = 1000;
          }
      }
          
      my %expo = ('' => 0, k => 1, m => 2, g => 3, t => 4, p => 5, e => 6);
      my ($src_expo, $dst_expo) = (0, 0);
      $src_expo = $expo{lc($options{src_quantity})} if (defined($options{src_quantity}) && $options{src_quantity} =~ /[kmgtpe]/i);
      if ($options{dst_unit} eq 'auto') {
          my @auto = ('', 'k', 'm', 'g', 't', 'p', 'e');
          my $i = defined($options{src_quantity}) ? $expo{$options{src_quantity}} : 0;
          for (; $i < scalar(@auto); $i++) {
              last if ($options{value} < $base);
              $options{value} = $options{value} / $base;
          }
  
          return ($options{value}, $auto[$i], $options{src_unit});
      } elsif (defined($options{dst_quantity}) && ($options{dst_quantity} eq '' || $options{dst_quantity} =~ /[kmgtpe]/i )) {
          my $dst_expo = $expo{lc($options{dst_quantity})};
          if ($dst_expo - $src_expo > 0) {
              $options{value} = $options{value} / ($base ** ($dst_expo - $src_expo));
          } elsif ($dst_expo - $src_expo < 0) {
              $options{value} = $options{value} * ($base ** (($dst_expo - $src_expo) * -1));
          }
      }
      
      return $options{value};
  }
  
  sub convert_bytes {
      my (%options) = @_;
  
      my %expo = (k => 1, m => 2, g => 3, t => 4, p => 5);
      my $value = $options{value};
      my $base = defined($options{network}) ? 1000 : 1024;    
      if ($options{unit} =~ /([kmgt])b/i) {
          $value = $value * ($base ** $expo{lc($1)});
      }
  
      return $value;
  }
  
  sub expand_exponential {
      my (%options) = @_;
      
      return $options{value} unless ($options{value} =~ /^(.*)e([-+]?)(.*)$/);
      my ($num, $sign, $exp) = ($1, $2, $3);
      my $sig = $sign eq '-' ? "." . ($exp - 1 + length $num) : '';
      return sprintf("%${sig}f", $options{value});
  }
  
  sub parse_threshold {
      my (%options) = @_;
  
      my $perf = trim($options{threshold});
      my $perf_result = { arobase => 0, infinite_neg => 0, infinite_pos => 0, start => '', end => '' };
  
      my $global_status = 1;    
      if ($perf =~ /^(\@?)((?:~|(?:\+|-)?\d+(?:[\.,]\d+)?(?:[KMGTPE][bB])?|):)?((?:\+|-)?\d+(?:[\.,]\d+)?(?:[KMGTPE][bB])?)?$/) {
          $perf_result->{start} = $2 if (defined($2));
          $perf_result->{end} = $3 if (defined($3));
          $perf_result->{arobase} = 1 if (defined($1) && $1 eq '@');
          $perf_result->{start} =~ s/[\+:]//g;
          $perf_result->{end} =~ s/\+//;
          if ($perf_result->{start} =~ s/([KMGTPE])([bB])//) {
              $perf_result->{start} = scale_bytesbit(
                  value => $perf_result->{start},
                  src_unit => $2, dst_unit => $2,
                  src_quantity => $1, dst_quantity => '',
              );
          }
          if ($perf_result->{end} =~ s/([KMGTPE])([bB])//) {
              $perf_result->{end} = scale_bytesbit(
                  value => $perf_result->{end},
                  src_unit => $2, dst_unit => $2,
                  src_quantity => $1, dst_quantity => '',
              );
          }
          if ($perf_result->{end} eq '') {
              $perf_result->{end} = 1e500;
              $perf_result->{infinite_pos} = 1;
          }
          $perf_result->{start} = 0 if ($perf_result->{start} eq '');      
          $perf_result->{start} =~ s/,/\./;
          $perf_result->{end} =~ s/,/\./;
          
          if ($perf_result->{start} eq '~') {
              $perf_result->{start} = -1e500;
              $perf_result->{infinite_neg} = 1;
          }
      } else {
          $global_status = 0;
      }
  
      return ($global_status, $perf_result);
  }
  
  sub get_threshold_litteral {
      my (%options) = @_;
      
      my $perf_output = ($options{arobase} == 1 ? '@' : '') . 
                        (($options{infinite_neg} == 0) ? $options{start} : '~') . 
                        ':' . 
                        (($options{infinite_pos} == 0) ? $options{end} : '');
      return $perf_output;
  }
  
  sub set_timezone {
      my (%options) = @_;
      
      return {} if (!defined($options{name}) || $options{name} eq '');
       
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'DateTime::TimeZone',
                                             error_msg => "Cannot load module 'DateTime::TimeZone'.");
      if (DateTime::TimeZone->is_valid_name($options{name})) {
          return { time_zone => DateTime::TimeZone->new(name => $options{name}) };
      }
      
      # try to manage syntax (:Pacific/Noumea for example)
      if ($options{name} =~ /^:(.*)$/ && DateTime::TimeZone->is_valid_name($1)) {
          return { time_zone => DateTime::TimeZone->new(name => $1) };
      }
  
      return {};
  }
  
  1;
  
  
CENTREON_PLUGINS_MISC

$fatpacked{"centreon/plugins/mode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MODE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::mode;
  
  use strict;
  use warnings;
  use centreon::plugins::perfdata;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{perfdata} = centreon::plugins::perfdata->new(output => $options{output});
      
      %{$self->{option_results}} = ();
      $self->{output} = $options{output};
      $self->{output}->use_new_perfdata(value => 1)
          if (defined($options{force_new_perfdata}) && $options{force_new_perfdata} == 1);
      $self->{mode} = $options{mode};
      $self->{version} = '1.0';
  
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      # options{default} = { mode_xxx => { option_name => option_value }, }
  
      %{$self->{option_results}} = %{$options{option_results}};
      # Manage default value
      return if (!defined($options{default}));
      foreach (keys %{$options{default}}) {
          if ($_ eq $self->{mode}) {
              foreach my $value (keys %{$options{default}->{$_}}) {
                  if (!defined($self->{option_results}->{$value})) {
                      $self->{option_results}->{$value} = $options{default}->{$_}->{$value};
                  }
              }
          }
      }
  }
  
  sub version {
      my ($self, %options) = @_;
      
      $self->{output}->add_option_msg(short_msg => "Mode Version: " . $self->{version});
  }
  
  sub disco_format {
      my ($self, %options) = @_;
  
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
  }
  
  1;
  
  
CENTREON_PLUGINS_MODE

$fatpacked{"centreon/plugins/options.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_OPTIONS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::options;
  
  use Pod::Usage;
  use Pod::Find qw(pod_where);
  use strict;
  use warnings;
  
  my $alternative = 1;
  
  sub new {
      my ($class) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{sanity} = 0;
      $self->{options_stored} = {};
      $self->{options} = {};
      @{$self->{pod_package}} = ();
      $self->{pod_packages_once} = {};
      
      if ($alternative == 0) {
          require Getopt::Long;
          Getopt::Long->import();
          Getopt::Long::Configure("pass_through");
          Getopt::Long::Configure('bundling');
          Getopt::Long::Configure('no_auto_abbrev');
      } else {
          require centreon::plugins::alternative::Getopt;
          $centreon::plugins::alternative::Getopt::warn_message = 0;
          centreon::plugins::alternative::Getopt->import();
      }
      
      return $self;
  }
  
  sub set_sanity {
      my ($self, %options) = @_;
      
      if ($alternative == 0) {
          Getopt::Long::Configure('no_pass_through');
      } else {
          $centreon::plugins::alternative::Getopt::warn_message = 1;
      }
  
      $self->{sanity} = 1;
  }
  
  sub set_output {
      my ($self, %options) = @_;
      
      $self->{output} = $options{output};
  }
  
  sub display_help {
      my ($self, %options) = @_;
      
      my $stdout;
      foreach (@{$self->{pod_package}}) {
          
          {
              local *STDOUT;
              open STDOUT, '>', \$stdout;
              my $where = pod_where({-inc => 1}, $_->{package});
              pod2usage(-exitval => 'NOEXIT', -input => $where,
                        -verbose => 99, 
                        -sections => $_->{sections}) if (defined($where));
          }
          
          $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
      }
  }
  
  sub add_help {
      my ($self, %options) = @_;
      # $options{package} = string package
      # $options{sections} = string sections
      # $options{help_first} = put at the beginning
      # $options{once} = put help only one time for a package
      
      if (defined($options{once}) && defined($self->{pod_packages_once}->{$options{package}})) {
          return ;
      }
      
      if (defined($options{help_first})) {
          unshift @{$self->{pod_package}}, {package => $options{package}, sections => $options{sections}};
      } else {
          push @{$self->{pod_package}}, { package => $options{package}, sections => $options{sections} };
      }
      
      $self->{pod_packages_once}->{$options{package}} = 1;
  }
  
  sub add_options {
      my ($self, %options) = @_;
      # $options{arguments} = ref to hash table with string and name to store (example: { 'mode:s' => { name => 'mode', default => 'defaultvalue' )
      
      foreach (keys %{$options{arguments}}) {
          if (defined($options{arguments}->{$_}->{redirect})) {
              $self->{options}->{$_} = \$self->{options_stored}->{$options{arguments}->{$_}->{redirect}};
              next;
          }
          
          if (defined($options{arguments}->{$_}->{default})) {
              $self->{options_stored}->{$options{arguments}->{$_}->{name}} = $options{arguments}->{$_}->{default};
          } else {
              $self->{options_stored}->{$options{arguments}->{$_}->{name}} = undef;
          }
          
          $self->{options}->{$_} = \$self->{options_stored}->{$options{arguments}->{$_}->{name}};
      }
  }
  
  sub parse_options {
      my $self = shift;
      #%{$self->{options_stored}} = ();
  
      my $save_warn_handler;
      if ($self->{sanity} == 1) {
          $save_warn_handler = $SIG{__WARN__};
          $SIG{__WARN__} = sub {
              $self->{output}->add_option_msg(short_msg => $_[0]);
              $self->{output}->option_exit(nolabel => 1);
          };
      }
      
      GetOptions(
         %{$self->{options}}
      );
      %{$self->{options}} = ();
      
      $SIG{__WARN__} = $save_warn_handler if ($self->{sanity} == 1);
  }
  
  sub get_option {
      my ($self, %options) = @_;
  
      return $self->{options_stored}->{$options{argument}};
  }
  
  sub get_options {
      my $self = shift;
  
      return $self->{options_stored};
  }
  
  sub clean {
      my $self = shift;
      
      $self->{options_stored} = {};
  }
  
  1;
  
CENTREON_PLUGINS_OPTIONS

$fatpacked{"centreon/plugins/output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_OUTPUT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::output;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      if (!defined($options{options})) {
          print "Class Output: Need to specify 'options' argument to load.\n";
          exit 3;
      }
  
      $options{options}->add_options(arguments => {
          'explode-perfdata-max:s@' => { name => 'explode_perfdata_max' },
          'range-perfdata:s'        => { name => 'range_perfdata' },
          'filter-perfdata:s'       => { name => 'filter_perfdata' },
          'change-perfdata:s@'      => { name => 'change_perfdata' },
          'extend-perfdata:s@'      => { name => 'extend_perfdata' },
          'extend-perfdata-group:s@'=> { name => 'extend_perfdata_group' },
          'change-short-output:s@'  => { name => 'change_short_output' },
          'use-new-perfdata'        => { name => 'use_new_perfdata' },
          'filter-uom:s'            => { name => 'filter_uom' },
          'verbose'                 => { name => 'verbose' },
          'debug'                   => { name => 'debug' },
          'opt-exit:s'              => { name => 'opt_exit', default => 'unknown' },
          'output-xml'              => { name => 'output_xml' },
          'output-json'             => { name => 'output_json' },
          'output-openmetrics'      => { name => 'output_openmetrics' },
          'output-file:s'           => { name => 'output_file' },
          'disco-format'            => { name => 'disco_format' },
          'disco-show'              => { name => 'disco_show' },
          'float-precision:s'       => { name => 'float_precision', default => 8 },
      });
      
      %{$self->{option_results}} = ();
  
      $self->{option_msg} = [];
      
      $self->{is_output_xml} = 0;
      $self->{is_output_json} = 0;
      $self->{errors} = {OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3, PENDING => 4};
      $self->{errors_num} = {0 => 'OK', 1 => 'WARNING', 2 => 'CRITICAL', 3 => 'UNKNOWN', 4 => 'PENDING'};
      $self->{myerrors} = {0 => "OK", 1 => "WARNING", 3 => "UNKNOWN", 7 => "CRITICAL"};
      $self->{myerrors_mask} = {CRITICAL => 7, WARNING => 1, UNKNOWN => 3, OK => 0};
      $self->{global_short_concat_outputs} = {OK => undef, WARNING => undef, CRITICAL => undef, UNKNOWN => undef, UNQUALIFIED_YET => undef};
      $self->{global_short_outputs} = {OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [], UNQUALIFIED_YET => []};
      $self->{global_long_output} = [];
      $self->{perfdatas} = [];
      $self->{explode_perfdatas} = {};
      $self->{change_perfdata} = {};
      $self->{explode_perfdata_total} = 0;
      $self->{range_perfdata} = 0;
      $self->{global_status} = 0;
      $self->{encode_utf8_import} = 0;
      $self->{perlqq} = 0;
  
      $self->{disco_elements} = [];
      $self->{disco_entries} = [];
  
      $self->{plugin} = '';
      $self->{mode} = '';
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      # $options{option_results} = ref to options result
  
      %{$self->{option_results}} = %{$options{option_results}};
      $self->{option_results}->{opt_exit} = lc($self->{option_results}->{opt_exit});
      if (!$self->is_litteral_status(status => $self->{option_results}->{opt_exit})) {
          $self->add_option_msg(short_msg => "Unknown value '" . $self->{option_results}->{opt_exit}  . "' for --opt-exit.");
          $self->option_exit(exit_litteral => 'unknown');
      }
      # Go in XML Mode
      if ($self->is_disco_show() || $self->is_disco_format()) {
          # By Default XML
          if (!defined($self->{option_results}->{output_json})) {
              $self->{option_results}->{output_xml} = 1;
          }
      }
      
      if (defined($self->{option_results}->{range_perfdata})) {
          $self->{range_perfdata} = $self->{option_results}->{range_perfdata};
          $self->{range_perfdata} = 1 if ($self->{range_perfdata} eq '');
          if ($self->{range_perfdata} !~ /^[012]$/) {
              $self->add_option_msg(short_msg => "Wrong range-perfdata option '" . $self->{range_perfdata} . "'");
              $self->option_exit();
          }
      }
      
      if (defined($self->{option_results}->{explode_perfdata_max})) {
          if (${$self->{option_results}->{explode_perfdata_max}}[0] eq '') {
              $self->{explode_perfdata_total} = 2;
          } else {
              $self->{explode_perfdata_total} = 1;
              foreach (@{$self->{option_results}->{explode_perfdata_max}}) {
                  my ($perf_match, $perf_result) = split /,/;
                  if (!defined($perf_result)) {
                      $self->add_option_msg(short_msg => "Wrong explode-perfdata-max option '" . $_ . "' (syntax: match,value)");
                      $self->option_exit();
                  }
                  $self->{explode_perfdatas}->{$perf_match} = $perf_result;
              }
          }
      }
      
      $self->load_perfdata_extend_args();
      $self->{option_results}->{use_new_perfdata} = 1 if (defined($self->{option_results}->{output_openmetrics}));
  }
  
  sub add_option_msg {
      my ($self, %options) = @_;
      # $options{short_msg} = string msg
      # $options{long_msg} = string msg
      $options{severity} = 'UNQUALIFIED_YET';
      
      $self->output_add(%options);
  }
  
  sub set_status {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
  
      # Nothing to do for 'UNQUALIFIED_YET'
      if (!$self->{myerrors_mask}->{uc($options{exit_litteral})}) {
          return ;
      }
      $self->{global_status} |= $self->{myerrors_mask}->{uc($options{exit_litteral})};
  }
  
  sub output_add {
      my ($self, %params) = @_;
      my %args = (
          severity => 'OK',
          separator => ' - ',
          debug => 0,
          short_msg => undef,
          long_msg => undef,
      );
      my $options = {%args, %params};
      
      if (defined($options->{short_msg})) {
          chomp $options->{short_msg};
          if (defined($self->{global_short_concat_outputs}->{uc($options->{severity})})) {
              $self->{global_short_concat_outputs}->{uc($options->{severity})} .= $options->{separator} . $options->{short_msg};
          } else {
              $self->{global_short_concat_outputs}->{uc($options->{severity})} = $options->{short_msg};
          }
          
          push @{$self->{global_short_outputs}->{uc($options->{severity})}}, $options->{short_msg};
          $self->set_status(exit_litteral => $options->{severity});
      }
      if (defined($options->{long_msg}) && 
          ($options->{debug} == 0 || defined($self->{option_results}->{debug}))) {
          chomp $options->{long_msg};
          push @{$self->{global_long_output}}, $options->{long_msg};
      }
  }
  
  sub perfdata_add {
      my ($self, %options) = @_;
      my $perfdata = {
          label => '', value => '', unit => '', warning => '', critical => '', min => '', max => ''
      };
      foreach (keys %options) {
          next if (!defined($options{$_}));
          $perfdata->{$_} = $options{$_};
      }
      
      if (defined($self->{option_results}->{use_new_perfdata}) && defined($options{nlabel})) {
          $perfdata->{label} = $options{nlabel};
      }
      if (defined($options{instances})) {
          $options{instances} = [$options{instances}] if (!ref($options{instances}));
          my ($external_instance_separator, $internal_instance_separator) = ('#', '~');
          if (defined($self->{option_results}->{use_new_perfdata})) {
              $perfdata->{label} = join('~', @{$options{instances}}) . '#' . $perfdata->{label};
          } else {
              $perfdata->{label} .= '_' . join('_', @{$options{instances}});
          }
      }
      
      $perfdata->{label} =~ s/'/''/g;
      push @{$self->{perfdatas}}, $perfdata;
  }
  
  sub range_perfdata {
      my ($self, %options) = @_;
      
      return if ($self->{range_perfdata} == 0);
      if ($self->{range_perfdata} == 1) {
          for (my $i = 0; $i < scalar(@{$options{ranges}}); $i++) {
              ${${$options{ranges}}[$i]} =~ s/^(@?)-?[0\.]+:/$1/;
          }
      } else {
          for (my $i = 0; $i < scalar(@{$options{ranges}}); $i++) {
              ${${$options{ranges}}[$i]} = '';
          }
      }
  }
  
  sub output_json {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      my $json_content = {
          plugin => {
              name => $self->{plugin},
              mode => $self->{mode},
              exit => $options{exit_litteral},
              outputs => [],
              perfdatas => []
          }
      };    
  
      foreach my $code_litteral (keys %{$self->{global_short_outputs}}) {
          foreach (@{$self->{global_short_outputs}->{$code_litteral}}) {
              my ($child_output, $child_type, $child_msg, $child_exit);
              my $lcode_litteral = ($code_litteral eq 'UNQUALIFIED_YET' ? uc($options{exit_litteral}) : $code_litteral);
  
              push @{$json_content->{plugin}->{outputs}}, {
                  type => 1,
                  msg => ($options{nolabel} == 0 ? ($lcode_litteral . ': ') : '') . $_,
                  exit => $lcode_litteral
              };
          }
      }
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          foreach (@{$self->{global_long_output}}) {
              push @{$json_content->{plugin}->{outputs}}, {
                  type => 2,
                  msg => $_,
              };
          }
      }
  
      if ($options{force_ignore_perfdata} == 0) {
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if (defined($self->{option_results}->{filter_perfdata}) &&
                       $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
              
              my %values = ();
              foreach my $key (keys %$perf) {
                  $perf->{$key} = '' if (defined($self->{option_results}->{filter_uom}) && $key eq 'unit' &&
                      $perf->{$key} !~ /$self->{option_results}->{filter_uom}/);
                  $values{$key} = $perf->{$key};
              }
              
              push @{$json_content->{plugin}->{perfdatas}}, {
                  %values
              };
          }
      }
  
      print $self->{json_output}->encode($json_content);
  }
  
  sub output_xml {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      my ($child_plugin_name, $child_plugin_mode, $child_plugin_exit, $child_plugin_output, $child_plugin_perfdata); 
  
      my $root = $self->{xml_output}->createElement('plugin');
      $self->{xml_output}->setDocumentElement($root);
  
      $child_plugin_name = $self->{xml_output}->createElement('name');
      $child_plugin_name->appendText($self->{plugin});
  
      $child_plugin_mode = $self->{xml_output}->createElement('mode');
      $child_plugin_mode->appendText($self->{mode});
  
      $child_plugin_exit = $self->{xml_output}->createElement('exit');
      $child_plugin_exit->appendText($options{exit_litteral});
  
      $child_plugin_output = $self->{xml_output}->createElement('outputs');
      $child_plugin_perfdata = $self->{xml_output}->createElement('perfdatas');
  
      $root->addChild($child_plugin_name);
      $root->addChild($child_plugin_mode);
      $root->addChild($child_plugin_exit);
      $root->addChild($child_plugin_output);
      $root->addChild($child_plugin_perfdata);
  
      foreach my $code_litteral (keys %{$self->{global_short_outputs}}) {
          foreach (@{$self->{global_short_outputs}->{$code_litteral}}) {
              my ($child_output, $child_type, $child_msg, $child_exit);
              my $lcode_litteral = ($code_litteral eq 'UNQUALIFIED_YET' ? uc($options{exit_litteral}) : $code_litteral);
  
              $child_output = $self->{xml_output}->createElement('output');
              $child_plugin_output->addChild($child_output);
  
              $child_type = $self->{xml_output}->createElement('type');
              $child_type->appendText(1); # short
  
              $child_msg = $self->{xml_output}->createElement('msg');
              $child_msg->appendText(($options{nolabel} == 0 ? ($lcode_litteral . ': ') : '') . $_);
              $child_exit = $self->{xml_output}->createElement('exit');
              $child_exit->appendText($lcode_litteral);
  
              $child_output->addChild($child_type);
              $child_output->addChild($child_exit);
              $child_output->addChild($child_msg);
          }
      }
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          foreach (@{$self->{global_long_output}}) {
              my ($child_output, $child_type, $child_msg);
          
              $child_output = $self->{xml_output}->createElement('output');
              $child_plugin_output->addChild($child_output);
  
              $child_type = $self->{xml_output}->createElement('type');
              $child_type->appendText(2); # long
  
              $child_msg = $self->{xml_output}->createElement('msg');
              $child_msg->appendText($_);
  
              $child_output->addChild($child_type);
              $child_output->addChild($child_msg);
          }
      }
  
      if ($options{force_ignore_perfdata} == 0) {
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if (defined($self->{option_results}->{filter_perfdata}) &&
                       $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
          
              my ($child_perfdata);
              $child_perfdata = $self->{xml_output}->createElement('perfdata');
              $child_plugin_perfdata->addChild($child_perfdata);
              foreach my $key (keys %$perf) {
                  $perf->{$key} = '' if (defined($self->{option_results}->{filter_uom}) && $key eq 'unit' &&
                      $perf->{$key} !~ /$self->{option_results}->{filter_uom}/);
                  my $child = $self->{xml_output}->createElement($key);
                  $child->appendText($perf->{$key});
                  $child_perfdata->addChild($child);
              }
          }
      }
  
      print $self->{xml_output}->toString(1);
  }
  
  sub output_openmetrics {
      my ($self, %options) = @_;
  
      $self->change_perfdata();
      foreach my $perf (@{$self->{perfdatas}}) {
          next if (defined($self->{option_results}->{filter_perfdata}) &&
                   $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
          $perf->{unit} = '' if (defined($self->{option_results}->{filter_uom}) &&
              $perf->{unit} !~ /$self->{option_results}->{filter_uom}/);
          $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
          my $label = $perf->{label};
          my $instance;
          if ($label =~ /^(.*?)#(.*)$/) {
              ($perf->{instance}, $label) = ($1, $2);
          }
          my ($bucket, $append) = ('{plugin="' . $self->{plugin} . '",mode="' . $self->{mode} . '"', '');
          foreach ('unit', 'warning', 'critical', 'min', 'max', 'instance') {
              if (defined($perf->{$_}) && $perf->{$_} ne '') {
                  $bucket .= ',' . $_ . '="' . $perf->{$_} . '"';
              }
          }
          $bucket .= '}';
          
          print $label . $bucket . ' ' . $perf->{value} . "\n";
      }
  }
  
  sub output_txt_short_display {
      my ($self, %options) = @_;
      
      if (defined($self->{global_short_concat_outputs}->{CRITICAL})) {
          print (($options{nolabel} == 0 ? 'CRITICAL: ' : '') . $self->{global_short_concat_outputs}->{CRITICAL} . " ");
      }
      if (defined($self->{global_short_concat_outputs}->{WARNING})) {
          print (($options{nolabel} == 0 ? 'WARNING: ' : '') . $self->{global_short_concat_outputs}->{WARNING} . " ");
      }
      if (defined($self->{global_short_concat_outputs}->{UNKNOWN})) {
          print (($options{nolabel} == 0 ? 'UNKNOWN: ' : '') . $self->{global_short_concat_outputs}->{UNKNOWN} . " ");
      }
      if (uc($options{exit_litteral}) eq 'OK') {
          print (($options{nolabel} == 0 ? 'OK: ' : '') . (defined($self->{global_short_concat_outputs}->{OK}) ? $self->{global_short_concat_outputs}->{OK} : '') . " ");
      }
  }
  
  sub output_txt_short {
      my ($self, %options) = @_;
      
      if (!defined($self->{option_results}->{change_short_output})) {
          $self->output_txt_short_display(%options);
          return ;
      }
      
      my $stdout = '';
      {
          local *STDOUT;
          open STDOUT, '>', \$stdout;
          $self->output_txt_short_display(%options);
      }
      
      foreach (@{$self->{option_results}->{change_short_output}}) {
           my ($pattern, $replace, $modifier) = split /~/;
           next if (!defined($pattern));
           $replace = '' if (!defined($replace));
           $modifier = '' if (!defined($modifier));
           eval "\$stdout =~ s{$pattern}{$replace}$modifier";
      }
      
      print $stdout;
  }
  
  sub output_txt {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
  
      if (defined($self->{global_short_concat_outputs}->{UNQUALIFIED_YET})) {
          $self->output_add(severity => uc($options{exit_litteral}), short_msg => $self->{global_short_concat_outputs}->{UNQUALIFIED_YET});
      }
  
      $self->output_txt_short(%options);
  
      if ($force_ignore_perfdata == 1) {
          print "\n";
      } else {
          print '|';
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if (defined($self->{option_results}->{filter_perfdata}) &&
                       $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
              $perf->{unit} = '' if (defined($self->{option_results}->{filter_uom}) &&
                  $perf->{unit} !~ /$self->{option_results}->{filter_uom}/);
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
              print " '" . $perf->{label} . "'=" . $perf->{value} . $perf->{unit} . ';' . $perf->{warning} . ';' . $perf->{critical} . ';' . $perf->{min} . ';' . $perf->{max};
          }
          print "\n";
      }
      
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          if (scalar(@{$self->{global_long_output}})) {
              print join("\n", @{$self->{global_long_output}});
              print "\n";
          }
      }
  }
  
  sub display {
      my ($self, %options) = @_;
      my $nolabel = defined($options{nolabel}) ? 1 : 0;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      $force_long_output = 1 if (defined($self->{option_results}->{debug}));
  
      if (defined($self->{option_results}->{output_file})) {
          if (!open (STDOUT, '>', $self->{option_results}->{output_file})) {
              $self->output_add(severity => 'UNKNOWN',
                                short_msg => "cannot open file  '" . $self->{option_results}->{output_file} . "': $!");
          }
      }
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $self->get_litteral_status(), 
                                nolabel => $nolabel, 
                                force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output);
              return ;
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $self->get_litteral_status(), 
                                 nolabel => $nolabel,
                                 force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output);
              return ;
          }
      } elsif (defined($self->{option_results}->{output_openmetrics})) {
          $self->output_openmetrics();
          return ;
      }
      
      $self->output_txt(
          exit_litteral => $self->get_litteral_status(), 
          nolabel => $nolabel,
          force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output
      );
  }
  
  sub die_exit {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
      # $options{nolabel} = interger label display
      my $exit_litteral = defined($options{exit_litteral}) ? $options{exit_litteral} : $self->{option_results}->{opt_exit};
      my $nolabel = defined($options{nolabel}) ? 1 : 0;
      # ignore long output in the following case
      $self->{option_results}->{verbose} = undef;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } 
  
      $self->output_txt(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
      $self->exit(exit_litteral => $exit_litteral);
  }
  
  sub option_exit {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
      # $options{nolabel} = interger label display
      my $exit_litteral = defined($options{exit_litteral}) ? $options{exit_litteral} : $self->{option_results}->{opt_exit};
      my $nolabel = defined($options{nolabel}) ? 1 : 0;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      }
  
      $self->output_txt(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
      $self->exit(exit_litteral => $exit_litteral);
  }
  
  sub exit {
      my ($self, %options) = @_;
      # $options{exit_litteral} = exit
      
      if (defined($options{exit_litteral})) {
          exit $self->{errors}->{uc($options{exit_litteral})};
      }
      exit $self->{errors}->{$self->{myerrors}->{$self->{global_status}}};
  }
  
  sub get_most_critical {
      my ($self, %options) = @_;
      my $current_status = 0; # For 'OK'
  
      foreach (@{$options{status}}) {
          if ($self->{myerrors_mask}->{uc($_)} > $current_status) {
              $current_status = $self->{myerrors_mask}->{uc($_)};
          }
      }
      return $self->{myerrors}->{$current_status};
  }
  
  sub get_litteral_status {
      my ($self, %options) = @_;
      
      if (defined($options{status})) {
          if (defined($self->{errors_num}->{$options{status}})) {
              return $self->{errors_num}->{$options{status}};
          }
          return $options{status};
      } else {
          return $self->{myerrors}->{$self->{global_status}};
      }
  }
  
  sub is_status {
      my ($self, %options) = @_;
      # $options{value} = string status 
      # $options{litteral} = value is litteral
      # $options{compare} = string status 
  
      if (defined($options{litteral})) {
          my $value = defined($options{value}) ? $options{value} : $self->get_litteral_status();
      
          if (uc($value) eq uc($options{compare})) {
              return 1;
          }
          return 0;
      }
  
      my $value = defined($options{value}) ? $options{value} : $self->{global_status};
      my $dec_val = $self->{myerrors_mask}->{$value};
      my $lresult = $value & $dec_val;
      # Need to manage 0
      if ($lresult > 0 || ($dec_val == 0 && $value == 0)) {
          return 1;
      }
      return 0;
  }
  
  sub is_litteral_status {
      my ($self, %options) = @_;
      # $options{status} = string status
  
      if (defined($self->{errors}->{uc($options{status})})) {
          return 1;
      }
  
      return 0;
  }
  
  sub create_json_document {
      my ($self) = @_;
  
      if (centreon::plugins::misc::mymodule_load(no_quit => 1, module => 'JSON',
                                             error_msg => "Cannot load module 'JSON'.")) {
          print "Cannot load module 'JSON'\n";
          $self->exit(exit_litteral => 'unknown');
      }
      $self->{is_output_json} = 1;
      $self->{json_output} = JSON->new->utf8();
  }
  
  sub create_xml_document {
      my ($self) = @_;
  
      if (centreon::plugins::misc::mymodule_load(no_quit => 1, module => 'XML::LibXML',
                                             error_msg => "Cannot load module 'XML::LibXML'.")) {
          print "Cannot load module 'XML::LibXML'\n";
          $self->exit(exit_litteral => 'unknown');
      }
      $self->{is_output_xml} = 1;
      $self->{xml_output} = XML::LibXML::Document->new('1.0', 'utf-8');
  }
  
  sub plugin {
      my ($self, %options) = @_;
      # $options{name} = string name
      
      if (defined($options{name})) {
          $self->{plugin} = $options{name};
      }
      return $self->{plugin};
  }
  
  sub mode {
      my ($self, %options) = @_;
      # $options{name} = string name
  
      if (defined($options{name})) {
          $self->{mode} = $options{name};
      }
      return $self->{mode};
  }
  
  sub add_disco_format {
      my ($self, %options) = @_;
  
      push @{$self->{disco_elements}}, @{$options{elements}};
  }
  
  sub display_disco_format {
      my ($self, %options) = @_;
      
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
      
          my $root = $self->{xml_output}->createElement('data');
          $self->{xml_output}->setDocumentElement($root);
  
          foreach (@{$self->{disco_elements}}) {
              my $child = $self->{xml_output}->createElement("element");
              $child->appendText($_);
              $root->addChild($child);
          }
  
          print $self->{xml_output}->toString(1);
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          my $json_content = {data => [] };
          foreach (@{$self->{disco_elements}}) {
              push @{$json_content->{data}}, $_;
          }
          
          print $self->{json_output}->encode($json_content);
      }
  }
  
  sub display_disco_show {
      my ($self, %options) = @_;
      
       if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          
          my $root = $self->{xml_output}->createElement('data');
          $self->{xml_output}->setDocumentElement($root);
  
          foreach (@{$self->{disco_entries}}) {
              my $child = $self->{xml_output}->createElement('label');
              foreach my $key (keys %$_) {
                  $child->setAttribute($key, $_->{$key});
              }
              $root->addChild($child);
          }
  
          print $self->{xml_output}->toString(1);
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          my $json_content = {data => [] };
          foreach (@{$self->{disco_entries}}) {
              my %values = ();
              foreach my $key (keys %$_) {
                  $values{$key} = $_->{$key};
              }
              push @{$json_content->{data}}, {%values};
          }
          
          print $self->{json_output}->encode($json_content);
      }
  }
  
  sub to_utf8 {
      my ($self, $value) = @_;
      
      if ($self->{encode_utf8_import} == 0) {
          # Some Perl version dont have the following module (like Perl 5.6.x)
          if (centreon::plugins::misc::mymodule_load(no_quit => 1, module => 'Encode',
                                                     error_msg => "Cannot load module 'Encode'.")) {
              print "Cannot load module 'Encode'\n";
              $self->exit(exit_litteral => 'unknown');
          }
          
          $self->{encode_utf8_import} = 1;
          eval '$self->{perlqq} = Encode::PERLQQ';
      }
      
      return centreon::plugins::misc::trim(Encode::decode('UTF-8', $value, $self->{perlqq}));
  }
  
  sub add_disco_entry {
      my ($self, %options) = @_;
      
      push @{$self->{disco_entries}}, {%options};
  }
  
  sub is_disco_format {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{disco_format})) {
          return 1;
      }
      return 0;
  }
  
  sub is_disco_show {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{disco_show})) {
          return 1;
      }
      return 0;
  }
  
  sub is_verbose {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{verbose})) {
          return 1;
      }
      return 0;
  }
  
  sub is_debug {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{debug})) {
          return 1;
      }
      return 0;
  }
  
  sub use_new_perfdata {
      my ($self, %options) = @_;
  
      $self->{option_results}->{use_new_perfdata} = $options{value}
          if (defined($options{value}));
      if (defined($self->{option_results}->{use_new_perfdata})) {
          return 1;
      }
      return 0;
  }
  
  sub get_instance_perfdata_separator {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{use_new_perfdata})) {
          return '~';
      }
      return '_';
  }
  
  sub parse_pfdata_scale {
      my ($self, %options) = @_;
      
      # --extend-perfdata=traffic_in,,scale(Mbps),mbps
      my $args = { unit => 'auto' };
      if ($options{args} =~ /^([KMGTPEkmgtpe])?(B|b|bps|Bps|b\/s|auto)$/) {
          $args->{quantity} = defined($1) ? $1 : '';
          $args->{unit} = $2;
      } elsif ($options{args} ne '') {
          return 1;
      }
      
      return (0, $args);
  }
  
  sub parse_pfdata_math {
      my ($self, %options) = @_;
  
      # --extend-perfdata=perfx,,math(current + 10 - 100, 1)
      my $args = { math => undef, apply_threshold => 0 };
      my ($math, $apply_threshold) = split /\|/, $options{args};
      if ($math =~ /^((?:[\s\.\-\+\*\/0-9\(\)]|current)+)$/) {
          $args->{math} = $1;
      } elsif ($options{args} ne '') {
          return 1;
      }
      
      if (defined($apply_threshold) && $apply_threshold =~ /^\s*(0|1)\s*$/ ) {
          $args->{apply_threshold} = $1;
      }
      
      return (0, $args);
  }
  
  sub parse_group_pfdata {
      my ($self, %options) = @_;
      
      $options{args} =~ s/^\s+//;
      $options{args} =~ s/\s+$//;
      my $args = { pattern_pf => $options{args} };
      return $args;
  }
  
  sub parse_pfdata_min {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_max {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_average {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_sum {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub apply_pfdata_scale {
      my ($self, %options) = @_;
      
      return if (${$options{perf}}->{unit} !~ /^([KMGTPEkmgtpe])?(B|b|bps|Bps|b\/s)$/);
      
      my ($src_quantity, $src_unit) = ($1, $2);
      my ($value, $dst_quantity, $dst_unit) = centreon::plugins::misc::scale_bytesbit(value => ${$options{perf}}->{value},
          src_quantity => $src_quantity, src_unit => $src_unit, dst_quantity => $options{args}->{quantity}, dst_unit => $options{args}->{unit});
      ${$options{perf}}->{value} = sprintf("%.2f", $value);
      if (defined($dst_unit)) {
         ${$options{perf}}->{unit} = $dst_quantity . $dst_unit;
      } else {
          ${$options{perf}}->{unit} = $options{args}->{quantity} . $options{args}->{unit};
      }
      
      if (defined(${$options{perf}}->{max}) && ${$options{perf}}->{max} ne '') {
          ($value) = centreon::plugins::misc::scale_bytesbit(value => ${$options{perf}}->{max},
              src_quantity => $src_quantity, src_unit => $src_unit, 
              dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity}, 
              dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          ${$options{perf}}->{max} = sprintf('%.2f', $value);
      }
      
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              ($result->{start}) = centreon::plugins::misc::scale_bytesbit(value => $result->{start},
                  src_quantity => $src_quantity, src_unit => $src_unit, 
                  dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity}, 
                  dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              ($result->{end}) = centreon::plugins::misc::scale_bytesbit(value => $result->{end},
                  src_quantity => $src_quantity, src_unit => $src_unit, 
                  dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity}, 
                  dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
  }
  
  sub apply_pfdata_invert {
      my ($self, %options) = @_;
      
      return if (!defined(${$options{perf}}->{max}) || ${$options{perf}}->{max} eq '');
      
      ${$options{perf}}->{value} = ${$options{perf}}->{max} - ${$options{perf}}->{value};
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
          
          my $tmp = { arobase => $result->{arobase}, infinite_pos => 0, infinite_neg => 0, start => $result->{start}, end => $result->{end} };
          $tmp->{infinite_neg} = 1 if ($result->{infinite_pos} == 1);
          $tmp->{infinite_pos} = 1 if ($result->{infinite_neg} == 1);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $tmp->{end} = ${$options{perf}}->{max} - $result->{start};
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $tmp->{start} = ${$options{perf}}->{max} - $result->{end};
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$tmp);
      }
  }
  
  sub apply_pfdata_percent {
      my ($self, %options) = @_;
  
      return if (!defined(${$options{perf}}->{max}) || ${$options{perf}}->{max} eq '');
      
      ${$options{perf}}->{value} = sprintf('%.2f', ${$options{perf}}->{value} * 100 / ${$options{perf}}->{max});
      ${$options{perf}}->{unit} = '%';
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $result->{start} = sprintf('%.2f', $result->{start} * 100 / ${$options{perf}}->{max});
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $result->{end} = sprintf('%.2f', $result->{end} * 100 / ${$options{perf}}->{max});
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
      
      ${$options{perf}}->{max} = 100; 
  }
  
  sub apply_pfdata_math {
      my ($self, %options) = @_;
      
      my $math = $options{args}->{math};
      $math =~ s/current/\$value/g;
      
      my $value = ${$options{perf}}->{value};
      eval "\${\$options{perf}}->{value} = $math";
      
      return if ($options{args}->{apply_threshold} == 0);
      
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $value = $result->{start};
              eval "\$result->{start} = $math";
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $value = $result->{end};
              eval "\$result->{end} = $math";
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
      
      ${$options{perf}}->{max} = 100;
  }
  
  sub apply_pfdata_min {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my $min;
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $min = $self->{perfdatas}->[$i]->{value}
              if (!defined($min) || $min > $self->{perfdatas}->[$i]->{value});
      }
  
      ${$options{perf}}->{value} = $min
          if (defined($min));
  }
  
  sub apply_pfdata_max {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my $max;
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $max = $self->{perfdatas}->[$i]->{value}
              if (!defined($max) || $max < $self->{perfdatas}->[$i]->{value});
      }
  
      ${$options{perf}}->{value} = $max
          if (defined($max));
  }
  
  sub apply_pfdata_sum {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my ($sum, $num) = (0, 0);
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $sum += $self->{perfdatas}->[$i]->{value};
          $num++;
      }
  
      ${$options{perf}}->{value} = $sum
          if ($num > 0);
  }
  
  sub apply_pfdata_average {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my ($sum, $num) = (0, 0);
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $sum += $self->{perfdatas}->[$i]->{value};
          $num++;
      }
  
      ${$options{perf}}->{value} = sprintf("%.2f", ($sum / $num))
          if ($num > 0);
  }
  
  sub load_perfdata_extend_args {
      my ($self, %options) = @_;
  
      foreach (
          [$self->{option_results}->{change_perfdata}, 1],
          [$self->{option_results}->{extend_perfdata}, 2],
          [$self->{option_results}->{extend_perfdata_group}, 3],
      ) {
          next if (!defined($_->[0]));
          foreach my $arg (@{$_->[0]}) {
              $self->parse_perfdata_extend_args(arg => $arg, type => $_->[1]);
          }
      }
  }
  
  sub parse_perfdata_extend_args {
      my ($self, %options) = @_;
      
      # --extend-perfdata=searchlabel,newlabel,method[,[newuom],[min],[max]]
      my ($pfdata_match, $pfdata_substitute, $method, $uom_sub, $min_sub, $max_sub) = 
          split /,/, $options{arg};
      return if ((!defined($pfdata_match) || $pfdata_match eq '') && $options{type} != 3);
      
      $self->{pfdata_extends} = [] if (!defined($self->{pfdata_extends}));
      my $pfdata_extends = {
          pfdata_match => defined($pfdata_match) && $pfdata_match ne '' ? $pfdata_match : undef,
          pfdata_substitute => defined($pfdata_substitute) && $pfdata_substitute ne '' ? $pfdata_substitute : undef,
          uom_sub => defined($uom_sub) && $uom_sub ne '' ? $uom_sub : undef,
          min_sub => defined($min_sub) && $min_sub ne '' ? $min_sub : undef,
          max_sub => defined($max_sub) && $max_sub ne '' ? $max_sub : undef,
          type => $options{type}
      };
  
      if (defined($method) && $method ne '') {
          if ($method !~ /^\s*(invert|percent|scale|math|min|max|average|sum)\s*\(\s*(.*?)\s*\)\s*$/) {
              $self->output_add(long_msg => "method in argument '$options{arg}' is unknown", debug => 1);
              return ;
          }
          
          $pfdata_extends->{method_name} = $1;
          my $args = $2;
          if (my $func = $self->can('parse_pfdata_' . $pfdata_extends->{method_name})) {
              (my $status, $pfdata_extends->{method_args}) = $func->($self, args => $args);
              if ($status == 1) {
                  $self->output_add(long_msg => "argument in method '$options{arg}' is unknown", debug => 1);
                  return ;
              }
          }
      }
  
      push  @{$self->{pfdata_extends}}, $pfdata_extends;
  }
  
  sub apply_perfdata_explode {
      my ($self, %options) = @_;
      
      return if ($self->{explode_perfdata_total} == 0);
      foreach (@{$self->{perfdatas}}) {
          next if ($_->{max} eq '');
          if ($self->{explode_perfdata_total} == 2) {
              $self->perfdata_add(label => $_->{label} . '_max', value => $_->{max});
              next;
          }
          foreach my $regexp (keys %{$self->{explode_perfdatas}}) {
              if ($_->{label} =~ /$regexp/) {
                  $self->perfdata_add(label => $self->{explode_perfdatas}->{$regexp}, value => $_->{max});
                  last;
              }
          }
      }
  }
  
  sub apply_perfdata_extend {
      my ($self, %options) = @_;
  
      foreach my $extend (@{$self->{pfdata_extends}}) {
          my $new_pfdata = [];
          
          # Manage special case when type group and pfdata_match empty
          if ($extend->{type} == 3 && (!defined($extend->{pfdata_match}) || $extend->{pfdata_match} eq '')) {
              next if (!defined($extend->{pfdata_substitute}) || $extend->{pfdata_substitute} eq '');
              my $new_perf = {
                  label => $extend->{pfdata_substitute}, value => '',
                  unit => defined($extend->{uom_sub}) ? $extend->{uom_sub} : '',
                  warning => '', critical => '',
                  min => defined($extend->{min_sub}) ? $extend->{min_sub} : '',
                  max => defined($extend->{max_sub}) ? $extend->{max_sub} : ''
              };
  
              if (defined($extend->{method_name})) {
                  my $func = $self->can('apply_pfdata_' . $extend->{method_name});
                  $func->($self, perf => \$new_perf, args => $extend->{method_args});
              }
  
              if (length($new_perf->{value})) {
                  push @{$self->{perfdatas}}, $new_perf;
              }
              next;
          }
          
          for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
              next if ($self->{perfdatas}->[$i]->{label} !~ /$extend->{pfdata_match}/);
              
              my $new_perf = { %{$self->{perfdatas}->[$i]} };
              if ($extend->{type} == 3) {
                  $new_perf = { label => $self->{perfdatas}->[$i]->{label}, value => '', unit => '', warning => '', critical => '', min => '', max => '' };
              }
              
              if (defined($extend->{pfdata_substitute})) {
                  eval "\$new_perf->{label} =~ s{$extend->{pfdata_match}}{$extend->{pfdata_substitute}}";
              }
  
              if (defined($extend->{method_name})) {
                  my $func = $self->can('apply_pfdata_' . $extend->{method_name});
                  $func->($self, perf => \$new_perf, args => $extend->{method_args});
              }
              
              $new_perf->{unit} = $extend->{uom_sub} if (defined($extend->{uom_sub}));
              $new_perf->{min} = $extend->{min_sub} if (defined($extend->{min_sub}));
              $new_perf->{max} = $extend->{max_sub} if (defined($extend->{max_sub}));
  
              if ($extend->{type} == 1) {
                  $self->{perfdatas}->[$i] = $new_perf;
              } else {
                  push @$new_pfdata, $new_perf if (length($new_perf->{value}));
              }
          }
  
          push @{$self->{perfdatas}}, @$new_pfdata;
      }
  }
  
  sub change_perfdata {
      my ($self, %options) = @_;
      
      $self->apply_perfdata_extend();
      $self->apply_perfdata_explode();
  }
  
  1;
  
  
  =head1 NAME
  
  Output class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 OUTPUT OPTIONS
  
  =over 8
  
  =item B<--verbose>
  
  Display long output.
  
  =item B<--debug>
  
  Display also debug messages.
  
  =item B<--filter-perfdata>
  
  Filter perfdata that match the regexp.
  
  =item B<--explode-perfdata-max>
  
  Put max perfdata (if it exist) in a specific perfdata 
  (without values: same with '_max' suffix) (Multiple options)
  
  =item B<--change-perfdata> B<--extend-perfdata> 
  
  Change or extend perfdata. 
  Syntax: --extend-perfdata=searchlabel,newlabel,target[,[newuom],[min],[max]]
  
  Common examples:
  
  =over 4
  
  Change storage free perfdata in used: --change-perfdata=free,used,invert()
  
  Change storage free perfdata in used: --change-perfdata=used,free,invert()
  
  Scale traffic values automaticaly: --change-perfdata=traffic,,scale(auto)
  
  Scale traffic values in Mbps: --change-perfdata=traffic_in,,scale(Mbps),mbps
  
  Change traffic values in percent: --change-perfdata=traffic_in,,percent()
  
  =back
  
  =item B<--extend-perfdata-group> 
  
  Extend perfdata from multiple perfdatas (methods in target are: min, max, average, sum)
  Syntax: --extend-perfdata-group=searchlabel,newlabel,target[,newuom]
  
  Common examples:
  
  =over 4
  
  Sum wrong packets from all interfaces (with interface need  --units-errors=absolute): --extend-perfdata-group=',packets_wrong,sum(packets_(discard|error)_(in|out))'
  
  Sum traffic by interface: --extend-perfdata-group='traffic_in_(.*),traffic_$1,sum(traffic_(in|out)_$1)'
  
  =back
  
  =item B<--change-short-output>
  
  Change short output display. --change-short-output=pattern~replace~modifier
  
  =item B<--range-perfdata>
  
  Change perfdata range thresholds display: 
  1 = start value equals to '0' is removed, 2 = threshold range is not display.
  
  =item B<--filter-uom>
  
  Filter UOM that match the regexp.
  
  =item B<--opt-exit>
  
  Optional exit code for an execution error (i.e. wrong option provided,
  SSH connection refused, timeout, etc)
  (Default: unknown).
  
  =item B<--output-xml>
  
  Display output in XML format.
  
  =item B<--output-json>
  
  Display output in JSON format.
  
  =item B<--output-openmetrics>
  
  Display metrics in OpenMetrics format.
  
  =item B<--output-file>
  
  Write output in file (can be used with json and xml options)
  
  =item B<--disco-format>
  
  Display discovery arguments (if the mode manages it).
  
  =item B<--disco-show>
  
  Display discovery values (if the mode manages it).
  
  =item B<--float-precision>
  
  Set the float precision for thresholds (Default: 8).
  
  =head1 DESCRIPTION
  
  B<output>.
  
  =cut
CENTREON_PLUGINS_OUTPUT

$fatpacked{"centreon/plugins/perfdata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PERFDATA';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::perfdata;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{output} = $options{output};
      # Typical Nagios Perfdata 'with ~ @ ..'
      $self->{threshold_label} = {};
      $self->{float_precision} = defined($self->{output}->{option_results}->{float_precision}) && $self->{output}->{option_results}->{float_precision} =~ /\d+/ ?  
          int($self->{output}->{option_results}->{float_precision}) : 8;
  
      return $self;
  }
  
  sub get_perfdata_for_output {
      my ($self, %options) = @_;
      # $options{label} : threshold label
      # $options{total} : percent threshold to transform in global
      # $options{cast_int} : cast absolute to int
      # $options{op} : operator to apply to start/end value (uses with 'value'})
      # $options{value} : value to apply with 'op' option
      
      if (!defined($self->{threshold_label}->{$options{label}}->{value}) || $self->{threshold_label}->{$options{label}}->{value} eq '') {
          return '';
      }
      
      my %perf_value = %{$self->{threshold_label}->{$options{label}}};
      
      if (defined($options{op}) && defined($options{value})) {
          eval "\$perf_value{start} = \$perf_value{start} $options{op} \$options{value}" if ($perf_value{infinite_neg} == 0);
          eval "\$perf_value{end} = \$perf_value{end} $options{op} \$options{value}" if ($perf_value{infinite_pos} == 0);
      }
      if (defined($options{total})) {
          $perf_value{start} = $perf_value{start} * $options{total} / 100 if ($perf_value{infinite_neg} == 0);
          $perf_value{end} = $perf_value{end} * $options{total} / 100 if ($perf_value{infinite_pos} == 0);
          $perf_value{start} = sprintf("%.2f", $perf_value{start}) if ($perf_value{infinite_neg} == 0 && (!defined($options{cast_int}) || $options{cast_int} != 1));
          $perf_value{end} = sprintf("%.2f", $perf_value{end}) if ($perf_value{infinite_pos} == 0 && (!defined($options{cast_int}) || $options{cast_int} != 1));
      }
      
      $perf_value{start} = int($perf_value{start}) if ($perf_value{infinite_neg} == 0 && defined($options{cast_int}) && $options{cast_int} == 1);
      $perf_value{end} = int($perf_value{end}) if ($perf_value{infinite_pos} == 0 && defined($options{cast_int}) && $options{cast_int} == 1);
      
      my $perf_output = ($perf_value{arobase} == 1 ? '@' : '') . 
                        (($perf_value{infinite_neg} == 0) ? $perf_value{start} : '~') . 
                        ':' . 
                        (($perf_value{infinite_pos} == 0) ? $perf_value{end} : '');
  
      return $perf_output;
  }
  
  sub threshold_validate {
      my ($self, %options) = @_;
      # $options{label} : threshold label
      # $options{value} : threshold value
  
      my $status = 1;
      $self->{threshold_label}->{$options{label}} = { value => $options{value}, start => undef, end => undef, arobase => undef, infinite_neg => undef, infinite_pos => undef };
      if (!defined($options{value}) || $options{value} eq '') {
          return $status;
      }
  
      ($status, my $result_perf) = 
          centreon::plugins::misc::parse_threshold(threshold => $options{value});
      $self->{threshold_label}->{$options{label}} = { %{$self->{threshold_label}->{$options{label}}}, %$result_perf };
      
      $self->{threshold_label}->{$options{label}}->{start_precision} = $self->{threshold_label}->{$options{label}}->{start};
      if ($self->{threshold_label}->{$options{label}}->{start} =~ /[.,]/) {
          $self->{threshold_label}->{$options{label}}->{start_precision} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $self->{threshold_label}->{$options{label}}->{start});
      }
      
      $self->{threshold_label}->{$options{label}}->{end_precision} = $self->{threshold_label}->{$options{label}}->{end};
      if ($self->{threshold_label}->{$options{label}}->{end} =~ /[.,]/) {
          $self->{threshold_label}->{$options{label}}->{end_precision} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $self->{threshold_label}->{$options{label}}->{end});
      }
      
      return $status;
  }
  
  sub threshold_check {
      my ($self, %options) = @_;
      # Can check multiple threshold. First match: out. Order is important
      # options{value}: value to compare
      # options{threshold}: ref to an array (example: [ {label => 'warning', exit_litteral => 'warning' }, {label => 'critical', exit_litteral => 'critical'} ]
      if ($options{value} =~ /[.,]/) {
          $options{value} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $options{value});
      }
      
      foreach (@{$options{threshold}}) {
          next if (!defined($self->{threshold_label}->{$_->{label}}));
          next if (!defined($self->{threshold_label}->{$_->{label}}->{value}) || $self->{threshold_label}->{$_->{label}}->{value} eq '');
          if ($self->{threshold_label}->{$_->{label}}->{arobase} == 0 && ($options{value} < $self->{threshold_label}->{$_->{label}}->{start_precision} || $options{value} > $self->{threshold_label}->{$_->{label}}->{end_precision})) {
              return $_->{exit_litteral};
          } elsif ($self->{threshold_label}->{$_->{label}}->{arobase}  == 1 && ($options{value} >= $self->{threshold_label}->{$_->{label}}->{start_precision} && $options{value} <= $self->{threshold_label}->{$_->{label}}->{end_precision})) {
              return $_->{exit_litteral};
          }
      }
  
      return 'ok';
  }
  
  sub trim {
      my ($self, $value) = @_;
      
      $value =~ s/^[ \t]+//;
      $value =~ s/[ \t]+$//;
      return $value;
  }
  
  sub change_bytes {
      my ($self, %options) = @_;
  
      my $value = $options{value};
      my $divide = defined($options{network}) ? 1000 : 1024;
      my @units = ('K', 'M', 'G', 'T');
      my $unit = '';
      my $sign = '';
  
      $sign = '-' if ($value != abs($value));
      $value = abs($value);
      
      for (my $i = 0; $i < scalar(@units); $i++) {
          last if (($value / $divide) < 1);
          $unit = $units[$i];
          $value = $value / $divide;
      }
  
      return (sprintf('%.2f', $sign . $value), $unit . (defined($options{network}) ? 'b' : 'B'));
  }
  
  1;
  
  
  =head1 NAME
  
  Perfdata class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 DESCRIPTION
  
  B<perfdata>.
  
  =cut
CENTREON_PLUGINS_PERFDATA

$fatpacked{"centreon/plugins/script.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SCRIPT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::script;
  
  use strict;
  use warnings;
  use centreon::plugins::output;
  use centreon::plugins::misc;
  use FindBin;
  use Pod::Usage;
  use Pod::Find qw(pod_where);
  
  my %handlers = (DIE => {});
  
  my $global_version = '20190704 (727d0077)';
  my $alternative_fatpacker = 1;
  
  sub new {
      my ($class) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{options} = undef;
      $self->{plugin} = undef;
      $self->{help} = undef;
  
      # Avoid to destroy because it keeps a ref on the object. 
      # A problem if we execute it multiple times in the same perl execution
      # Use prepare_destroy
      $self->set_signal_handlers;
      return $self;
  }
  
  sub prepare_destroy {
      my ($self) = @_;
  
      delete $handlers{DIE}->{$self};
  }
  
  sub set_signal_handlers {
      my $self = shift;
  
      $SIG{__DIE__} = \&class_handle_DIE;
      $handlers{DIE}->{$self} = sub { $self->handle_DIE($_[0]) };
  }
  
  sub class_handle_DIE {
      my ($msg) = @_;
  
      foreach (keys %{$handlers{DIE}}) {
          &{$handlers{DIE}->{$_}}($msg);
      }
  }
  
  sub handle_DIE {
      my ($self, $msg) = @_;
  
      return unless defined $^S and $^S == 0; # Ignore errors in eval
      $self->{output}->add_option_msg(short_msg => $msg);
      $self->{output}->die_exit();
  }
  
  sub get_global_version {
      return $global_version;
  }
  
  sub get_plugin {
      my ($self) = @_;
      
      ######
      # Need to load global 'Output' and 'Options'
      ######
      if ($alternative_fatpacker == 0) {
          require centreon::plugins::options;
          $self->{options} = centreon::plugins::options->new();
      } else {
          require centreon::plugins::alternative::FatPackerOptions;
          $self->{options} = centreon::plugins::alternative::FatPackerOptions->new();
      }
      $self->{output} = centreon::plugins::output->new(options => $self->{options});
      $self->{options}->set_output(output => $self->{output});
  
      $self->{options}->add_options(arguments => {
          'plugin:s'          => { name => 'plugin' },
          'list-plugin'       => { name => 'list_plugin' }, 
          'help'              => { name => 'help' },
          'ignore-warn-msg'   => { name => 'ignore_warn_msg' },
          'version'           => { name => 'version' },
          'runas:s'           => { name => 'runas' },
          'environment:s%'    => { name => 'environment' },
          'convert-args:s'    => { name => 'convert_args' },
      });
  
      $self->{options}->parse_options();
  
      $self->{plugin} = $self->{options}->get_option(argument => 'plugin' );
      $self->{list_plugin} = $self->{options}->get_option(argument => 'list_plugin' );
      $self->{help} = $self->{options}->get_option(argument => 'help' );
      $self->{version} = $self->{options}->get_option(argument => 'version' );
      $self->{runas} = $self->{options}->get_option(argument => 'runas' );
      $self->{environment} = $self->{options}->get_option(argument => 'environment' );
      $self->{ignore_warn_msg} = $self->{options}->get_option(argument => 'ignore_warn_msg' );
      $self->{convert_args} = $self->{options}->get_option(argument => 'convert_args' );
  
      $self->{output}->plugin(name => $self->{plugin});
      $self->{output}->check_options(option_results => $self->{options}->get_options());
  
      $self->{options}->clean();
  }
  
  sub convert_args {
      my ($self) = @_;
      
      if ($self->{convert_args} =~ /^(.+?),(.*)/) {
          my ($search, $replace) = ($1, $2);
          for (my $i = 0; $i <= $#ARGV; $i++) {
              eval "\$ARGV[\$i] =~ s/$search/$replace/g";
          }
      }
  }
  
  sub display_local_help {
      my ($self) = @_;
  
      my $stdout;
      if ($self->{help}) {
          local *STDOUT;
          open STDOUT, '>', \$stdout;
          
          if ($alternative_fatpacker == 0) {
              pod2usage(-exitval => 'NOEXIT', -input => pod_where({-inc => 1}, __PACKAGE__));
          } else {
              my $pp = __PACKAGE__ . '.pm';
              $pp =~ s{::}{/}g;
              my $content_class = $INC{$pp}->{$pp};
              open my $str_fh, '<', \$content_class;
              pod2usage(-exitval => 'NOEXIT', -input => $str_fh);
              close $str_fh;
          }
      }
      
      $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
  }
  
  sub check_directory {
      my ($self, $directory) = @_;
      
      opendir(my $dh, $directory) || return ;
      while (my $filename = readdir $dh) {
          $self->check_directory($directory . '/' . $filename) if ($filename !~ /^\./ && -d $directory . '/' . $filename);
          if ($filename eq 'plugin.pm') {
              my $stdout = '';
              
              {
                  local *STDOUT;
                  open STDOUT, '>', \$stdout;
                  pod2usage(-exitval => 'NOEXIT', -input => $directory . "/" . $filename,
                            -verbose => 99, 
                            -sections => "PLUGIN DESCRIPTION");
              }
              $self->{plugins_result}->{$directory . "/" . $filename} = $stdout;
          }
      }
      closedir $dh;
  }
  
  sub fatpacker_find_plugin {
      my ($self) = @_;
      
      my $plugins = [];
      foreach (@INC) {
          next if (ref($_) !~ /FatPacked/);
          foreach my $name (keys %$_) {
              if ($name =~ /plugin.pm$/) {
                  push @$plugins, $name;
              }
          }
      }
      
      return $plugins;
  }
  
  sub check_plugin_option {
      my ($self) = @_;
      
      if (defined($self->{version})) {
          $self->{output}->add_option_msg(short_msg => 'Global Version: ' . $global_version);
          $self->{output}->option_exit(nolabel => 1);
      }
      
      my $no_plugin = 1;
      if ($alternative_fatpacker == 1) {
          my $integrated_plugins = $self->fatpacker_find_plugin();
          if (scalar(@$integrated_plugins) == 1) {
              $self->{plugin} = $integrated_plugins->[0];
              $no_plugin = 0;
          }
      }
      
      if ($no_plugin == 1) {
          $self->{output}->add_option_msg(short_msg => "Need to specify '--plugin' option.");
          $self->{output}->option_exit();
      }
  }
  
  sub display_list_plugin {
      my ($self) = @_;
      $self->{plugins_result} = {};
      
      if ($alternative_fatpacker == 1) {
          my $integrated_plugins = $self->fatpacker_find_plugin();
          
          foreach my $key (@$integrated_plugins) {
              # Need to load it to get the description
              centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $key, 
                                                     error_msg => 'Cannot load module --plugin.');
                                                 
              my $name = $key;
              $name =~ s/\.pm//g;
              $name =~ s/\//::/g;
              $self->{output}->add_option_msg(long_msg => '-----------------');
              $self->{output}->add_option_msg(long_msg => 'PLUGIN: ' . $name);
              {
                  my $stdout = '';
                  local *STDOUT;
                  open STDOUT, '>', \$stdout;
                  my $content_class = $INC{$key}->{$key};
                  open my $str_fh, '<', \$content_class;
                  pod2usage(-exitval => 'NOEXIT', -input => $str_fh, -verbose => 99, -sections => 'PLUGIN DESCRIPTION');
                  close $str_fh;
                  $self->{output}->add_option_msg(long_msg => $stdout);
              }
          }
          return ;
      }
      
      # Search file 'plugin.pm'
      $self->check_directory($FindBin::Bin);
      foreach my $key (keys %{$self->{plugins_result}}) {
          my $name = $key;
          $name =~ s/^$FindBin::Bin\/(.*)\.pm/$1/;
          $name =~ s/\//::/g;
          $self->{plugins_result}->{$key} =~ s/^Plugin Description/DESCRIPTION/i;
          
          $self->{output}->add_option_msg(long_msg => '-----------------');
          $self->{output}->add_option_msg(long_msg => 'PLUGIN: ' . $name);
          $self->{output}->add_option_msg(long_msg => $self->{plugins_result}->{$key});
      }
  }
  
  sub check_relaunch {
      my $self = shift;
      my $need_restart = 0;
      my $cmd = $FindBin::Bin . "/" . $FindBin::Script;
      my @args = ();
      
      if (defined($self->{environment})) {
          foreach (keys %{$self->{environment}}) {
              if ($_ ne '' && (!defined($ENV{$_}) || $ENV{$_} ne $self->{environment}->{$_})) {
                  $ENV{$_} = $self->{environment}->{$_};
                  $need_restart = 1;
              }
          }
      }
      
      if (defined($self->{runas}) && $self->{runas} ne '') {
          # Check if it's already me and user exist ;)
          my ($name, $passwd, $uid) = getpwnam($self->{runas});
          if (!defined($uid)) {
              $self->{output}->add_option_msg(short_msg => "Runas user '" . $self->{runas} . "' not exist.");
              $self->{output}->option_exit();
          }
          if ($uid != $>) {
              if ($> == 0) {
                  unshift @args, "-s", "/bin/bash", "-l", $self->{runas}, "-c", join(" ", $cmd, "--plugin=" . $self->{plugin}, @ARGV);
                  $cmd = "su";
              } else {
                  unshift @args, "-S", "-u", $self->{runas}, $cmd, "--plugin=" . $self->{plugin}, @ARGV;
                  $cmd = "sudo";
              }
              $need_restart = 1;
          }
      }
  
      if ($need_restart == 1) {
          if (scalar(@args) <= 0) {
              unshift @args, @ARGV, '--plugin=' . $self->{plugin}
          }
  
          my ($lerror, $stdout, $exit_code) = centreon::plugins::misc::backtick(
              command => $cmd,
              arguments => [@args],
              timeout => 30,
              wait_exit => 1
          );
  
          if ($exit_code <= -1000) {
              if ($exit_code == -1000) {
                  $self->{output}->output_add(severity => 'UNKNOWN', 
                                              short_msg => $stdout);
              }
              $self->{output}->display();
              $self->{output}->exit();
          }
          print $stdout;
          # We put unknown
          if (!($exit_code >= 0 && $exit_code <= 4)) {
              exit 3;
          }
          exit $exit_code;
      }
  }
  
  sub run {
      my ($self) = @_;
  
      $self->get_plugin();
  
      if (defined($self->{help}) && !defined($self->{plugin})) {
          $self->display_local_help();
          $self->{output}->option_exit();
      }
      if (defined($self->{list_plugin})) {
          $self->display_list_plugin();
          $self->{output}->option_exit();
      }
      $self->check_plugin_option() if (!defined($self->{plugin}) || $self->{plugin} eq '');
      if (defined($self->{ignore_warn_msg})) {
          $SIG{__WARN__} = sub {};
      }
      $self->convert_args() if (defined($self->{convert_args}));
  
      $self->check_relaunch();
      
      (undef, $self->{plugin}) = 
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{plugin}, 
                                                 error_msg => 'Cannot load module --plugin.');
      my $plugin = $self->{plugin}->new(options => $self->{options}, output => $self->{output});
      $plugin->init(help => $self->{help},
                    version => $self->{version});
      $plugin->run();
  }
  
  1;
  
  
  =head1 NAME
  
  centreon_plugins.pl - main program to call Centreon plugins.
  
  =head1 SYNOPSIS
  
  centreon_plugins.pl [options]
  
  =head1 OPTIONS
  
  =over 8
  
  =item B<--plugin>
  
  Specify the path to the plugin.
  
  =item B<--list-plugin>
  
  Print available plugins.
  
  =item B<--version>
  
  Print global version.
  
  =item B<--help>
  
  Print a brief help message and exits.
  
  =item B<--ignore-warn-msg>
  
  Perl warn messages are ignored (not displayed).
  
  =item B<--runas>
  
  Run the script as a different user (prefer to use directly the good user).
  
  =item B<--environment>
  
  Set environment variables for the script (prefer to set it before running it for better performance).
  
  =item B<--convert-args>
  
  Change strings of arguments. Useful to use '!' in nrpe protocol.
  Example: --convert-args='##,\x21'
  
  =back
  
  =head1 DESCRIPTION
  
  B<centreon_plugins.pl> .
  
  =cut
CENTREON_PLUGINS_SCRIPT

$fatpacked{"centreon/plugins/script_snmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SCRIPT_SNMP';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::script_snmp;
  
  use strict;
  use warnings;
  use centreon::plugins::snmp;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      # $options{package} = parent package caller
      # $options{options} = options object
      # $options{output} = output object
      $self->{options} = $options{options};
      $self->{output} = $options{output};
      
      $self->{options}->add_options(
          arguments => {
              'mode:s'         => { name => 'mode_name' },
              'dyn-mode:s'     => { name => 'dynmode_name' },
              'list-mode'      => { name => 'list_mode' },
              'mode-version:s' => { name => 'mode_version' },
              'sanity-options' => { name => 'sanity_options' }, # keep it for 6 month before remove it
              'pass-manager:s' => { name => 'pass_manager' },
          }
      );
      $self->{version} = '1.0';
      %{$self->{modes}} = ();
      $self->{default} = undef;
      
      $self->{options}->parse_options();
      $self->{option_results} = $self->{options}->get_options();
      foreach (keys %{$self->{option_results}}) {
          $self->{$_} = $self->{option_results}->{$_};
      }
      $self->{options}->clean();
  
      $self->{options}->add_help(package => $options{package}, sections => 'PLUGIN DESCRIPTION');
      $self->{options}->add_help(package => __PACKAGE__, sections => 'GLOBAL OPTIONS');
      $self->{output}->mode(name => $self->{mode_name});
  
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      # $options{version} = string version
      # $options{help} = string help
  
      if (defined($options{help}) && !defined($self->{mode_name}) && !defined($self->{dynmode_name})) {
          $self->{options}->display_help();
          $self->{output}->option_exit();
      }
      if (defined($options{version}) && !defined($self->{mode_name}) && !defined($self->{dynmode_name})) {
          $self->version();
      }
      if (defined($self->{list_mode})) {
          $self->list_mode();
      }
      $self->{options}->set_sanity();
  
      # Output HELP
      $self->{options}->add_help(package => 'centreon::plugins::output', sections => 'OUTPUT OPTIONS');
  
      $self->load_password_mgr();
  
      # SNMP
      $self->{snmp} = centreon::plugins::snmp->new(options => $self->{options}, output => $self->{output});
  
      # Load mode
      if (defined($self->{mode_name}) && $self->{mode_name} ne '') {
          $self->is_mode(mode => $self->{mode_name});
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{modes}{$self->{mode_name}}, 
                                                 error_msg => "Cannot load module --mode.");
          $self->{mode} = $self->{modes}{$self->{mode_name}}->new(options => $self->{options}, output => $self->{output}, mode => $self->{mode_name});
      } elsif (defined($self->{dynmode_name}) && $self->{dynmode_name} ne '') {
          (undef, $self->{dynmode_name}) = centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{dynmode_name}, 
                                                                                  error_msg => "Cannot load module --dyn-mode.");
          $self->{mode} = $self->{dynmode_name}->new(options => $self->{options}, output => $self->{output}, mode => $self->{dynmode_name});
      } else {
          $self->{output}->add_option_msg(short_msg => "Need to specify '--mode' or '--dyn-mode' option.");
          $self->{output}->option_exit();
      }
  
      if (defined($options{help})) {
          if (defined($self->{mode_name}) && $self->{mode_name} ne '') {
              $self->{options}->add_help(package => $self->{modes}{$self->{mode_name}}, sections => 'MODE');
          } else {
              $self->{options}->add_help(package => $self->{dynmode_name}, sections => 'MODE');
          }
          $self->{options}->display_help();
          $self->{output}->option_exit();
      }
      if (defined($options{version})) {
          $self->{mode}->version();
          $self->{output}->option_exit(nolabel => 1);
      }
      if (centreon::plugins::misc::minimal_version($self->{mode}->{version}, $self->{mode_version}) == 0) {
          $self->{output}->add_option_msg(short_msg => "Not good version for plugin mode. Excepted at least: " . $self->{mode_version} . ". Get: ".  $self->{mode}->{version});
          $self->{output}->option_exit();
      }
      
      $self->{options}->parse_options();
      $self->{option_results} = $self->{options}->get_options();
      
      $self->{pass_mgr}->manage_options(option_results => $self->{option_results}) if (defined($self->{pass_mgr}));
      $self->{snmp}->check_options(option_results => $self->{option_results});
      $self->{mode}->check_options(option_results => $self->{option_results}, default => $self->{default}, snmp => $self->{snmp});
  }
  
  sub load_password_mgr {
      my ($self, %options) = @_;
      
      return if (!defined($self->{option_results}->{pass_manager}) || $self->{option_results}->{pass_manager} eq '');
  
      (undef, my $pass_mgr_name) = centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => "centreon::plugins::passwordmgr::" . $self->{option_results}->{pass_manager}, 
          error_msg => "Cannot load module 'centreon::plugins::passwordmgr::" . $self->{option_results}->{pass_manager} . "'"
      );
      $self->{pass_mgr} = $pass_mgr_name->new(options => $self->{options}, output => $self->{output});
  }
  
  sub run {
      my ($self) = @_;
  
      if ($self->{output}->is_disco_format()) {
          $self->{mode}->disco_format();
          $self->{output}->display_disco_format();
          $self->{output}->exit(exit_litteral => 'ok');
      }
  
      $self->{snmp}->connect();
      if ($self->{output}->is_disco_show()) {
          $self->{mode}->disco_show(snmp => $self->{snmp});
          $self->{output}->display_disco_show();
          $self->{output}->exit(exit_litteral => 'ok');
      } else {
          $self->{mode}->run(snmp => $self->{snmp});
      }
  }
  
  sub is_mode {
      my ($self, %options) = @_;
      
      # $options->{mode} = mode
      if (!defined($self->{modes}{$options{mode}})) {
          $self->{output}->add_option_msg(short_msg => "mode '" . $options{mode} . "' doesn't exist (use --list-mode option to show available modes).");
          $self->{output}->option_exit();
      }
  }
  
  sub version {
      my ($self) = @_;    
      $self->{output}->add_option_msg(short_msg => "Plugin Version: " . $self->{version});
      $self->{output}->option_exit(nolabel => 1);
  }
  
  sub list_mode {
      my ($self) = @_;
      $self->{options}->display_help();
      
      $self->{output}->add_option_msg(long_msg => "Modes Available:");
      foreach (sort keys %{$self->{modes}}) {
          $self->{output}->add_option_msg(long_msg => "   " . $_);
      }
      $self->{output}->option_exit(nolabel => 1);
  }
  
  1;
  
  
  =head1 NAME
  
  -
  
  =head1 SYNOPSIS
  
  -
  
  =head1 GLOBAL OPTIONS
  
  =over 8
  
  =item B<--mode>
  
  Choose a mode.
  
  =item B<--dyn-mode>
  
  Specify a mode with the path (separated by '::').
  
  =item B<--list-mode>
  
  List available modes.
  
  =item B<--mode-version>
  
  Check minimal version of mode. If not, unknown error.
  
  =item B<--version>
  
  Display plugin version.
  
  =item B<--pass-manager>
  
  Use a password manager.
  
  =back
  
  =head1 DESCRIPTION
  
  B<>.
  
  =cut
CENTREON_PLUGINS_SCRIPT_SNMP

$fatpacked{"centreon/plugins/snmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SNMP';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::snmp;
  
  use strict;
  use warnings;
  use SNMP;
  use Socket;
  use POSIX;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      # $options{options} = options object
      # $options{output} = output object
      # $options{exit_value} = integer
      
      if (!defined($options{output})) {
          print "Class SNMP: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class SNMP: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      if (!defined($options{noptions})) {
          $options{options}->add_options(arguments => {
              "hostname|host:s"           => { name => 'host' },
              "snmp-community:s"          => { name => 'snmp_community', default => 'public' },
              "snmp-version:s"            => { name => 'snmp_version', default => 1 },
              "snmp-port:s"               => { name => 'snmp_port', default => 161 },
              "snmp-timeout:s"            => { name => 'snmp_timeout', default => 1 },
              "snmp-retries:s"            => { name => 'snmp_retries', default => 5 },
              "maxrepetitions:s"          => { name => 'maxrepetitions', default => 50 },
              "subsetleef:s"              => { name => 'subsetleef', default => 50 },
              "subsettable:s"             => { name => 'subsettable', default => 100 },
              "snmp-autoreduce:s"         => { name => 'snmp_autoreduce' },
              "snmp-force-getnext"        => { name => 'snmp_force_getnext' },
              "snmp-username:s"           => { name => 'snmp_security_name' },
              "authpassphrase:s"          => { name => 'snmp_auth_passphrase' },
              "authprotocol:s"            => { name => 'snmp_auth_protocol' },
              "privpassphrase:s"          => { name => 'snmp_priv_passphrase' },
              "privprotocol:s"            => { name => 'snmp_priv_protocol' },
              "contextname:s"             => { name => 'snmp_context_name' },
              "contextengineid:s"         => { name => 'snmp_context_engine_id' },
              "securityengineid:s"        => { name => 'snmp_security_engine_id' },
              "snmp-errors-exit:s"        => { name => 'snmp_errors_exit', default => 'unknown' },
          });
      }
      $options{options}->add_help(package => __PACKAGE__, sections => 'SNMP OPTIONS');
  
      #####
      $self->{session} = undef;
      $self->{output} = $options{output};
      $self->{snmp_params} = {};
      
      # Dont load MIB
      $SNMP::auto_init_mib = 0;
      $ENV{MIBS} = '';
      # For snmpv v1 - get request retries when you have "NoSuchName"
      $self->{RetryNoSuch} = 1;
      # Dont try to translate OID (we keep value)
      $self->{UseNumeric} = 1;
      
      $self->{error_msg} = undef;
      $self->{error_status} = 0;
      
      return $self;
  }
  
  sub connect {
      my ($self, %options) = @_;
      
      $self->{snmp_params}->{RetryNoSuch} = $self->{RetryNoSuch};
      $self->{snmp_params}->{UseNumeric} = $self->{UseNumeric};
  
      if (!$self->{output}->is_litteral_status(status => $self->{snmp_errors_exit})) {
          $self->{output}->add_option_msg(short_msg => "Unknown value '" . $self->{snmp_errors_exit}  . "' for --snmp-errors-exit.");
          $self->{output}->option_exit(exit_litteral => 'unknown');
      }
      
      $self->{session} = new SNMP::Session(%{$self->{snmp_params}});
      if (!defined($self->{session})) {
          $self->{output}->add_option_msg(short_msg => 'SNMP Session : unable to create');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
      if ($self->{session}->{ErrorNum}) {
          $self->{output}->add_option_msg(short_msg => 'SNMP Session : ' . $self->{session}->{ErrorStr});
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  }
  
  sub load {
      my ($self, %options) = @_;
      # $options{oids} = ref to array of oids (example: ['.1.2', '.1.2'])
      # $options{instances} = ref to array of oids instances
      # $options{begin}, $args->{end} = integer instance end
      # $options{instance_regexp} = str
      # 3 way to use: with instances, with end, none
      
      if (defined($options{end})) {
          for (my $i = $options{begin}; $i <= $options{end}; $i++) {
              foreach (@{$options{oids}}) {
                  push @{$self->{oids_loaded}}, $_ . "." . $i;
              }
          }
          return ;
      }
      
      if (defined($options{instances})) {
          $options{instance_regexp} = defined($options{instance_regexp}) ? $options{instance_regexp} : '(\d+)$';
          foreach my $instance (@{$options{instances}}) {
              $instance =~ /$options{instance_regexp}/;
              foreach (@{$options{oids}}) {
                  push @{$self->{oids_loaded}}, $_ . "." . $1;
              }
          }
          return ;
      }
      
      push @{$self->{oids_loaded}}, @{$options{oids}};
  }
  
  sub autoreduce_table {
      my ($self, %options) = @_;
      
      return 1 if (defined($self->{snmp_force_getnext}) || $self->is_snmpv1());
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      
      return 1 if (${$options{repeat_count}} == 1);
      ${$options{repeat_count}} = int(${$options{repeat_count}} / $self->{snmp_autoreduce_divisor});
      ${$options{repeat_count}} = 1 if (${$options{repeat_count}} < 1);
      return 0;
  }
  
  sub autoreduce_multiple_table {
      my ($self, %options) = @_;
      
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      return 1 if (${$options{repeat_count}} == 1);
      
      ${$options{repeat_count}} = int(${$options{repeat_count}} / $self->{snmp_autoreduce_divisor});
      $self->{subsettable} = int($self->{subsettable} / $self->{snmp_autoreduce_divisor});
      ${$options{repeat_count}} = 1 if (${$options{repeat_count}} < 1);
      return 0;
  }
  
  sub autoreduce_leef {
      my ($self, %options) = @_;
      
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      
      return 1 if ($self->{subsetleef} == 1);
      $self->{subsetleef} = int($self->{subsetleef} / $self->{snmp_autoreduce_divisor});
      $self->{subsetleef} = 1 if ($self->{subsetleef} < 1);
      
      my $array_ref = [];
      my $subset_current = 0;
      my $subset_construct = [];
      foreach ([@{$options{current}}], @{$self->{array_ref_ar}}) {
          foreach my $entry (@$_) {;
              push @$subset_construct, [$entry->[0], $entry->[1]];
              $subset_current++;
              if ($subset_current == $self->{subsetleef}) {
                  push @$array_ref, \@$subset_construct;
                  $subset_construct = [];
                  $subset_current = 0;
              }
          }
      }
      
      if ($subset_current) {
          push @$array_ref, \@$subset_construct;
      }
  
      $self->{array_ref_ar} = \@$array_ref;
      return 0;
  }
  
  sub get_leef {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{nothing_quit} = integer
      # $options{oids} = ref to array of oids (example: ['.1.2', '.1.2'])
      
      # Returns array
      #    'undef' value for an OID means NoSuchValue
      
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
      
      if (!defined($options{oids})) {
          if ($#{$self->{oids_loaded}} < 0) {
              if ($dont_quit == 1) {
                  $self->set_error(error_status => -1, error_msg => "Need to specify OIDs");
                  return undef;
              }
              $self->{output}->add_option_msg(short_msg => 'Need to specify OIDs');
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
          push @{$options{oids}}, @{$self->{oids_loaded}};
          @{$self->{oids_loaded}} = ();
      }
      
      my $results = {};
      $self->{array_ref_ar} = [];
      my $subset_current = 0;
      my $subset_construct = [];
      foreach my $oid (@{$options{oids}}) {
          # Get last value
          next if ($oid !~ /(.*)\.(\d+)([\.\s]*)$/);
          
          my ($oid, $instance) = ($1, $2);
          $results->{$oid . "." . $instance} = undef;
          push @$subset_construct, [$oid, $instance];
          $subset_current++;
          if ($subset_current == $self->{subsetleef}) {
              push @{$self->{array_ref_ar}}, \@$subset_construct;
              $subset_construct = [];
              $subset_current = 0;
          }
      }
      if ($subset_current) {
          push @{$self->{array_ref_ar}}, \@$subset_construct;
      }
      
      ############################
      # If wrong oid with SNMP v1, packet resent (2 packets more). Not the case with SNMP > 1.
      # Can have "NoSuchName", if nothing works...
      # = v1: wrong oid
      #   bless( [
      #       '.1.3.6.1.2.1.1.3',
      #       '0',
      #       '199720062',
      #       'TICKS'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #       '.1.3.6.1.2.1.1.999',
      #       '0'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #       '.1.3.6.1.2.1.1',
      #       '1000'
      #       ], 'SNMP::Varbind' )
      # > v1: wrong oid
      #   bless( [
      #        '.1.3.6.1.2.1.1.3',
      #        '0',
      #        '199728713',
      #        'TICKS'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #         '.1.3.6.1.2.1.1',
      #         '3',
      #         'NOSUCHINSTANCE',
      #        'TICKS'
      #    ], 'SNMP::Varbind' )
      #   bless( [
      #        '.1.3.6.1.2.1.1.999',
      #        '0',
      #        'NOSUCHOBJECT',
      #        'NOSUCHOBJECT'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #        '.1.3.6.1.2.1.1',
      #        '1000',
      #        'NOSUCHOBJECT',
      #        'NOSUCHOBJECT'
      #       ], 'SNMP::Varbind' )
      ############################
      
      my $total = 0;
      while (my $entry = shift(@{$self->{array_ref_ar}})) {
          my $vb = new SNMP::VarList(@{$entry});
          $self->{session}->get($vb);
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              # -24  Timeout
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. We next.
                  next;
              }
  
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_leef(current => $entry) == 0);
              }
              my $msg = 'SNMP GET Request : ' . $self->{session}->{ErrorStr};    
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
              
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
          
          # Some equipments gives a partial response and no error.
          # We look the last value if it's empty or not
          # In snmpv1 we have the retryNoSuch
          if (((scalar(@$vb) != scalar(@{$entry})) || (scalar(@{@$vb[-1]}) < 3)) && !$self->is_snmpv1()) {
              next if ($self->{snmp_autoreduce} == 1 && $self->autoreduce_leef(current => $entry) == 0);
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => "SNMP partial response. Please try --snmp-autoreduce option");
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
              
              $self->set_error(error_status => -1, error_msg => "SNMP partial response");
              return undef;
          }
  
          foreach my $entry (@$vb) {
              if ($#$entry < 3) {
                  # Can be snmpv1 not find
                  next;
              }
              if (${$entry}[2] eq 'NOSUCHOBJECT' || ${$entry}[2] eq 'NOSUCHINSTANCE') {
                  # Error in snmp > 1
                  next;
              }
              
              $total++;
              $results->{${$entry}[0] . "." . ${$entry}[1]} = ${$entry}[2];
          }
      }
      
      if ($nothing_quit == 1 && $total == 0) {
          $self->{output}->add_option_msg(short_msg => "SNMP GET Request : Cant get a single value.");
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
      
      return $results;
  }
  
  sub multiple_find_bigger {
      my ($self, %options) = @_;
      
      my $getting = {};
      my @values = ();
      foreach my $key (keys %{$options{working_oids}}) {
          push @values, $options{working_oids}->{$key}->{start};
          $getting->{ $options{working_oids}->{$key}->{start} } = $key;
      }
      @values = $self->oid_lex_sort(@values);
      
      return $getting->{pop(@values)};
  }
  
  sub get_multiple_table {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oids} = refs array
      #     [ { oid => 'x.x.x.x', start => '', end => ''}, { oid => 'y.y.y.y', start => '', end => ''} ]
      # $options{return_type} = integer
      
      my ($return_type) = (defined($options{return_type}) && $options{return_type} == 1) ? 1 : 0;
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
      
      my $working_oids = {};
      my $results = {};
      # Check overlap
      foreach my $entry (@{$options{oids}}) {
          # Transform asking
          if ($entry->{oid} !~ /(.*)\.(\d+)([\.\s]*)$/) {
              if ($dont_quit == 1) {
                  $self->set_error(error_status => -1, error_msg => "Method 'get_multiple_table': Wrong OID '" . $entry->{oid} . "'.");
                  return undef;
              }
              $self->{output}->add_option_msg(short_msg => "Method 'get_multiple_table': Wrong OID '" . $entry->{oid} . "'.");
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      
          if (defined($entry->{start})) {
              $working_oids->{$entry->{oid}} = { start => $entry->{start}, end => $entry->{end} }; # last in it
          } else {
              $working_oids->{$entry->{oid}} = { start => $entry->{oid}, end => $entry->{end} };
          }
          
          if ($return_type == 0) {
              $results->{$entry->{oid}} = {};
          }
      }
      
      # we use a medium (UDP have a PDU limit. SNMP protcol cant send multiples for one request)
      # So we need to manage
      # It's for "bulk". We ask 50 next values. If you set 1, it's like a getnext (snmp v1)
      my $repeat_count = 50;
      if (defined($self->{maxrepetitions}) && 
          $self->{maxrepetitions} =~ /^\d+$/) {
          $repeat_count = $self->{maxrepetitions};
      }
          
      # Quit if base not the same or 'ENDOFMIBVIEW' value. Need all oid finish otherwise we continue :)
      while (1) {
          my $current_oids = 0;
          my @bindings = ();
          my @bases = ();
          foreach my $key (keys %{$working_oids}) {
              $working_oids->{$key}->{start} =~ /(.*)\.(\d+)([\.\s]*)$/;
              push @bindings, [$1, $2];
              push @bases, $key;
              
              $current_oids++;
              last if ($current_oids > $self->{subsettable});
          }
          
          # Nothing more to check. We quit
          last if ($current_oids == 0);
          
          my $vb = new SNMP::VarList(@bindings);
          
          if ($self->is_snmpv1() || defined($self->{snmp_force_getnext})) {
              $self->{session}->getnext($vb);
          } else {
              my $current_repeat_count = floor($repeat_count / $current_oids);
              $current_repeat_count = 1 if ($current_repeat_count == 0);
              $self->{session}->getbulk(0, $current_repeat_count, $vb);
          }
          
          # Error
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. Need to find the most up oid ;)
                  my $oid_base = $self->multiple_find_bigger(working_oids => $working_oids);
                  delete $working_oids->{$oid_base};
                  next;
              }
              
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_multiple_table(repeat_count => \$repeat_count) == 0);
              }
              
              my $msg = 'SNMP Table Request : ' . $self->{session}->{ErrorStr};
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
              
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
          
          # Manage
          # step by step: [ 1 => 1, 2 => 1, 3 => 1 ], [ 1 => 2, 2 => 2, 3 => 2 ],...
          
          my $pos = -1;
          foreach my $entry (@$vb) {
              $pos++;
          
              # Already destruct. we continue
              next if (!defined($working_oids->{ $bases[$pos % $current_oids] }));
          
              # ENDOFMIBVIEW is on each iteration. So we need to delete and skip after that
              if (${$entry}[2] eq 'ENDOFMIBVIEW') {
                  delete $working_oids->{ $bases[$pos % $current_oids] };
                  # END mib
                  next;
              }
          
              # Not in same table
              my $complete_oid = ${$entry}[0] . "." . ${$entry}[1];
              my $base = $bases[$pos % $current_oids];
              if ($complete_oid !~ /^$base\./ ||
                  (defined($working_oids->{ $bases[$pos % $current_oids] }->{end}) && 
                   $self->check_oid_up(current => $complete_oid, end => $working_oids->{ $bases[$pos % $current_oids] }->{end}))) {
                  delete $working_oids->{ $bases[$pos % $current_oids] };
                  next;
              }
          
              if ($return_type == 0) {
                  $results->{$bases[$pos % $current_oids]}->{$complete_oid} = ${$entry}[2];
              } else {
                  $results->{$complete_oid} = ${$entry}[2];
              }
  
              $working_oids->{ $bases[$pos % $current_oids] }->{start} = $complete_oid;
          }
          
          # infinite loop. Some equipments it returns nothing!!??
          if ($pos == -1) {
              $self->{output}->add_option_msg(short_msg => "SNMP Table Request: problem to get values (try --snmp-force-getnext option)");
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      }
      
      my $total = 0;
      if ($nothing_quit == 1) {
          if ($return_type == 1) {
              $total = scalar(keys %{$results});
          } else {
              foreach (keys %{$results}) {
                  $total += scalar(keys %{$results->{$_}});
              }
          }
          
          if ($total == 0) {
              $self->{output}->add_option_msg(short_msg => "SNMP Table Request: Cant get a single value.");
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      }
      
      return $results;
  }
  
  sub get_table {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oid} = string (example: '.1.2')
      # $options{start} = string (example: '.1.2')
      # $options{end} = string (example: '.1.2')
      
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
      
      if (defined($options{start})) {
          $options{start} = $self->clean_oid($options{start});
      }
      if (defined($options{end})) {
          $options{end} = $self->clean_oid($options{end});
      }
      
      # we use a medium (UDP have a PDU limit. SNMP protcol cant send multiples for one request)
      # So we need to manage
      # It's for "bulk". We ask 50 next values. If you set 1, it's like a getnext (snmp v1)
      my $repeat_count = 50;
      if (defined($self->{maxrepetitions}) && 
          $self->{maxrepetitions} =~ /^\d+$/) {
          $repeat_count = $self->{maxrepetitions};
      }
      
      # Transform asking
      if ($options{oid} !~ /(.*)\.(\d+)([\.\s]*)$/) {
          if ($dont_quit == 1) {
              $self->set_error(error_status => -1, error_msg => "Method 'get_table': Wrong OID '" . $options{oid} . "'.");
              return undef;
          }
          $self->{output}->add_option_msg(short_msg => "Method 'get_table': Wrong OID '" . $options{oid} . "'.");
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
      
      my $main_indice = $1 . "." . $2;
      my $results = {};
      
      # Quit if base not the same or 'ENDOFMIBVIEW' value
      my $leave = 1;
      my $last_oid;
  
      if (defined($options{start})) {
          $last_oid = $options{start};
      } else {
          $last_oid = $options{oid};
      }
      while ($leave) {
          $last_oid =~ /(.*)\.(\d+)([\.\s]*)$/;
          my $vb = new SNMP::VarList([$1, $2]);
      
          if ($self->is_snmpv1() || defined($self->{snmp_force_getnext})) {
              $self->{session}->getnext($vb);
          } else {
              $self->{session}->getbulk(0, $repeat_count, $vb);
          }
          
          # Error
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              # -24  Timeout
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. We quit.
                  last;
              }
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_table(repeat_count => \$repeat_count) == 0);
              }
              
              my $msg = 'SNMP Table Request : ' . $self->{session}->{ErrorStr};
          
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
              
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
          
          # Manage
          foreach my $entry (@$vb) {
              if (${$entry}[2] eq 'ENDOFMIBVIEW') {
                  # END mib
                  $leave = 0;
                  last;
              }
          
              # Not in same table
              my $complete_oid = ${$entry}[0] . "." . ${$entry}[1];
              if ($complete_oid !~ /^$main_indice\./ ||
                  (defined($options{end}) && $self->check_oid_up(current => $complete_oid, end => $options{end}))) {
                  $leave = 0;
                  last;
              }
          
              $results->{$complete_oid} = ${$entry}[2];
              $last_oid = $complete_oid;
          }
      }
      
      if ($nothing_quit == 1 && scalar(keys %$results) == 0) {
          $self->{output}->add_option_msg(short_msg => "SNMP Table Request: Cant get a single value.");
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
      
      return $results;
  }
  
  sub set {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oids} = ref to hash table
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      $self->set_error();
  
      my $vars = [];
      foreach my $oid (keys %{$options{oids}}) {
          # Get last value
          next if ($oid !~ /(.*)\.(\d+)([\.\s]*)$/);
          
          my $value = $options{oids}->{$oid}->{value};
          my $type = $options{oids}->{$oid}->{type};
          my ($oid, $instance) = ($1, $2);
         
          push @$vars, [$oid, $instance, $value, $type];
      }
      
      $self->{session}->set($vars);
      if ($self->{session}->{ErrorNum}) {
          # 0    noError       Pas d'erreurs.
          # 1    tooBig        Reponse de taille trop grande.
          # 2    noSuchName    Variable inexistante.
      
          my $msg = 'SNMP SET Request : ' . $self->{session}->{ErrorStr};
          if ($dont_quit == 0) {
              $self->{output}->add_option_msg(short_msg => $msg);
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
          
          $self->set_error(error_status => -1, error_msg => $msg);
          return undef;
      }
  
      return 0;
  }
  
  sub is_snmpv1 {
      my ($self) = @_;
      
      if ($self->{snmp_params}->{Version} eq '1') {
          return 1;
      }
      return 0;
  }
  
  sub clean_oid {
      my ($self, $oid) = @_;
      
      $oid =~ s/\.$//;
      $oid =~ s/^(\d)/\.$1/;
      return $oid;
  }
  
  sub check_oid_up {
      my ($self, %options) = @_;
  
      my $current_oid = $options{current};
      my $end_oid = $options{end};
      
      my @current_oid_splitted = split /\./, $current_oid;
      my @end_oid_splitted = split /\./, $end_oid;
      # Skip first value (before first '.' empty)
      for (my $i = 1; $i <= $#current_oid_splitted && $i <= $#end_oid_splitted; $i++) {
          if (int($current_oid_splitted[$i]) > int($end_oid_splitted[$i])) {
              return 1;
          }
      }
      
      return 0;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      # $options{option_results} = ref to options result
      
      if (!defined($options{option_results}->{host})) {
          $self->{output}->add_option_msg(short_msg => "Missing parameter --hostname.");
          $self->{output}->option_exit();
      }
  
      $options{option_results}->{snmp_version} =~ s/^v//;
      if ($options{option_results}->{snmp_version} !~ /1|2c|2|3/) {
          $self->{output}->add_option_msg(short_msg => "Unknown snmp version.");
          $self->{output}->option_exit();
      }
  
      $self->{snmp_force_getnext} = $options{option_results}->{snmp_force_getnext};
      $self->{maxrepetitions} = $options{option_results}->{maxrepetitions};
      $self->{subsetleef} = (defined($options{option_results}->{subsetleef}) && $options{option_results}->{subsetleef} =~ /^[0-9]+$/) ? $options{option_results}->{subsetleef} : 50;
      $self->{subsettable} = (defined($options{option_results}->{subsettable}) && $options{option_results}->{subsettable} =~ /^[0-9]+$/) ? $options{option_results}->{subsettable} : 100;
      $self->{snmp_errors_exit} = $options{option_results}->{snmp_errors_exit};
      $self->{snmp_autoreduce} = 0;
      $self->{snmp_autoreduce_divisor} = 2;
      if (defined($options{option_results}->{snmp_autoreduce})) {
          $self->{snmp_autoreduce} = 1;
          $self->{snmp_autoreduce_divisor} = $1 if ($options{option_results}->{snmp_autoreduce} =~ /(\d+(\.\d+)?)/ && $1 > 1);
      }
  
      %{$self->{snmp_params}} = (DestHost => $options{option_results}->{host},
                                 Community => $options{option_results}->{snmp_community},
                                 Version => $options{option_results}->{snmp_version},
                                 RemotePort => $options{option_results}->{snmp_port},
                                 Retries => 5);
      
      if (defined($options{option_results}->{snmp_timeout}) && $options{option_results}->{snmp_timeout} =~ /^[0-9]+$/) {
          $self->{snmp_params}->{Timeout} = $options{option_results}->{snmp_timeout} * (10**6);
      }
      
      if (defined($options{option_results}->{snmp_retries}) && $options{option_results}->{snmp_retries} =~ /^[0-9]+$/) {
          $self->{snmp_params}->{Retries} = $options{option_results}->{snmp_retries};
      }
  
      if ($options{option_results}->{snmp_version} eq "3") {
  
          $self->{snmp_params}->{Context} = $options{option_results}->{snmp_context_name} if (defined($options{option_results}->{snmp_context_name}));
          $self->{snmp_params}->{ContextEngineId} = $options{option_results}->{snmp_context_engine_id} if (defined($options{option_results}->{snmp_context_engine_id}));
          $self->{snmp_params}->{SecEngineId} = $options{option_results}->{snmp_security_engine_id} if (defined($options{option_results}->{snmp_security_engine_id}));
          $self->{snmp_params}->{SecName} = $options{option_results}->{snmp_security_name} if (defined($options{option_results}->{snmp_security_name}));
          
          # Certificate SNMPv3. Need net-snmp > 5.6
          if ($options{option_results}->{host} =~ /^(dtls|tls|ssh).*:/) {
              $self->{snmp_params}->{OurIdentity} = $options{option_results}->{snmp_our_identity} if (defined($options{option_results}->{snmp_our_identity}));
              $self->{snmp_params}->{TheirIdentity} = $options{option_results}->{snmp_their_identity} if (defined($options{option_results}->{snmp_their_identity}));
              $self->{snmp_params}->{TheirHostname} = $options{option_results}->{snmp_their_hostname} if (defined($options{option_results}->{snmp_their_hostname}));
              $self->{snmp_params}->{TrustCert} = $options{option_results}->{snmp_trust_cert} if (defined($options{option_results}->{snmp_trust_cert}));
              $self->{snmp_params}->{SecLevel} = 'authPriv';
              return ;
          }
          
  
          if (!defined($options{option_results}->{snmp_security_name}) || $options{option_results}->{snmp_security_name} eq '') {
              $self->{output}->add_option_msg(short_msg => "Missing parameter Security Name.");
              $self->{output}->option_exit();
          }
          
          # unauthenticated and unencrypted
          $self->{snmp_params}->{SecLevel} = 'noAuthNoPriv';
          
          my $user_activate = 0;
          if (defined($options{option_results}->{snmp_auth_passphrase}) && $options{option_results}->{snmp_auth_passphrase} ne '') {
              if (!defined($options{option_results}->{snmp_auth_protocol})) {
                  $self->{output}->add_option_msg(short_msg => "Missing parameter authenticate protocol.");
                  $self->{output}->option_exit();
              }
              $options{option_results}->{snmp_auth_protocol} = uc($options{option_results}->{snmp_auth_protocol});
              if ($options{option_results}->{snmp_auth_protocol} ne "MD5" && $options{option_results}->{snmp_auth_protocol} ne "SHA") {
                  $self->{output}->add_option_msg(short_msg => "Wrong authentication protocol. Must be MD5 or SHA.");
                  $self->{output}->option_exit();
              }
              
              $self->{snmp_params}->{SecLevel} = 'authNoPriv';
              $self->{snmp_params}->{AuthProto} = $options{option_results}->{snmp_auth_protocol};
              $self->{snmp_params}->{AuthPass} = $options{option_results}->{snmp_auth_passphrase};
              $user_activate = 1;
          }
  
          if (defined($options{option_results}->{snmp_priv_passphrase}) && $options{option_results}->{snmp_priv_passphrase} ne '') {
              if (!defined($options{option_results}->{snmp_priv_protocol})) {
                  $self->{output}->add_option_msg(short_msg => "Missing parameter privacy protocol.");
                  $self->{output}->option_exit();
              }
              
              $options{option_results}->{snmp_priv_protocol} = uc($options{option_results}->{snmp_priv_protocol});
              if ($options{option_results}->{snmp_priv_protocol} ne 'DES' && $options{option_results}->{snmp_priv_protocol} ne 'AES') {
                  $self->{output}->add_option_msg(short_msg => "Wrong privacy protocol. Must be DES or AES.");
                  $self->{output}->option_exit();
              }
              if ($user_activate == 0) {
                  $self->{output}->add_option_msg(short_msg => "Cannot use snmp v3 privacy option without snmp v3 authentification options.");
                  $self->{output}->option_exit();
              }
              $self->{snmp_params}->{SecLevel} = 'authPriv';
              $self->{snmp_params}->{PrivPass} = $options{option_results}->{snmp_priv_passphrase};
              $self->{snmp_params}->{PrivProto} = $options{option_results}->{snmp_priv_protocol};
          }
      }
  }
  
  sub set_snmp_connect_params {
      my ($self, %options) = @_;
      
      foreach (keys %options) {
          $self->{snmp_params}->{$_} = $options{$_};
      }
  }
  
  sub set_snmp_params {
      my ($self, %options) = @_;
      
      foreach (keys %options) {
          $self->{$_} = $options{$_};
      }
  }
  
  sub set_error {
      my ($self, %options) = @_;
      # $options{error_msg} = string error
      # $options{error_status} = integer status
      
      $self->{error_status} = defined($options{error_status}) ? $options{error_status} : 0;
      $self->{error_msg} = defined($options{error_msg}) ? $options{error_msg} : undef;
  }
  
  sub error_status {
       my ($self) = @_;
      
      return $self->{error_status};
  }
  
  sub error {
      my ($self) = @_;
      
      return $self->{error_msg};
  }
  
  sub get_hostname {
      my ($self) = @_;
  
      my $host = $self->{snmp_params}->{DestHost};
      $host =~ s/.*://;
      return $host;
  }
  
  sub get_port {
      my ($self) = @_;
  
      return $self->{snmp_params}->{RemotePort};
  }
  
  sub map_instance {
      my ($self, %options) = @_;
      
      my $results = {};
      my $instance = '';
      $instance = '.' . $options{instance} if (defined($options{instance}));
      foreach my $name (keys %{$options{mapping}}) {
          my $entry = $options{mapping}->{$name}->{oid} . $instance;
          if (defined($options{results}->{$entry})) {
              $results->{$name} = $options{results}->{$entry};
          } elsif (defined($options{results}->{$options{mapping}->{$name}->{oid}}->{$entry})) {
              $results->{$name} = $options{results}->{$options{mapping}->{$name}->{oid}}->{$entry};
          } elsif (defined($options{mapping}->{$name}->{location}) && 
                  defined($options{results}->{$options{mapping}->{$name}->{location}}->{$entry})) {
              $results->{$name} = $options{results}->{$options{mapping}->{$name}->{location}}->{$entry};
          } else {
              $results->{$name} = defined($options{default}) ? $options{default} : undef;
          }
          
          if (defined($options{mapping}->{$name}->{map})) {
              if (defined($results->{$name})) {
                  $results->{$name} = defined($options{mapping}->{$name}->{map}->{$results->{$name}}) ? $options{mapping}->{$name}->{map}->{$results->{$name}} : (defined($options{default}) ? $options{default} : 'unknown');
              }
          }
      }
      
      return $results;
  }
  
  sub oid_lex_sort {
      my $self = shift;
  
      if (@_ <= 1) {
          return @_;
      }
  
      return map { $_->[0] }
              sort { $a->[1] cmp $b->[1] }
                  map
                  {
                     my $oid = $_;
                     $oid =~ s/^\.//;
                     $oid =~ s/ /\.0/g;
                     [$_, pack 'N*', split m/\./, $oid]
                  } @_;
  }
  
  1;
  
  
  =head1 NAME
  
  SNMP global
  
  =head1 SYNOPSIS
  
  snmp class
  
  =head1 SNMP OPTIONS
  
  =over 8
  
  =item B<--hostname>
  
  Hostname to query (required).
  
  =item B<--snmp-community>
  
  Read community (defaults to public).
  
  =item B<--snmp-version>
  
  Version: 1 for SNMP v1 (default), 2 for SNMP v2c, 3 for SNMP v3.
  
  =item B<--snmp-port>
  
  Port (default: 161).
  
  =item B<--snmp-timeout>
  
  Timeout in secondes (default: 1) before retries.
  
  =item B<--snmp-retries>
  
  Set the number of retries (default: 5) before failure.
  
  =item B<--maxrepetitions>
  
  Max repetitions value (default: 50) (only for SNMP v2 and v3).
  
  =item B<--subsetleef>
  
  How many oid values per SNMP request (default: 50) (for get_leef method. Be cautious whe you set it. Prefer to let the default value).
  
  =item B<--snmp-autoreduce>
   
  Auto reduce SNMP request size in case of SNMP errors (By default, the divisor is 2).
  
  =item B<--snmp-force-getnext>
  
  Use snmp getnext function (even in snmp v2c and v3).
  
  =item B<--snmp-username>
  
  Security name (only for SNMP v3).
  
  =item B<--authpassphrase>
  
  Authentication protocol pass phrase.
  
  =item B<--authprotocol>
  
  Authentication protocol (MD5|SHA)
  
  =item B<--privpassphrase>
  
  Privacy protocol pass phrase
  
  =item B<--privprotocol>
  
  Privacy protocol (DES|AES)
  
  =item B<--contextname>
  
  Context name
  
  =item B<--contextengineid>
  
  Context engine ID
  
  =item B<--securityengineid>
  
  Security engine ID
  
  =item B<--snmp-errors-exit>
  
  Exit code for SNMP Errors (default: unknown)
  
  =back
  
  =head1 DESCRIPTION
  
  B<snmp>.
  
  =cut
CENTREON_PLUGINS_SNMP

$fatpacked{"centreon/plugins/statefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_STATEFILE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::statefile;
  
  use strict;
  use warnings;
  use Data::Dumper;
  use vars qw($datas);
  use centreon::plugins::misc;
  
  my $default_dir = '/var/lib/centreon/centplugins';
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (defined($options{options})) {
          $options{options}->add_options(arguments => {
              'memcached:s'           => { name => 'memcached' },
              'redis-server:s'        => { name => 'redis_server' },
              'redis-attribute:s%'    => { name => 'redis_attribute' },
              'redis-db:s'            => { name => 'redis_db' },
              'memexpiration:s'       => { name => 'memexpiration', default => 86400 },
              'statefile-dir:s'       => { name => 'statefile_dir', default => $default_dir },
              'statefile-suffix:s'    => { name => 'statefile_suffix', default => '' },
              'statefile-concat-cwd'  => { name => 'statefile_concat_cwd' },
              'statefile-storable'    => { name => 'statefile_storable' },
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'RETENTION OPTIONS', once => 1);
      }
      
      $self->{error} = 0;
      $self->{output} = $options{output};
      $self->{datas} = {};
      $self->{storable} = 0;
      $self->{memcached_ok} = 0;
      $self->{memcached} = undef;
      
      $self->{statefile_dir} = undef;
      $self->{statefile_suffix} = undef;
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      if (defined($options{option_results}) && defined($options{option_results}->{memcached})) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Memcached::libmemcached',
                                                 error_msg => "Cannot load module 'Memcached::libmemcached'.");
          $self->{memcached} = Memcached::libmemcached->new();
          Memcached::libmemcached::memcached_server_add($self->{memcached}, $options{option_results}->{memcached});
      }
      
      # Check redis
      if (defined($options{option_results}->{redis_server})) {
          $self->{redis_attributes} = '';
          if (defined($options{option_results}->{redis_attribute})) {
              foreach (keys %{$options{option_results}->{redis_attribute}}) {
                  $self->{redis_attributes} .= "$_ => " . $options{option_results}->{redis_attribute}->{$_} . ', ';
              }
          }
          
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Redis',
                                                 error_msg => "Cannot load module 'Redis'.");
          eval {
              $self->{redis_cnx} = Redis->new(server => $options{option_results}->{redis_server}, 
                                              eval $self->{redis_attributes});
              if (defined($self->{redis_cnx}) && 
                  defined($options{option_results}->{redis_db}) &&
                  $options{option_results}->{redis_db} ne ''
                  ) {
                  $self->{redis_cnx}->select($options{option_results}->{redis_db});
              }
          };
      }
      
      $self->{statefile_dir} = $options{option_results}->{statefile_dir};
      if ($self->{statefile_dir} ne $default_dir && defined($options{option_results}->{statefile_concat_cwd})) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Cwd',
                                                 error_msg => "Cannot load module 'Cwd'.");
          $self->{statefile_dir} = Cwd::cwd() . '/' . $self->{statefile_dir};
      }
      if (defined($options{option_results}->{statefile_storable})) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Storable',
                                                 error_msg => "Cannot load module 'Storable'.");
          $self->{storable} = 1;
      }
      $self->{statefile_suffix} = $options{option_results}->{statefile_suffix};
      $self->{memexpiration} = $options{option_results}->{memexpiration};
  }
  
  sub error {
      my ($self) = shift;
       
      if (@_) {
          $self->{error} = $_[0];
      }
      return $self->{error};
  }
  
  sub read {
      my ($self, %options) = @_;
      $self->{statefile_suffix} = defined($options{statefile_suffix}) ? $options{statefile_suffix} : $self->{statefile_suffix};
      $self->{statefile_dir} = defined($options{statefile_dir}) ? $options{statefile_dir} : $self->{statefile_dir};
      $self->{statefile} = defined($options{statefile}) ? $options{statefile} . $self->{statefile_suffix} : 
                              $self->{statefile};
      $self->{no_quit} = defined($options{no_quit}) && $options{no_quit} == 1 ? 1 : 0;
  
      if (defined($self->{memcached})) {
          # if "SUCCESS" or "NOT FOUND" is ok. Other with use the file
          my $val = Memcached::libmemcached::memcached_get($self->{memcached}, $self->{statefile_dir} . "/" . $self->{statefile});
          if (defined($self->{memcached}->errstr) && $self->{memcached}->errstr =~ /^SUCCESS|NOT FOUND$/i) {
              $self->{memcached_ok} = 1;
              if (defined($val)) {
                  eval( $val );
                  $self->{datas} = $datas;
                  $datas = {};
                  return 1;
              }
              return 0;
          }
      }
      
      if (defined($self->{redis_cnx})) {
          my $val = $self->{redis_cnx}->get($self->{statefile_dir} . "/" . $self->{statefile});
          if (defined($val)) {
              eval($val);
              $self->{datas} = $datas;
              $datas = {};
              return 1;
          }
          
          return 0;
      }
      
      if (! -e $self->{statefile_dir} . '/' . $self->{statefile}) {
          if (! -w $self->{statefile_dir} || ! -x $self->{statefile_dir}) {
              $self->error(1);
              $self->{output}->add_option_msg(short_msg =>  "Cannot write statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'. Need write/exec permissions on directory.");
              if ($self->{no_quit} == 0) {
                  $self->{output}->option_exit();
              }
          }
          return 0;
      } elsif (! -w $self->{statefile_dir} . '/' . $self->{statefile}) {
          $self->error(1);
          $self->{output}->add_option_msg(short_msg => "Cannot write statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'. Need write permissions on file.");
          if ($self->{no_quit} == 0) {
              $self->{output}->option_exit();
          }
          return 1;
      } elsif (! -s $self->{statefile_dir} . '/' . $self->{statefile}) {
          # Empty file. Not a problem. Maybe plugin not manage not values
          return 0;
      }
      
      if ($self->{storable} == 1) {
          open FILE, $self->{statefile_dir} . '/' . $self->{statefile};
          eval {
              $self->{datas} = Storable::fd_retrieve(*FILE);
          };
          # File is corrupted surely. We'll reset it
          if ($@) {
              close FILE;
              return 0;
          }
          close FILE;
      } else {
          unless (my $return = do $self->{statefile_dir} . '/' . $self->{statefile}) {
              # File is corrupted surely. We'll reset it
              return 0;
              #if ($@) {
              #    $self->{output}->add_option_msg(short_msg => "Couldn't parse '" . $self->{statefile_dir} . "/" . $self->{statefile} . "': $@");
              #    $self->{output}->option_exit();
              #}
              #unless (defined($return)) {
              #    $self->{output}->add_option_msg(short_msg => "Couldn't do '" . $self->{statefile_dir} . "/" . $self->{statefile} . "': $!");
              #    $self->{output}->option_exit();
              #}
              #unless ($return) {
              #    $self->{output}->add_option_msg(short_msg => "Couldn't run '" . $self->{statefile_dir} . "/" . $self->{statefile} . "': $!");
              #    $self->{output}->option_exit();
          }
          $self->{datas} = $datas;
          $datas = {};
      }
  
      return 1;
  }
  
  sub get_string_content {
      my ($self, %options) = @_;
  
      return Data::Dumper::Dumper($self->{datas});
  }
  
  sub get {
      my ($self, %options) = @_;
  
      if (defined($self->{datas}->{$options{name}})) {
          return $self->{datas}->{$options{name}};
      }
      return undef;
  }
  
  sub write {
      my ($self, %options) = @_;
  
      if ($self->{memcached_ok} == 1) {
          Memcached::libmemcached::memcached_set($self->{memcached}, $self->{statefile_dir} . '/' . $self->{statefile}, 
                                                 Data::Dumper->Dump([$options{data}], ['datas']), $self->{memexpiration});
          if (defined($self->{memcached}->errstr) && $self->{memcached}->errstr =~ /^SUCCESS$/i) {
              return ;
          }
      }
      if (defined($self->{redis_cnx})) {
          return if (defined($self->{redis_cnx}->set($self->{statefile_dir} . '/' . $self->{statefile}, Data::Dumper->Dump([$options{data}], ['datas']),
                                                    'EX', $self->{memexpiration})));
      }
      open FILE, '>', $self->{statefile_dir} . '/' . $self->{statefile};
      if ($self->{storable} == 1) {
          Storable::store_fd($options{data}, *FILE);
      } else {
          print FILE Data::Dumper->Dump([$options{data}], ['datas']);
      }
      close FILE;
  }
  
  1;
  
  
  =head1 NAME
  
  Statefile class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 RETENTION OPTIONS
  
  =over 8
  
  =item B<--memcached>
  
  Memcached server to use (only one server).
  
  =item B<--redis-server>
  
  Redis server to use (only one server).
  
  =item B<--redis-attribute>
  
  Set Redis Options (--redis-attribute="cnx_timeout=5").
  
  =item B<--redis-db>
  
  Set Redis database index.
  
  =item B<--memexpiration>
  
  Time to keep data in seconds (Default: 86400).
  
  =item B<--statefile-dir>
  
  Directory for statefile (Default: '/var/lib/centreon/centplugins').
  
  =item B<--statefile-suffix>
  
  Add a suffix for the statefile name (Default: '').
  
  =item B<--statefile-concat-cwd>
  
  Concat current working directory with option '--statefile-dir'.
  Useful on Windows when plugin is compiled.
  
  =item B<--statefile-storable>
  
  Use Perl Module 'Storable' (instead Data::Dumper) to store datas.
  
  =back
  
  =head1 DESCRIPTION
  
  B<statefile>.
  
  =cut
CENTREON_PLUGINS_STATEFILE

$fatpacked{"centreon/plugins/templates/catalog_functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_CATALOG_FUNCTIONS';
  #
  # Copyright 2018 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::catalog_functions;
  
  use strict;
  use warnings;
  use Exporter;
  
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(catalog_status_threshold catalog_status_calc);
  
  sub catalog_status_threshold {
      my ($self, %options) = @_;
      my $status = 'ok';
      my $message;
  
      eval {
          local $SIG{__WARN__} = sub { $message = $_[0]; };
          local $SIG{__DIE__} = sub { $message = $_[0]; };
  
          my $label = $self->{label};
          $label =~ s/-/_/g;
          if (defined($self->{instance_mode}->{option_results}->{'ok_' . $label}) && $self->{instance_mode}->{option_results}->{'ok_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'ok_' . $label}") {
              $status = 'ok';
          } elsif (defined($self->{instance_mode}->{option_results}->{'critical_' . $label}) && $self->{instance_mode}->{option_results}->{'critical_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'critical_' . $label}") {
              $status = 'critical';
          } elsif (defined($self->{instance_mode}->{option_results}->{'warning_' . $label}) && $self->{instance_mode}->{option_results}->{'warning_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'warning_' . $label}") {
              $status = 'warning';
          } elsif (defined($self->{instance_mode}->{option_results}->{'unknown_' . $label}) && $self->{instance_mode}->{option_results}->{'unknown_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'unknown_' . $label}") {
              $status = 'unknown';
          }
      };
      if (defined($message)) {
          $self->{output}->output_add(long_msg => 'filter status issue: ' . $message);
      }
  
      return $status;
  }
  
  sub catalog_status_calc {
      my ($self, %options) = @_;
  
      foreach (keys %{$options{new_datas}}) {
          if (/^\Q$self->{instance}\E_(.*)/) {
              $self->{result_values}->{$1} = $options{new_datas}->{$_};
          }
      }
  }
  
  1;
  
  
CENTREON_PLUGINS_TEMPLATES_CATALOG_FUNCTIONS

$fatpacked{"centreon/plugins/templates/counter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_COUNTER';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::counter;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  use centreon::plugins::values;
  use centreon::plugins::misc;
  
  my $sort_subs = {
      num => sub { $a <=> $b },
      cmp => sub { $a cmp $b },
  };
  
  sub set_counters {
      my ($self, %options) = @_;
      
      if (!defined($self->{maps_counters})) {
          $self->{maps_counters} = {};
      }
      
      $self->{maps_counters_type} = [];
      
      # 0 = mode total
      # 1 = mode instances
      #push @{$self->{maps_counters_type}}, { 
      #    name => 'global', type => 0, message_separator => ', ', cb_prefix_output => undef, cb_init => undef,
      #};
  
      #$self->{maps_counters}->{global} = [
      #    { label => 'client', set => {
      #           key_values => [ { name => 'client' } ],
      #           output_template => 'Current client connections : %s',
      #           perfdatas => [
      #               { label => 'Client', value => 'client_absolute', template => '%s', 
      #                 min => 0, unit => 'con' },
      #           ],
      #       }
      #    },
      #];
      
      # Example for instances
      #push @{$self->{maps_counters_type}}, { 
      #    name => 'cpu', type => 1, message_separator => ', ', cb_prefix_output => undef, cb_init => undef,
      #    message_multiple => 'All CPU usages are ok',
      #};    
  }
  
  sub get_callback {
      my ($self, %options) = @_;
  
      if (defined($options{method_name})) {
          return $self->can($options{method_name});
      }
      
      return undef;
  }
  
  sub call_object_callback {
      my ($self, %options) = @_;
      
      if (defined($options{method_name})) {
          my $method = $self->can($options{method_name});
          if ($method) {
              return $self->$method(%options);
          }
      }
      
      return undef;
  }
  
  sub get_threshold_prefix {
      my ($self, %options) = @_;
      
      my $prefix = '';
      END_LOOP: foreach (@{$self->{maps_counters_type}}) {
          if ($_->{name} eq $options{name}) {
              $prefix = 'instance-' if ($_->{type} == 1);
              last;
          }
          
          if ($_->{type} == 3) {
              foreach (@{$_->{group}}) {
                  if ($_->{name} eq $options{name}) {
                      $prefix = 'instance-' if ($_->{type} == 0);
                      $prefix = 'subinstance-' if ($_->{type} == 1);
                      last END_LOOP;
                  }
              }
          }
      }
  
      return $prefix;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $self->{version} = '1.0';
      $options{options}->add_options(arguments => {
          'filter-counters:s'     => { name => 'filter_counters' },
          'display-ok-counters:s' => { name => 'display_ok_counters' },
          'list-counters'         => { name => 'list_counters' },
      });
      $self->{statefile_value} = undef;
      if (defined($options{statefile}) && $options{statefile}) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'centreon::plugins::statefile',
                                                 error_msg => "Cannot load module 'centreon::plugins::statefile'.");
          $self->{statefile_value} = centreon::plugins::statefile->new(%options);
      }
      
      $self->{maps_counters} = {} if (!defined($self->{maps_counters}));
      $self->set_counters(%options);
      
      foreach my $key (keys %{$self->{maps_counters}}) {
          foreach (@{$self->{maps_counters}->{$key}}) {
              my $label = $_->{label};
              my $thlabel = $label;
              if ($self->{output}->use_new_perfdata() && defined($_->{nlabel})) {
                  $label = $_->{nlabel};
                  $thlabel = $self->get_threshold_prefix(name => $key) . $label;
              }
              $thlabel =~ s/\./-/g;
              
              if (!defined($_->{threshold}) || $_->{threshold} != 0) {
                  $options{options}->add_options(arguments => {
                      'warning-' . $thlabel . ':s'     => { name => 'warning-' . $thlabel },
                      'critical-' . $thlabel . ':s'    => { name => 'critical-' . $thlabel },
                  });
  
                  if (defined($_->{nlabel})) {
                      $options{options}->add_options(arguments => {
                          'warning-' . $_->{label} . ':s'     => { name => 'warning-' . $_->{label}, redirect => 'warning-' . $thlabel },
                          'critical-' . $_->{label} . ':s'    => { name => 'critical-' . $_->{label}, redirect => 'critical-' . $thlabel },
                      });
                  }
              }
              $_->{obj} = centreon::plugins::values->new(
                  statefile => $self->{statefile_value},
                  output => $self->{output}, perfdata => $self->{perfdata},
                  label => $_->{label}, nlabel => $_->{nlabel}, thlabel => $thlabel,
              );
              $_->{obj}->set(%{$_->{set}});
          }
      }
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (defined($self->{option_results}->{list_counters})) {
          my $list_counter = 'counter list:';
          my $th_counter = '';
          foreach my $key (keys %{$self->{maps_counters}}) {
              foreach (@{$self->{maps_counters}->{$key}}) {
                  my $label = $_->{label};
                  $label =~ s/-//g;
                  $list_counter .= " " . $_->{label};
                  $th_counter .= " --warning-$_->{label}='\$_SERVICEWARNING" . uc($label) . "\$' --critical-$_->{label}='\$_SERVICECRITICAL" . uc($label) . "\$'";  
              }
          }
          $self->{output}->output_add(short_msg => $list_counter);
          $self->{output}->output_add(long_msg => 'configuration: ' . $th_counter); 
          $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1);
          $self->{output}->exit();
      }
      foreach my $key (keys %{$self->{maps_counters}}) {
          foreach (@{$self->{maps_counters}->{$key}}) {
              $_->{obj}->{instance_mode} = $self;
              $_->{obj}->init(option_results => $self->{option_results});
          }
      }
      
      if (defined($self->{statefile_value})) {
          $self->{statefile_value}->check_options(%options);
      }
  }
  
  sub run_global {
      my ($self, %options) = @_;
      
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $resume = defined($options{resume}) && $options{resume} == 1 ? 1 : 0;
      # Can be set when it comes from type 3 counters
      my $called_multiple = defined($options{called_multiple}) && $options{called_multiple} == 1 ? 1 : 0;
      my $multiple_parent = defined($options{multiple_parent}) && $options{multiple_parent} == 1 ? 1 : 0;
      my $force_instance = defined($options{force_instance}) ? $options{force_instance} : undef;
      
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator}: ', ';
      my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
      my @exits;
      foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
          my $obj = $_->{obj};
  
          next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
              $_->{label} !~ /$self->{option_results}->{filter_counters}/);
      
          $obj->set(instance => defined($force_instance) ? $force_instance : $options{config}->{name});
      
          my ($value_check) = $obj->execute(new_datas => $self->{new_datas}, values => $self->{$options{config}->{name}});
  
          next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
          if ($value_check != 0) {
              $long_msg .= $long_msg_append . $obj->output_error();
              $long_msg_append = $message_separator;
              next;
          }
          my $exit2 = $obj->threshold_check();
          push @exits, $exit2;
  
          my $output = $obj->output();
          if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
              (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
               $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
              $long_msg .= $long_msg_append . $output;
              $long_msg_append = $message_separator;
          }
  
          if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
              $short_msg .= $short_msg_append . $output;
              $short_msg_append = $message_separator;
          }
          
          $obj->perfdata(extra_instance => $multiple_parent);
      }
  
      my ($prefix_output, $suffix_output);
      $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}) 
          if (defined($options{config}->{cb_prefix_output}));
      $prefix_output = '' if (!defined($prefix_output));
      
      $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
      $suffix_output = '' if (!defined($suffix_output));
      
      if ($called_multiple == 1 && $long_msg ne '') {
          $self->{output}->output_add(long_msg => $options{indent_long_output} . $prefix_output. $long_msg . $suffix_output);
      }
      
      my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
      if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
          if ($called_multiple == 0) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => $prefix_output . $short_msg . $suffix_output);
          } else {
              $self->run_multiple_prefix_output(severity => $exit,
                                                short_msg => $prefix_output . $short_msg . $suffix_output);
          }
      } else {
          if ($long_msg ne '' && $multiple_parent == 0) {
              if ($called_multiple == 0) {
                  $self->{output}->output_add(short_msg => $prefix_output . $long_msg . $suffix_output) ;
              } else {
                  $self->run_multiple_prefix_output(severity => 'ok',
                                                    short_msg => $prefix_output . $long_msg . $suffix_output);
              }
          }
      }
  }
  
  sub run_instances {
      my ($self, %options) = @_;
      
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $cb_init_counters = $self->get_callback(method_name => $options{config}->{cb_init_counters});
      my $display_status_lo = defined($options{display_status_long_output}) && $options{display_status_long_output} == 1 ? 1 : 0;
      my $resume = defined($options{resume}) && $options{resume} == 1 ? 1 : 0;
      my $no_message_multiple = 1;
      
      $self->{lproblems} = 0;
      $self->{multiple} = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $self->{multiple} = 0;
      }
      
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator}: ', ';
  
      my $sort_method = 'cmp';
      $sort_method = $options{config}->{sort_method}
          if (defined($options{config}->{sort_method}));
      foreach my $id (sort { $sort_subs->{$sort_method}->() } keys %{$self->{$options{config}->{name}}}) {
          my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
          my @exits = ();
          foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
              my $obj = $_->{obj};
  
              next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
                  $_->{label} !~ /$self->{option_results}->{filter_counters}/);
              next if ($cb_init_counters && $self->$cb_init_counters(%$_) == 1);
  
              $no_message_multiple = 0;
              $obj->set(instance => $id);
          
              my ($value_check) = $obj->execute(new_datas => $self->{new_datas},
                                                values => $self->{$options{config}->{name}}->{$id});
              next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
              if ($value_check != 0) {
                  $long_msg .= $long_msg_append . $obj->output_error();
                  $long_msg_append = $message_separator;
                  next;
              }
              my $exit2 = $obj->threshold_check();
              push @exits, $exit2;
  
              my $output = $obj->output();
              if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
                  (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
                   $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
                  $long_msg .= $long_msg_append . $output;
                  $long_msg_append = $message_separator;
              }
              
              if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
                  $self->{lproblems}++;
                  $short_msg .= $short_msg_append . $output;
                  $short_msg_append = $message_separator;
              }
              
              $obj->perfdata(extra_instance => $self->{multiple});
          }
  
          my ($prefix_output, $suffix_output);
          $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
          $prefix_output = '' if (!defined($prefix_output));
          
          $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
          $suffix_output = '' if (!defined($suffix_output));
  
          my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
          # in mode grouped, we don't display 'ok'
          my $debug = 0;
          $debug = 1 if ($display_status_lo == 1 && $self->{output}->is_status(value => $exit, compare => 'OK', litteral => 1));
          if (scalar @{$self->{maps_counters}->{$options{config}->{name}}} > 0 && $long_msg ne '') {
              $self->{output}->output_add(long_msg => ($display_status_lo == 1 ? lc($exit) . ': ' : '') . $prefix_output . $long_msg . $suffix_output, debug => $debug);
          }
          if ($resume == 1) {
              $self->{most_critical_instance} = $self->{output}->get_most_critical(status => [ $self->{most_critical_instance},  $exit ]);  
              next;
          }
          
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => $prefix_output . $short_msg . $suffix_output);
          }
          
          if ($self->{multiple} == 0)  {
              $self->{output}->output_add(short_msg => $prefix_output . $long_msg . $suffix_output);
          }
      }
      
      if ($no_message_multiple == 0 && $self->{multiple} == 1 && $resume == 0) {
          $self->{output}->output_add(short_msg => $options{config}->{message_multiple});
      }
  }
  
  sub run_group {
      my ($self, %options) = @_;
  
      my $multiple = 1;
      return if (scalar(keys %{$self->{$options{config}->{name}}}) <= 0);
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $multiple = 0;
      }
      
      if ($multiple == 1) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => $options{config}->{message_multiple});
      }
      
      my $format_output = defined($options{config}->{format_output}) ? $options{config}->{format_output} : '%s problem(s) detected';
      
      my ($global_exit, $total_problems) = ([], 0);
      foreach my $id (sort keys %{$self->{$options{config}->{name}}}) {
          $self->{most_critical_instance} = 'ok';
          if (defined($options{config}->{cb_long_output})) {
              $self->{output}->output_add(long_msg => $self->call_object_callback(method_name => $options{config}->{cb_long_output},
                                                                                  instance_value => $self->{$options{config}->{name}}->{$id}));
          }
          
          foreach my $group (@{$options{config}->{group}}) {
              $self->{$group->{name}} = $self->{$options{config}->{name}}->{$id}->{$group->{name}};
              
              # we resume datas
              $self->run_instances(config => $group, display_status_long_output => 1, resume => 1);
              
              push @{$global_exit}, $self->{most_critical_instance};
              $total_problems += $self->{lproblems};
              
              my $prefix_output;
              $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
              $prefix_output = '' if (!defined($prefix_output));
              
              if ($multiple == 0 && (!defined($group->{display}) || $group->{display} != 0)) {
                  $self->{output}->output_add(severity => $self->{most_critical_instance},
                                              short_msg => sprintf("${prefix_output}" . $format_output, $self->{lproblems}));
              }
          }
      }
      
      if ($multiple == 1) {
          my $exit = $self->{output}->get_most_critical(status => [ @{$global_exit} ]);
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf($format_output, $total_problems));
          }
      }
      
      if (defined($options{config}->{display_counter_problem})) {
          $self->{output}->perfdata_add(
              label => $options{config}->{display_counter_problem}->{label},
              nlabel => $options{config}->{display_counter_problem}->{nlabel},
              unit => $options{config}->{display_counter_problem}->{unit},
              value => $total_problems,
              min => $options{config}->{display_counter_problem}->{min}, max => $options{config}->{display_counter_problem}->{max}
          );
      }
  }
  
  sub run_multiple_instances {
      my ($self, %options) = @_;
      
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $use_new_perfdata = $self->{output}->use_new_perfdata();
      my $multiple_parent = defined($options{multiple_parent}) && $options{multiple_parent} == 1 ? $options{multiple_parent} : 0;
      my $indent_long_output = defined($options{indent_long_output}) ? $options{indent_long_output} : '';
      my $no_message_multiple = 1;
      
      my $multiple = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $multiple = 0;
      }
      
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator} : ', ';
      my $sort_method = 'cmp';
      $sort_method = $options{config}->{sort_method}
          if (defined($options{config}->{sort_method}));
      foreach my $id (sort { $sort_subs->{$sort_method}->() } keys %{$self->{$options{config}->{name}}}) {
          my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
          my @exits = ();
          foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
              my $obj = $_->{obj};
              
              next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
                  $_->{label} !~ /$self->{option_results}->{filter_counters}/);
              
              my $instance = $id;
              if ($use_new_perfdata || ($multiple_parent == 1 && $multiple == 1)) {
                  $instance = $options{instance_parent} . ($self->{output}->get_instance_perfdata_separator()) . $id;
              } elsif ($multiple_parent == 1 && $multiple == 0) {
                  $instance = $options{instance_parent};
              }
              
              $no_message_multiple = 0;
              $obj->set(instance => $instance);
          
              my ($value_check) = $obj->execute(new_datas => $self->{new_datas},
                                                values => $self->{$options{config}->{name}}->{$id});
              next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
              if ($value_check != 0) {
                  $long_msg .= $long_msg_append . $obj->output_error();
                  $long_msg_append = $message_separator;
                  next;
              }
              my $exit2 = $obj->threshold_check();
              push @exits, $exit2;
  
              my $output = $obj->output();
              $long_msg .= $long_msg_append . $output;
              $long_msg_append = $message_separator;
              
              if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
                  $short_msg .= $short_msg_append . $output;
                  $short_msg_append = $message_separator;
              }
              
              if ($multiple_parent == 1 && $multiple == 0) {
                  $obj->perfdata(extra_instance => 1);
              } else {
                  $obj->perfdata(extra_instance => $multiple);
              }
          }
  
          my ($prefix_output, $suffix_output);
          $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
          $prefix_output = '' if (!defined($prefix_output));
          
          $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
          $suffix_output = '' if (!defined($suffix_output));
  
          my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
          if (scalar @{$self->{maps_counters}->{$options{config}->{name}}} > 0 && $long_msg ne '') {
              $self->{output}->output_add(long_msg => $indent_long_output . $prefix_output . $long_msg . $suffix_output)
                  if (!defined($options{config}->{display_long}) || $options{config}->{display_long} != 0);
          }
          
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->run_multiple_prefix_output(severity => $exit,
                  short_msg => $prefix_output . $short_msg . $suffix_output);
          }
          
          if ($multiple == 0 && $multiple_parent == 0) {
              $self->run_multiple_prefix_output(severity => 'ok', short_msg => $prefix_output . $long_msg . $suffix_output);            
          }
      }
      
      if ($no_message_multiple == 0 && $multiple == 1 && $multiple_parent == 0) {
          $self->{output}->output_add(short_msg => $options{config}->{message_multiple});
      }
  }
  
  sub run_multiple_prefix_output {
      my ($self, %options) = @_;
      
      my %separator;
      if ($self->{prefix_multiple_output_done}->{lc($options{severity})} == 0) {
          $self->{output}->output_add(severity => $options{severity}, short_msg => $self->{prefix_multiple_output});
          $self->{prefix_multiple_output_done}->{lc($options{severity})} = 1;
          $separator{separator} = '';
      }
      
      $self->{output}->output_add(severity => $options{severity}, short_msg => "$options{short_msg}", %separator);
  }
  
  sub run_multiple {
      my ($self, %options) = @_;
  
      my $multiple = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $multiple = 0;
      }
      
      if ($multiple == 1) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => $options{config}->{message_multiple});
      }
      
      foreach my $instance (sort keys %{$self->{$options{config}->{name}}}) {
          if (defined($options{config}->{cb_long_output})) {
              $self->{output}->output_add(long_msg => $self->call_object_callback(method_name => $options{config}->{cb_long_output},
                                                                                  instance_value => $self->{$options{config}->{name}}->{$instance}));
          }
          
          $self->{prefix_multiple_output} = '';
          $self->{prefix_multiple_output_done} = { ok => 0, warning => 0, critical => 0, unknown => 0 };
          $self->{prefix_multiple_output} = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$instance})
               if (defined($options{config}->{cb_prefix_output}));
          my $indent_long_output = '';
          $indent_long_output = $options{config}->{indent_long_output}
              if (defined($options{config}->{indent_long_output}));
          
          foreach my $group (@{$options{config}->{group}}) {
              next if (!defined($self->{$options{config}->{name}}->{$instance}->{$group->{name}}));
              $self->{$group->{name}} = $self->{$options{config}->{name}}->{$instance}->{$group->{name}};
              
              if ($group->{type} == 1) {
                  $self->run_multiple_instances(config => $group, multiple_parent => $multiple, instance_parent => $instance, indent_long_output => $indent_long_output);
              } elsif ($group->{type} == 0) {
                  $self->run_global(config => $group, multiple_parent => $multiple, called_multiple => 1, force_instance => $instance, indent_long_output => $indent_long_output);
              }
          }
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      
      $self->manage_selection(%options);
      
      $self->{new_datas} = undef;
      if (defined($self->{statefile_value})) {
          $self->{new_datas} = {};
          $self->{statefile_value}->read(statefile => $self->{cache_name}) if (defined($self->{cache_name}));
          $self->{new_datas}->{last_timestamp} = time();
      }
      
      foreach my $entry (@{$self->{maps_counters_type}}) {
          if ($entry->{type} == 0) {
              $self->run_global(config => $entry);
          } elsif ($entry->{type} == 1) {
              $self->run_instances(config => $entry);
          } elsif ($entry->{type} == 2) {
              $self->run_group(config => $entry);
          } elsif ($entry->{type} == 3) {
              $self->run_multiple(config => $entry);
          }
      }
          
      if (defined($self->{statefile_value})) {
          $self->{statefile_value}->write(data => $self->{new_datas});
      }
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      # example for snmp
      #use Digest::MD5 qw(md5_hex);
      #$self->{cache_name} = "choose_name_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
      #    (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  sub change_macros {
      my ($self, %options) = @_;
  
      foreach (@{$options{macros}}) {
          if (defined($self->{option_results}->{$_})) {
              $self->{option_results}->{$_} =~ s/%\{(.*?)\}/\$self->{result_values}->{$1}/g;
          }
      }
  }
      
  1;
  
  
  =head1 MODE
  
  Default template for counters. Should be extended.
  
  =over 8
  
  =item B<--filter-counters>
  
  Only display some counters (regexp can be used).
  Example to check SSL connections only : --filter-counters='^xxxx|yyyy$'
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'xxx', 'xxx'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'xxx', 'xxx'.
  
  =back
  
  =cut
CENTREON_PLUGINS_TEMPLATES_COUNTER

$fatpacked{"centreon/plugins/templates/hardware.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_HARDWARE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::hardware;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub set_system {
      my ($self, %options) = @_;
      
      # To check with a regexp
      #$self->{regexp_threshold_overload_check_section_option} = '';
      #$self->{cb_threshold_overload_check_section_option} = 'callbackname';
      
      #$self->{regexp_threshold_numeric_check_section_option} = '';
      #$self->{cb_threshold_numeric_check_section_option} = 'callbackname';
      
      # Some callbacks 
      #$self->{cb_hook1} = 'callbackname'; # before the loads
      #$self->{cb_hook2} = 'callbackname'; # between loads and requests
      #$self->{cb_hook3} = 'callbackname'; # after requests
      #$self->{cb_hook4} = 'callbackname'; # after output
      
      # Example for threshold:
      #$self->{thresholds} = {
      #    fan => [
      #        ['bad', 'CRITICAL'],
      #        ['good', 'OK'],
      #        ['notPresent', 'OK'],
      #    ],
      #};
      
      # Unset the call to load components
      #$self->{components_exec_load} = 0;
      
      # Set the path_info
      #$self->{components_path} = 'network::xxxx::mode::components';
      
      # Set the components
      #$self->{components_module} = ['cpu', 'memory', ...];
  }
  
  sub call_object_callback {
      my ($self, %options) = @_;
      
      if (defined($options{method_name})) {
          my $method = $self->can($options{method_name});
          if ($method) {
              return $self->$method(%options);
          }
      }
      
      return undef;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $self->{version} = '1.0';
      $options{options}->add_options(arguments => {
          'component:s'             => { name => 'component', default => '.*' },
          'no-component:s'          => { name => 'no_component' },
          'threshold-overload:s@'   => { name => 'threshold_overload' },
          'add-name-instance'       => { name => 'add_name_instance' },
      });
      
      $self->{performance} = (defined($options{no_performance}) && $options{no_performance} == 1) ?
          0 : 1;
      if ($self->{performance} == 1) {
          $options{options}->add_options(arguments => {
              'warning:s@'     => { name => 'warning' },
              'critical:s@'   => { name => 'critical' },
          });
      }
      
      $self->{filter_exclude} = (defined($options{no_filter_exclude}) && $options{no_filter_exclude} == 1) ?
          0 : 1;
      if ($self->{filter_exclude} == 1) {
          $options{options}->add_options(arguments => {
              'exclude:s'     => { name => 'exclude' },
              'filter:s@'     => { name => 'filter' },
          });
      }
      $self->{absent} = (defined($options{no_absent}) && $options{no_absent} == 1) ?
          0 : 1;
      if ($self->{absent} == 1) {
          $options{options}->add_options(arguments => {
              'absent-problem:s@'       => { name => 'absent_problem' },
          });
      }
      
      $self->{load_components} = (defined($options{no_load_components}) && $options{no_load_components} == 1) ?
          0 : 1;
      $self->{components} = {};
      $self->{no_components} = undef;
      
      $self->{components_module} = [];
      $self->{components_exec_load} = 1;
      $self->set_system();
  
      $self->{count} = (defined($options{no_count}) && $options{no_count} == 1) ?
          0 : 1;
      if ($self->{count} == 1) {
          foreach my $component (@{$self->{components_module}}) {
              $options{options}->add_options(arguments => {
                  'warning-count-' . $component . ':s'    => { name => 'warning_count_' . $component },
                  'critical-count-' . $component . ':s'    => { name => 'critical_count_' . $component },
              });
          }
      }
  
      $self->{request} = [];
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (defined($self->{option_results}->{no_component})) {
          if ($self->{option_results}->{no_component} ne '') {
              $self->{no_components} = $self->{option_results}->{no_component};
          } else {
              $self->{no_components} = 'critical';
          }
      }
      
      if ($self->{filter_exclude} == 1) {
          $self->{filter} = [];
          foreach my $val (@{$self->{option_results}->{filter}}) {
              next if (!defined($val) || $val eq '');
              my @values = split (/,/, $val);
              push @{$self->{filter}}, { filter => $values[0], instance => $values[1] }; 
          }
      }
      
      if ($self->{absent} == 1) {
          $self->{absent_problem} = [];
          foreach my $val (@{$self->{option_results}->{absent_problem}}) {
              next if (!defined($val) || $val eq '');
              my @values = split (/,/, $val);
              push @{$self->{absent_problem}}, { filter => $values[0], instance => $values[1] }; 
          }
      }
      
      $self->{overload_th} = {};
      foreach my $val (@{$self->{option_results}->{threshold_overload}}) {
          next if (!defined($val) || $val eq '');
          my @values = split (/,/, $val);
          if (scalar(@values) < 3) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload option '" . $val . "'.");
              $self->{output}->option_exit();
          }
          my ($section, $instance, $status, $filter);
          if (scalar(@values) == 3) {
              ($section, $status, $filter) = @values;
              $instance = '.*';
          } else {
               ($section, $instance, $status, $filter) = @values;
          }
          if (defined($self->{regexp_threshold_overload_check_section_option}) && 
              $section !~ /$self->{regexp_threshold_overload_check_section_option}/) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload section '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->call_object_callback(method_name => $self->{cb_threshold_overload_check_section_option}, 
                                      section => $section, option_value => $val);
  
          if ($self->{output}->is_litteral_status(status => $status) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload status '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->{overload_th}->{$section} = [] if (!defined($self->{overload_th}->{$section}));
          push @{$self->{overload_th}->{$section}}, {filter => $filter, status => $status, instance => $instance };
      }
      
      if ($self->{performance} == 1) {
          $self->{numeric_threshold} = {};
          foreach my $option (('warning', 'critical')) {
              foreach my $val (@{$self->{option_results}->{$option}}) {
                  next if (!defined($val) || $val eq '');
                  if ($val !~ /^(.*?),(.*?),(.*)$/) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option option '" . $val . "'.");
                      $self->{output}->option_exit();
                  }
                  my ($section, $instance, $value) = ($1, $2, $3);                
                  if (defined($self->{regexp_threshold_numeric_check_section_option}) && 
                      $section !~ /$self->{regexp_threshold_numeric_check_section_option}/) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option option '" . $val . "'.");
                      $self->{output}->option_exit();
                  }   
                  $self->call_object_callback(method_name => $self->{cb_threshold_numeric_check_section_option}, 
                                              section => $section, option_name => $option, option_value => $val);
  
                  my $position = 0;
                  if (defined($self->{numeric_threshold}->{$section})) {
                      $position = scalar(@{$self->{numeric_threshold}->{$section}});
                  }
                  if (($self->{perfdata}->threshold_validate(label => $option . '-' . $section . '-' . $position, value => $value)) == 0) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option threshold '" . $value . "'.");
                      $self->{output}->option_exit();
                  }
                  $self->{numeric_threshold}->{$section} = [] if (!defined($self->{numeric_threshold}->{$section}));
                  push @{$self->{numeric_threshold}->{$section}}, { label => $option . '-' . $section . '-' . $position, threshold => $option, instance => $instance };
              }
          }
      }
      
      if ($self->{count} == 1) {
          foreach my $comp (@{$self->{components_module}}) {
              foreach my $threshold (('warning', 'critical')) {
                  if (($self->{perfdata}->threshold_validate(label => $threshold . '-count-' . $comp, value => $self->{option_results}->{$threshold . '_count_' . $comp})) == 0) {
                      $self->{output}->add_option_msg(short_msg => "Wrong " . $threshold . " threshold '" . $self->{option_results}->{$threshold . '_count_' . $comp} . "'.");
                      $self->{output}->option_exit();
                  }
              }
          }
      }
  }
  
  sub load_components {
      my ($self, %options) = @_;
      
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $mod_name,
                                                     error_msg => "Cannot load module '$mod_name'.") if ($self->{load_components} == 1);
              $self->{loaded} = 1;
              if ($self->{components_exec_load} == 1) {
                  my $func = $mod_name->can('load');
                  $func->($self);
              }
          }
      }
  }
  
  sub exec_components {
      my ($self, %options) = @_;
      
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              my $func = $mod_name->can('check');
              $func->($self); 
          }
      }
  }
  
  sub display {
      my ($self, %options) = @_;
      
      my $total_components = 0;
      my $display_by_component = '';
      my $display_by_component_append = '';
      my $exit = 'OK';
      my $exits = [];
      my ($warn, $crit);
  
      foreach my $comp (sort(keys %{$self->{components}})) {
          # Skipping short msg when no components
          next if ($self->{components}->{$comp}->{total} == 0 && $self->{components}->{$comp}->{skip} == 0);
  
          if ($self->{count} == 1) {
              ($exit, $warn, $crit) = $self->get_severity_count(label => $comp, value => $self->{components}->{$comp}->{total});
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("'%s' components '%s' checked",
                                                              $self->{components}->{$comp}->{total},
                                                              $comp));
              }
              $self->{output}->perfdata_add(
                  label => 'count_' . $comp,
                  nlabel => 'hardware.' . $comp . '.count',
                  value => $self->{components}->{$comp}->{total},
                  warning => $warn,
                  critical => $crit
              );
              push @{$exits}, $exit;
          }
  
          $total_components += $self->{components}->{$comp}->{total} + $self->{components}->{$comp}->{skip};
          my $count_by_components = $self->{components}->{$comp}->{total} + $self->{components}->{$comp}->{skip}; 
          $display_by_component .= $display_by_component_append . $self->{components}->{$comp}->{total} . '/' . $count_by_components . ' ' . $self->{components}->{$comp}->{name};
          $display_by_component_append = ', ';
      }
  
      $exit = $self->{output}->get_most_critical(status => $exits) if (scalar(@{$exits}) > 0);
      
      if ($self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
          $self->{output}->output_add(short_msg => sprintf('All %s components are ok [%s].', 
                                                          $total_components,
                                                          $display_by_component)
                                      );
      }
  
      if (defined($self->{option_results}->{no_component}) && $total_components == 0) {
          $self->{output}->output_add(severity => $self->{no_components},
                                      short_msg => 'No components are checked.');
      }
  }
  
  sub run {
      my ($self, %options) = @_;
  
      $self->{loaded} = 0;  
      $self->call_object_callback(method_name => $self->{cb_hook1}, %options);
  
      $self->load_components(%options);
      if ($self->{loaded} == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong option. Cannot find component '" . $self->{option_results}->{component} . "'.");
          $self->{output}->option_exit();
      }
      
      $self->call_object_callback(method_name => $self->{cb_hook2}, %options);
      $self->exec_components(%options);
      $self->call_object_callback(method_name => $self->{cb_hook3}, %options);
      
      $self->display();
  
      $self->call_object_callback(method_name => $self->{cb_hook4}, %options);
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub check_filter {
      my ($self, %options) = @_;
      
      # Old compatibility variable. We'll be deleted
      if (defined($self->{option_results}->{exclude})) {
          if (defined($options{instance})) {
              if ($self->{option_results}->{exclude} =~ /(^|\s|,)${options{section}}[^,]*#\Q$options{instance}\E#/) {
                  $self->{components}->{$options{section}}->{skip}++;
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section $options{instance} instance."));
                  return 1;
              }
          } elsif (defined($self->{option_results}->{exclude}) && $self->{option_results}->{exclude} =~ /(^|\s|,)$options{section}(\s|,|$)/) {
              $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section."));
              return 1;
          }
      }
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));   
      foreach (@{$self->{filter}}) {
          if ($options{section} =~ /$_->{filter}/) {
              if (!defined($options{instance}) && !defined($_->{instance})) {
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section."));
                  return 1;
              } elsif (defined($options{instance}) && $options{instance} =~ /$_->{instance}/) {
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section $options{instance} instance."));
                  return 1;
              }
          }
      }
      
      return 0;
  }
  
  sub absent_problem {
      my ($self, %options) = @_;
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
      foreach (@{$self->{absent_problem}}) {
          if ($options{section} =~ /$_->{filter}/) {
              if (!defined($_->{instance}) || $options{instance} =~ /$_->{instance}/) {
                  $self->{output}->output_add(severity => 'CRITICAL',
                                              short_msg => sprintf("Component '%s' instance '%s' is not present", 
                                                                   $options{section}, $options{instance}));
                  $self->{output}->output_add(long_msg => sprintf("Skipping $options{section} section $options{instance} instance (not present)"));
                  $self->{components}->{$options{section}}->{skip}++;
                  return 1;
              }
          }
      }
      
      return 0;
  }
  
  sub get_severity_count {
      my ($self, %options) = @_;
      my $status = 'OK'; # default
      my $thresholds = { warning => undef, critical => undef };
      
      $status = $self->{perfdata}->threshold_check(value => $options{value},
                                                   threshold => [ { label => 'critical-count-' . $options{label}, 'exit_litteral' => 'critical' }, 
                                                                  { label => 'warning-count-' . $options{label}, 'exit_litteral' => 'warning' } ]);
      $thresholds->{critical} = $self->{perfdata}->get_perfdata_for_output(label => 'critical-count-' . $options{label});
      $thresholds->{warning} = $self->{perfdata}->get_perfdata_for_output(label => 'warning-count-' . $options{label});
  
      return ($status, $thresholds->{warning}, $thresholds->{critical});
  }
  
  sub get_severity_numeric {
      my ($self, %options) = @_;
      my $status = 'OK'; # default
      my $thresholds = { warning => undef, critical => undef };
      my $checked = 0;
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
      if (defined($self->{numeric_threshold}->{$options{section}})) {
          my $exits = [];
          foreach (@{$self->{numeric_threshold}->{$options{section}}}) {
              if ($options{instance} =~ /$_->{instance}/) {
                  push @{$exits}, $self->{perfdata}->threshold_check(value => $options{value}, threshold => [ { label => $_->{label}, exit_litteral => $_->{threshold} } ]);
                  $thresholds->{$_->{threshold}} = $self->{perfdata}->get_perfdata_for_output(label => $_->{label});
                  $checked = 1;
              }
          }
          $status = $self->{output}->get_most_critical(status => $exits) if (scalar(@{$exits}) > 0);
      }
      
      return ($status, $thresholds->{warning}, $thresholds->{critical}, $checked);
  }
  
  sub get_severity {
      my ($self, %options) = @_;
      my $status = 'UNKNOWN'; # default 
      
      if (defined($self->{overload_th}->{$options{section}})) {
          foreach (@{$self->{overload_th}->{$options{section}}}) {            
              if ($options{value} =~ /$_->{filter}/i && 
                  (!defined($options{instance}) || $options{instance} =~ /$_->{instance}/)) {
                  $status = $_->{status};
                  return $status;
              }
          }
      }
      my $label = defined($options{label}) ? $options{label} : $options{section};
      foreach (@{$self->{thresholds}->{$label}}) {
          if ($options{value} =~ /$$_[0]/i) {
              $status = $$_[1];
              return $status;
          }
      }
      
      return $status;
  }
      
  1;
  
  
  =head1 MODE
  
  Default template for hardware. Should be extended.
  
  =over 8
  
  =item B<--component>
  
  Which component to check (Default: '.*').
  Can be: 'xxx', 'yyy'.
  
  =item B<--filter>
  
  Exclude some parts (comma seperated list) (Example: --filter=xxx --filter=yyyy)
  Can also exclude specific instance: --filter=xxxxx,instancevalue
  
  =item B<--absent-problem>
  
  Return an error if an entity is not 'present' (default is skipping) (comma seperated list)
  Can be specific or global: --absent-problem=xxxx,instancevalue
  
  =item B<--no-component>
  
  Return an error if no compenents are checked.
  If total (with skipped) is 0. (Default: 'critical' returns).
  
  =item B<--threshold-overload>
  
  Set to overload default threshold values (syntax: section,[instance,]status,regexp)
  It used before default thresholds (order stays).
  Example: --threshold-overload='xxxxx,CRITICAL,^(?!(normal)$)'
  
  =item B<--warning>
  
  Set warning threshold for temperatures (syntax: type,instance,threshold)
  Example: --warning='xxxxx,.*,30'
  
  =item B<--critical>
  
  Set critical threshold for temperatures (syntax: type,instance,threshold)
  Example: --critical='xxxxx,.*,40'
  
  =item B<--warning-count-xxxx>
  
  Set warning threshold for component count.
  
  =item B<--critical-count-xxxx>
  
  Set critical threshold for component count.
  
  =back
  
  =cut
CENTREON_PLUGINS_TEMPLATES_HARDWARE

$fatpacked{"centreon/plugins/values.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_VALUES';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::values;
  
  use strict;
  use warnings;
  # Warning message with sprintf and too much arguments.
  # Really annoying. Need to disable that warning
  no if ($^V gt v5.22.0), 'warnings' => 'redundant';
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{statefile} = $options{statefile};
      $self->{output} = $options{output};
      $self->{perfdata} = $options{perfdata};
      $self->{label} = $options{label};
      $self->{nlabel} = $options{nlabel};
      $self->{thlabel} = defined($options{thlabel}) ? $options{thlabel} : $self->{label};
  
      $self->{perfdatas} = [];
      
      $self->{output_template} = $self->{label} . ' : %s';
      $self->{output_use} = undef;
      $self->{output_change_bytes} = 0;
      $self->{output_absolute_unit} = '';
      $self->{output_per_second_unit} = '';
      
      $self->{output_error_template} = $self->{label} . ' : %s';
      
      $self->{threshold_use} = undef;
      $self->{threshold_warn} = undef;
      $self->{threshold_crit} = undef;
  
      $self->{per_second} = 0;
      $self->{manual_keys} = 0;
      $self->{last_timestamp} = undef;
  
      $self->{result_values} = {};
      
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel}; 
      
      if (($self->{perfdata}->threshold_validate(label => $warn, value => $options{option_results}->{$warn})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $warn threshold '" . $options{option_results}->{$warn} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => $crit, value => $options{option_results}->{$crit})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $crit threshold '" . $options{option_results}->{$crit} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub set {
      my ($self, %options) = @_;
  
      foreach (keys %options) {
          $self->{$_} = $options{$_};
      }
  }
  
  sub calc {
      my ($self, %options) = @_;
  
      # manage only one value ;)
      foreach my $value (@{$self->{key_values}}) {
          if (defined($value->{diff}) && $value->{diff} == 1) { 
              if (defined($self->{per_second}) && $self->{per_second} == 1) {
                  $self->{result_values}->{$value->{name} . '_per_second'} = ($options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}}) / $options{delta_time};
              }
              $self->{result_values}->{$value->{name} . '_absolute'} = $options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}};
          } else {
              # absolute one. nothing to do. Can be used for values.
              $self->{result_values}->{$value->{name} . '_absolute'} = $options{new_datas}->{$self->{instance} . '_' . $value->{name}};
          }
      }
  
      return 0;
  }
  
  sub threshold_check {
      my ($self, %options) = @_;
      
      if (defined($self->{closure_custom_threshold_check})) {
          return &{$self->{closure_custom_threshold_check}}($self, %options);
      }
      
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel};
      
      my $first = defined($self->{key_values}->[0]) ? $self->{key_values}->[0]->{name} : '';
      my $value;
  
      if (!defined($self->{threshold_use})) {
          $value = $self->{result_values}->{$first . '_absolute'};
          if (defined($self->{per_second}) && $self->{per_second} == 1) {
              $value = $self->{result_values}->{$first . '_per_second'};
          }
      } else {
          $value = $self->{result_values}->{$self->{threshold_use}};
      }
  
      return $self->{perfdata}->threshold_check(value => $value, threshold => [ { label => $crit, 'exit_litteral' => 'critical' },
                                                                                { label => $warn, 'exit_litteral' => 'warning' }]);
  }
  
  sub output_error {
      my ($self, %options) = @_;
      
      return sprintf($self->{output_error_template}, $self->{error_msg});
  }
  
  sub output {
      my ($self, %options) = @_;
       
      if (defined($self->{closure_custom_output})) {
          return $self->{closure_custom_output}->($self);
      }
      my $first = $self->{key_values}->[0]->{name};
      my ($value, $unit) = (defined($first) ? $self->{result_values}->{$first . '_absolute'} : '', $self->{output_absolute_unit});
      
      if (!defined($self->{output_use})) {
          if ($self->{per_second} == 1) {
              $value = $self->{result_values}->{$first . '_per_second'};
              $unit = $self->{output_per_second_unit};
          }
      } else {
          $value = $self->{result_values}->{$self->{output_use}};
      }
  
      if ($self->{output_change_bytes} == 1) {
          ($value, $unit) = $self->{perfdata}->change_bytes(value => $value);
      } elsif ($self->{output_change_bytes} == 2) {
          ($value, $unit) = $self->{perfdata}->change_bytes(value => $value, network => 1);
      }
      
      return sprintf($self->{output_template}, $value, $unit);
  }
  
  sub use_instances {
      my ($self, %options) = @_;
  
      if (!defined($options{extra_instance}) || $options{extra_instance} != 0 || $self->{output}->use_new_perfdata()) {
          return 1;
      }
      
      return 0;
  }
  
  sub perfdata {
      my ($self, %options) = @_;
      
      if (defined($self->{closure_custom_perfdata})) {
          return &{$self->{closure_custom_perfdata}}($self, %options);
      }
      
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel}; 
      
      foreach my $perf (@{$self->{perfdatas}}) {
          my ($label, $extra_label, $min, $max, $th_total) = ($self->{label}, '');
          my $cast_int = (defined($perf->{cast_int}) && $perf->{cast_int} == 1) ? 1 : 0;
          my $template = '%s';
          
          $template = $perf->{template} if (defined($perf->{template}));
          $label = $perf->{label} if (defined($perf->{label}));
          if (defined($perf->{min})) {
              $min = ($perf->{min} =~ /[^0-9]/) ? $self->{result_values}->{$perf->{min}} : $perf->{min};
          }
          if (defined($perf->{max})) {
              $max = ($perf->{max} =~ /[^0-9]/) ? $self->{result_values}->{$perf->{max}} : $perf->{max};
          }
          if (defined($perf->{threshold_total})) {
              $th_total = ($perf->{threshold_total} =~ /[^0-9]/) ? $self->{result_values}->{$perf->{threshold_total}} : $perf->{threshold_total};
          }
          
          my $instances;
          if (defined($perf->{label_extra_instance}) && $perf->{label_extra_instance} == 1) {
              my $instance = '';
              if (defined($perf->{instance_use})) {
                  $instance = $self->{result_values}->{$perf->{instance_use}};
              } else {
                  $instance = $self->{instance};
              }
              
              if (!defined($options{extra_instance}) || $options{extra_instance} != 0 || $self->{output}->use_new_perfdata()) {
                  $instances = $instance;
              }
          }
  
          $self->{output}->perfdata_add(
              label => $label,
              instances => $instances,
              nlabel => $self->{nlabel},
              unit => $perf->{unit},
              value => $cast_int == 1 ? int($self->{result_values}->{$perf->{value}}) : sprintf($template, $self->{result_values}->{$perf->{value}}),
              warning => $self->{perfdata}->get_perfdata_for_output(label => $warn, total => $th_total, cast_int => $cast_int),
              critical => $self->{perfdata}->get_perfdata_for_output(label => $crit, total => $th_total, cast_int => $cast_int),
              min => $min, max => $max
          );
      }
  }
  
  sub execute {
      my ($self, %options) = @_;
      my $old_datas = {};
  
      $self->{result_values} = {},
      $self->{error_msg} = undef;
      my $quit = 0;
      my $per_second = 0;
      
      $options{new_datas} = {} if (!defined($options{new_datas}));
      foreach my $value (@{$self->{key_values}}) {
          if (!defined($options{values}->{$value->{name}}) || 
              defined($value->{no_value}) && $options{values}->{$value->{name}} eq $value->{no_value}) {
              $quit = 2;
              last;
          }
      
          if (defined($value->{diff}) && $value->{diff} == 1) {            
              $options{new_datas}->{$self->{instance} . '_' . $value->{name}} = $options{values}->{$value->{name}};
              $old_datas->{$self->{instance} . '_' . $value->{name}} = $self->{statefile}->get(name => $self->{instance} . '_' . $value->{name});
              if (!defined($old_datas->{$self->{instance} . '_' . $value->{name}})) {
                  $quit = 1;
                  next;
              }
              if ($old_datas->{$self->{instance} . '_' . $value->{name}} > $options{new_datas}->{$self->{instance} . '_' . $value->{name}}) {
                  $old_datas->{$self->{instance} . '_' . $value->{name}} = 0;
              }
          } else {
              $options{new_datas}->{$self->{instance} . '_' . $value->{name}} = $options{values}->{$value->{name}};
              if (defined($self->{statefile})) {
                  $old_datas->{$self->{instance} . '_' . $value->{name}} = $self->{statefile}->get(name => $self->{instance} . '_' . $value->{name});
              }
          }
      }
      
      # Very manual
      if ($self->{manual_keys} == 1) {
          foreach my $name (keys %{$options{values}}) {
              $options{new_datas}->{$self->{instance} . '_' . $name} = $options{values}->{$name};
              if (defined($self->{statefile})) {
                  $old_datas->{$self->{instance} . '_' . $name} = $self->{statefile}->get(name => $self->{instance} . '_' . $name);
              }
          }
      }
  
      if ($quit == 2) {
          $self->{error_msg} = "skipped (no value(s))";
          return -10;
      }
      
      if ($quit == 1) {
          $self->{error_msg} = "Buffer creation";
          return -1;
      }
      
      if (defined($self->{per_second}) && $self->{per_second} == 1) {
          if (!defined($self->{last_timestamp})) {
              $self->{last_timestamp} = $self->{statefile}->get(name => 'last_timestamp');
          }
          if (!defined($self->{last_timestamp})) {
              $self->{error_msg} = "Buffer creation";
              return -1;
          }
      }
     
      my $delta_time;
      if (defined($self->{per_second}) && $self->{per_second} == 1) {
          $delta_time = $options{new_datas}->{last_timestamp} - $self->{last_timestamp};
          if ($delta_time <= 0) {
              $delta_time = 1;
          }
      }
  
      if (defined($self->{closure_custom_calc})) {
          return $self->{closure_custom_calc}->($self, old_datas => $old_datas, new_datas => $options{new_datas}, delta_time => $delta_time, extra_options => $self->{closure_custom_calc_extra_options});
      }
      return $self->calc(old_datas => $old_datas, new_datas => $options{new_datas}, delta_time => $delta_time);
  }
  
  1;
  
  
CENTREON_PLUGINS_VALUES

$fatpacked{"storage/netapp/snmp/mode/aggregatestate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_AGGREGATESTATE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::aggregatestate;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub custom_state_threshold {
      my ($self, %options) = @_;
      
      return $self->{instance_mode}->get_severity(section => 'state', value => $self->{result_values}->{aggrState});
  }
  
  sub custom_state_calc {
      my ($self, %options) = @_;
      
      $self->{result_values}->{aggrState} = $options{new_datas}->{$self->{instance} . '_aggrState'};
      return 0;
  }
  
  sub custom_status_threshold {
      my ($self, %options) = @_;
      
      return $self->{instance_mode}->get_severity(section => 'status', value => $self->{result_values}->{aggrStatus});
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
      
      $self->{result_values}->{aggrStatus} = $options{new_datas}->{$self->{instance} . '_aggrStatus'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'agg', type => 1, cb_prefix_output => 'prefix_agg_output', message_multiple => 'All aggregates are ok' },
      ];
      
      $self->{maps_counters}->{agg} = [
          { label => 'state', set => {
                  key_values => [ { name => 'aggrState' } ],
                  closure_custom_calc => $self->can('custom_state_calc'),
                  output_template => "State : '%s'", output_error_template => "State : '%s'",
                  output_use => 'aggrState',
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => $self->can('custom_state_threshold'),
              }
          },
          { label => 'status', set => {
                  key_values => [ { name => 'aggrStatus' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  output_template => "Status : '%s'", output_error_template => "Status : '%s'",
                  output_use => 'aggrStatus',
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => $self->can('custom_status_threshold'),
              }
          },
      ];
  }
  
  sub prefix_agg_output {
      my ($self, %options) = @_;
  
      return "Aggregate '" . $options{instance_value}->{aggrName} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "filter-name:s"         => { name => 'filter_name' },
          "threshold-overload:s@" => { name => 'threshold_overload' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->{overload_th} = {};
      foreach my $val (@{$self->{option_results}->{threshold_overload}}) {
          if ($val !~ /^(.*?),(.*?),(.*)$/) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload option '" . $val . "'.");
              $self->{output}->option_exit();
          }
          my ($section, $status, $filter) = ($1, $2, $3);
          if ($self->{output}->is_litteral_status(status => $status) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload status '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->{overload_th}->{$section} = [] if (!defined($self->{overload_th}->{$section}));
          push @{$self->{overload_th}->{$section}}, {filter => $filter, status => $status};
      }
  }
  
  my $thresholds = {
      state => [
          ['online', 'OK'],
          ['offline', 'CRITICAL'],
      ],
      status => [
          ['normal', 'OK'],
          ['mirrored', 'OK'],
          ['.*', 'CRITICAL'],
      ],
  };
  
  sub get_severity {
      my ($self, %options) = @_;
      my $status = 'UNKNOWN'; # default 
      
      if (defined($self->{overload_th}->{$options{section}})) {
          foreach (@{$self->{overload_th}->{$options{section}}}) {            
              if ($options{value} =~ /$_->{filter}/i) {
                  $status = $_->{status};
                  return $status;
              }
          }
      }
      foreach (@{$thresholds->{$options{section}}}) {           
          if ($options{value} =~ /$$_[0]/i) {
              $status = $$_[1];
              return $status;
          }
      }
      
      return $status;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_aggrName = '.1.3.6.1.4.1.789.1.5.11.1.2';
      my $oid_aggrState = '.1.3.6.1.4.1.789.1.5.11.1.5';
      my $oid_aggrStatus = '.1.3.6.1.4.1.789.1.5.11.1.6';
      my $snmp_result = $options{snmp}->get_multiple_table(
          oids => [
              { oid => $oid_aggrName },
              { oid => $oid_aggrState },
              { oid => $oid_aggrStatus },
          ],
          nothing_quit => 1
      );
  
      $self->{agg} = {};
      foreach my $oid (keys %{$snmp_result->{$oid_aggrState}}) {
          next if ($oid !~ /^$oid_aggrState\.(.*)$/);
          my $instance = $1;
          my $name = $snmp_result->{$oid_aggrName}->{$oid_aggrName . '.' . $instance};
          my $state = $snmp_result->{$oid_aggrState}->{$oid_aggrState . '.' . $instance};
          my $status = $snmp_result->{$oid_aggrStatus}->{$oid_aggrStatus . '.' . $instance};
          
          if (!defined($state) || $state eq '') {
              $self->{output}->output_add(long_msg => "skipping  '" . $name . "': state value not set.");
              next;
          } 
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $name !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping  '" . $name . "': no matching filter name.");
              next;
          }
          
          $self->{agg}->{$instance} = { aggrName => $name, aggrState => $state, aggrStatus => $status};
      }
      
      if (scalar(keys %{$self->{agg}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No aggregate found.");
          $self->{output}->option_exit();
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check state and status from aggregates.
  
  =over 8
  
  =item B<--filter-name>
  
  Filter by aggregate name.
  
  =item B<--threshold-overload>
  
  Set to overload default threshold values (syntax: section,status,regexp)
  It used before default thresholds (order stays).
  Example: --threshold-overload='state,CRITICAL,^(?!(online)$)'
  
  =back
  
  =cut
STORAGE_NETAPP_SNMP_MODE_AGGREGATESTATE

$fatpacked{"storage/netapp/snmp/mode/cacheage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_CACHEAGE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::cacheage;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  { 
                                    "warning:s"               => { name => 'warning' },
                                    "critical:s"              => { name => 'critical' },
                                  });
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      if (($self->{perfdata}->threshold_validate(label => 'warning', value => $self->{option_results}->{warning})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong warning threshold '" . $self->{option_results}->{warning} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'critical', value => $self->{option_results}->{critical})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong critical threshold '" . $self->{option_results}->{critical} . "'.");
          $self->{output}->option_exit();
      }    
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_cacheAge = ".1.3.6.1.4.1.789.1.2.2.23.0"; 
  
      my $result = $self->{snmp}->get_leef(oids => [$oid_cacheAge],
                                           nothing_quit => 1);
                                           
      my $exit = $self->{perfdata}->threshold_check(value => $result->{$oid_cacheAge},
                                                    threshold => [ { label => 'critical', 'exit_litteral' => 'critical' },
                                                                   { label => 'warning', exit_litteral => 'warning' } ]);
      $self->{output}->output_add(severity => $exit,
                                  short_msg => sprintf("Cache age is '%s' minutes", $result->{$oid_cacheAge}));
      $self->{output}->perfdata_add(label => 'cache_age', unit => 'm',
                                    value => $result->{$oid_cacheAge},
                                    warning => $self->{option_results}->{warning},
                                    critical => $self->{option_results}->{critical},
                                    min => 0);
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check age in minutes of the oldest read-only blocks in the buffer cache.
  
  =over 8
  
  =item B<--warning>
  
  Threshold warning in minutes
  
  =item B<--critical>
  
  Threshold critical in minutes
  
  =back
  
  =cut
STORAGE_NETAPP_SNMP_MODE_CACHEAGE

$fatpacked{"storage/netapp/snmp/mode/components/communication.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_COMPONENTS_COMMUNICATION';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::components::communication;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my %map_com_states = (
      1 => 'initializing', 
      2 => 'transitioning', 
      3 => 'active', 
      4 => 'inactive',
      5 => 'reconfiguring',
      6 => 'nonexistent',
  );
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclContactState = '.1.3.6.1.4.1.789.1.21.1.2.1.2';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclContactState };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking communications");
      $self->{components}->{communication} = {name => 'communications', total => 0, skip => 0};
      return if ($self->check_filter(section => 'communication'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my $com_state = $map_com_states{$self->{results}->{$oid_enclContactState}->{$oid_enclContactState . '.' . $i}};
  
          next if ($self->check_filter(section => 'communication', instance => $shelf_addr));
          
          $self->{components}->{communication}->{total}++;
          $self->{output}->output_add(long_msg => sprintf("Shelve '%s' communication state is '%s'", 
                                                            $shelf_addr, $com_state));
          my $exit = $self->get_severity(section => 'communication', value => $com_state);
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Shelve '%s' communication state is '%s'", 
                                                            $shelf_addr, $com_state));
          }
      }
  }
  
  1;
STORAGE_NETAPP_SNMP_MODE_COMPONENTS_COMMUNICATION

$fatpacked{"storage/netapp/snmp/mode/components/electronics.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_COMPONENTS_ELECTRONICS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::components::electronics;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclElectronicsPresent = '.1.3.6.1.4.1.789.1.21.1.2.1.31';
  my $oid_enclElectronicsFailed = '.1.3.6.1.4.1.789.1.21.1.2.1.33';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclElectronicsPresent }, { oid => $oid_enclElectronicsFailed };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking electronics");
      $self->{components}->{electronics} = {name => 'electronics', total => 0, skip => 0};
      return if ($self->check_filter(section => 'electronics'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my $present = $self->{results}->{$oid_enclElectronicsPresent}->{$oid_enclElectronicsPresent . '.' . $i};
          my $failed = $self->{results}->{$oid_enclElectronicsFailed}->{$oid_enclElectronicsFailed . '.' . $i};
          
          foreach my $num (split /,/, $present) {
              $num = centreon::plugins::misc::trim($num);
              next if ($num !~ /[0-9]/);
              
              next if ($self->check_filter(section => 'electronics', instance => $shelf_addr . '.' . $num));
              $self->{components}->{electronics}->{total}++;
  
              my $status = 'ok';
              if ($failed =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'failed';
              }
  
              $self->{output}->output_add(long_msg => sprintf("Shelve '%s' electronics '%s' is '%s'", 
                                          $shelf_addr, $num, $status));
              my $exit = $self->get_severity(section => 'electronics', value => $status);
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Shelve '%s' electronics '%s' is '%s'", $shelf_addr, $num, $status));
              }
          }
      }
  }
  
  1;
STORAGE_NETAPP_SNMP_MODE_COMPONENTS_ELECTRONICS

$fatpacked{"storage/netapp/snmp/mode/components/fan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_COMPONENTS_FAN';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::components::fan;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclFansPresent = '.1.3.6.1.4.1.789.1.21.1.2.1.17';
  my $oid_enclFansFailed = '.1.3.6.1.4.1.789.1.21.1.2.1.18';
  my $oid_enclFansSpeed = '.1.3.6.1.4.1.789.1.21.1.2.1.62';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclFansPresent }, { oid => $oid_enclFansFailed },
          { oid => $oid_enclFansSpeed };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking fans");
      $self->{components}->{fan} = {name => 'fans', total => 0, skip => 0};
      return if ($self->check_filter(section => 'fan'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my $present = $self->{results}->{$oid_enclFansPresent}->{$oid_enclFansPresent . '.' . $i};
          my $failed = $self->{results}->{$oid_enclFansFailed}->{$oid_enclFansFailed . '.' . $i};
          my @current_speed = defined($self->{results}->{$oid_enclFansSpeed}->{$oid_enclFansSpeed . '.' . $i}) ? split /,/, $self->{results}->{$oid_enclFansSpeed}->{$oid_enclFansSpeed . '.' . $i} : ();
          
          foreach my $num (split /,/, $present) {
              $num = centreon::plugins::misc::trim($num);
              next if ($num !~ /[0-9]/);
              my $current_value = (defined($current_speed[$num - 1]) && $current_speed[$num - 1] =~ /(^|\s)([0-9]+)/) ? $2 : '';
              
              next if ($self->check_filter(section => 'fan', instance => $shelf_addr . '.' . $num));
              $self->{components}->{fan}->{total}++;
  
              my $status = 'ok';
              if ($failed =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'failed';
              }
  
              $self->{output}->output_add(long_msg => sprintf("Shelve '%s' Fan '%s' is '%s'", 
                                          $shelf_addr, $num, $status));
              my $exit = $self->get_severity(section => 'fan', value => $status);
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Shelve '%s' Fan '%s' is '%s'", $shelf_addr, $num, $status));
              }
              
              if ($current_value ne '') {
                  my ($exit, $warn, $crit) = $self->get_severity_numeric(section => 'fan', instance => $shelf_addr . '.' . $num, value => $current_value);
                  if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                      $self->{output}->output_add(severity => $exit,
                                                  short_msg => sprintf("Shelve '%s' Fan '%s' speed is '%s'", $shelf_addr, $num, $current_value));
                  }
                  
                  $self->{output}->perfdata_add(
                      label => "speed", unit => 'rpm',
                      nlabel => 'hardware.fan.speed.rpm',
                      instances => [$shelf_addr, $num],
                      value => $current_value,
                      warning => $warn,
                      critical => $crit,
                      min => 0
                  );
              }
          }
      }
  }
  
  1;
STORAGE_NETAPP_SNMP_MODE_COMPONENTS_FAN

$fatpacked{"storage/netapp/snmp/mode/components/psu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_COMPONENTS_PSU';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::components::psu;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclPowerSuppliesPresent = '.1.3.6.1.4.1.789.1.21.1.2.1.13';
  my $oid_enclPowerSuppliesFailed = '.1.3.6.1.4.1.789.1.21.1.2.1.15';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclPowerSuppliesPresent }, { oid => $oid_enclPowerSuppliesFailed };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking power supplies");
      $self->{components}->{psu} = {name => 'psus', total => 0, skip => 0};
      return if ($self->check_filter(section => 'psu'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my $present = $self->{results}->{$oid_enclPowerSuppliesPresent}->{$oid_enclPowerSuppliesPresent . '.' . $i};
          my $failed = $self->{results}->{$oid_enclPowerSuppliesFailed}->{$oid_enclPowerSuppliesFailed . '.' . $i};
          
          foreach my $num (split /,/, $present) {
              $num = centreon::plugins::misc::trim($num);
              next if ($num !~ /[0-9]/);
              
              next if ($self->check_filter(section => 'psu', instance => $shelf_addr . '.' . $num));
              $self->{components}->{psu}->{total}++;
  
              my $status = 'ok';
              if ($failed =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'failed';
              }
  
              $self->{output}->output_add(long_msg => sprintf("Shelve '%s' PSU '%s' is '%s'", 
                                          $shelf_addr, $num, $status));
              my $exit = $self->get_severity(section => 'psu', value => $status);
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Shelve '%s' PSU '%s' is '%s'", $shelf_addr, $num, $status));
              }
          }
      }
  }
  
  1;
STORAGE_NETAPP_SNMP_MODE_COMPONENTS_PSU

$fatpacked{"storage/netapp/snmp/mode/components/raid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_COMPONENTS_RAID';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::components::raid;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my %map_raid_states = (
      1 => 'active',
      2 => 'reconstructionInProgress',
      3 => 'parityReconstructionInProgress',
      4 => 'parityVerificationInProgress',
      5 => 'scrubbingInProgress',
      6 => 'failed',
      9 => 'prefailed',
      10 => 'offline',
  );
  my $oid_raidPStatus = '.1.3.6.1.4.1.789.1.6.10.1.2';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_raidPStatus };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking raids");
      $self->{components}->{raid} = {name => 'raids', total => 0, skip => 0};
      return if ($self->check_filter(section => 'raid'));
  
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_raidPStatus}})) {
          $oid =~ /^$oid_raidPStatus\.(.*)$/;
          my $instance = $1;
          my $raid_state = $map_raid_states{$self->{results}->{$oid_raidPStatus}->{$oid}};
  
          next if ($self->check_filter(section => 'raid', instance => $instance));
          
          $self->{components}->{raid}->{total}++;
          $self->{output}->output_add(long_msg => sprintf("Raid '%s' state is '%s'", 
                                                          $instance, $raid_state));
          my $exit = $self->get_severity(section => 'raid', value => $raid_state);
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Raid '%s' state is '%s'", 
                                                               $instance, $raid_state));
          }
      }
  }
  
  1;
STORAGE_NETAPP_SNMP_MODE_COMPONENTS_RAID

$fatpacked{"storage/netapp/snmp/mode/components/temperature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_COMPONENTS_TEMPERATURE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::components::temperature;
  
  use strict;
  use warnings;
  
  my %map_hum_status = (
      1 => 'noStatus',
      2 => 'normal',
      3 => 'highWarning',
      4 => 'highCritical',
      5 => 'lowWarning',
      6 => 'lowCritical',
      7 => 'sensorError',
  );
  my %map_hum_online = (
      1 => 'online',
      2 => 'offline',
  );
  
  my $mapping = {
      enclTempSensorsPresent => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.20' },
      enclTempSensorsOverTempFail => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.21' },
      enclTempSensorsOverTempWarn => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.22' },
      enclTempSensorsUnderTempFail => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.23' },
      enclTempSensorsUnderTempWarn => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.24' },
      enclTempSensorsCurrentTemp => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.25' },
      enclTempSensorsOverTempFailThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.26' },
      enclTempSensorsOverTempWarnThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.27' },
      enclTempSensorsUnderTempFailThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.28' },
      enclTempSensorsUnderTempWarnThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.29' },
  };
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclEntry = '.1.3.6.1.4.1.789.1.21.1.2.1';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclEntry, begin => $mapping->{enclTempSensorsPresent}->{oid}, end => $mapping->{enclTempSensorsUnderTempWarnThr}->{oid} };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking temperatures");
      $self->{components}->{temperature} = {name => 'temperatures', total => 0, skip => 0};
      return if ($self->check_filter(section => 'temperature'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_enclEntry}, instance => $i);
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my @current_temp = split /,/, $result->{enclTempSensorsCurrentTemp};
          
          my @warn_under_thr = split /,/, $result->{enclTempSensorsUnderTempWarnThr};
          my @crit_under_thr = split /,/, $result->{enclTempSensorsUnderTempFailThr};
          my @warn_over_thr = split /,/, $result->{enclTempSensorsOverTempWarnThr};
          my @crit_over_thr = split /,/, $result->{enclTempSensorsOverTempFailThr};
  
          foreach my $num (split /,/, $result->{enclTempSensorsPresent}) {
              $num = centreon::plugins::misc::trim($num);
              next if ($num !~ /[0-9]/ || !defined($current_temp[$num - 1]));
              
              next if ($self->check_filter(section => 'temperature', instance => $shelf_addr . '.' . $num));
      
              $warn_under_thr[$num - 1] =~ /(-*[0-9]+)C/;
              my $wu_thr = $1;
              $crit_under_thr[$num - 1] =~ /(-*[0-9]+)C/;
              my $cu_thr = $1;
              $warn_over_thr[$num - 1] =~ /(-*[0-9]+)C/;
              my $wo_thr = $1;
              $crit_over_thr[$num - 1] =~ /(-*[0-9]+)C/;
              my $co_thr = $1;
              $current_temp[$num - 1] =~ /(-*[0-9]+)C/;
              my $current_value = $1;
              
              $self->{components}->{temperature}->{total}++;
              
              my $status = 'ok';
              if ($result->{enclTempSensorsUnderTempFailThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'under critical threshold';
              } elsif ($result->{enclTempSensorsUnderTempWarnThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'under warning threshold';
              } elsif ($result->{enclTempSensorsOverTempFailThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'over critical threshold';
              } elsif ($result->{enclTempSensorsOverTempWarnThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'over warning threshold';
              }
              
              $self->{output}->output_add(long_msg => sprintf("Shelve '%s' temperature sensor '%s' is %s [current = %s]", 
                                                              $shelf_addr, $num, $status, $current_value));
              my $exit = $self->get_severity(section => 'temperature', value => $status);
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Shelve '%s' temperature sensor '%s' is %s", 
                                                                   $shelf_addr, $num, $status));
              }
              
              my $warn = $wu_thr . ':' . $wo_thr;
              my $crit = $cu_thr . ':' . $co_thr;
              my ($exit2, $warn2, $crit2, $checked) = $self->get_severity_numeric(section => 'temperature', instance => $shelf_addr . '.' . $num, value => $current_value);
              if ($checked == 1) { 
                 ($warn, $crit) = ($warn2, $crit2);
              }
              
              if (!$self->{output}->is_status(value => $exit2, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit2,
                                              short_msg => sprintf("Shelve '%s' temperature sensor '%s' is %s degree centigrade", 
                                                                   $shelf_addr, $num, $current_value));
              }
              
              $self->{output}->perfdata_add(
                  label => "temp", unit => 'C',
                  nlabel => 'hardware.temperature.celsius',
                  instances => [$shelf_addr, $num],
                  value => $current_value,
                  warning => $warn,
                  critical => $crit
              );
          }
      }
  }
  
  1;
STORAGE_NETAPP_SNMP_MODE_COMPONENTS_TEMPERATURE

$fatpacked{"storage/netapp/snmp/mode/components/voltage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_COMPONENTS_VOLTAGE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::components::voltage;
  
  use strict;
  use warnings;
  
  my %map_hum_status = (
      1 => 'noStatus',
      2 => 'normal',
      3 => 'highWarning',
      4 => 'highCritical',
      5 => 'lowWarning',
      6 => 'lowCritical',
      7 => 'sensorError',
  );
  my %map_hum_online = (
      1 => 'online',
      2 => 'offline',
  );
  
  my $mapping = {
      enclVoltSensorsPresent => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.35' },
      enclVoltSensorsOverVoltFail => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.36' },
      enclVoltSensorsOverVoltWarn => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.37' },
      enclVoltSensorsUnderVoltFail => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.38' },
      enclVoltSensorsUnderVoltWarn => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.39' },
      enclVoltSensorsCurrentVolt => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.40' },
      enclVoltSensorsOverVoltFailThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.41' },
      enclVoltSensorsOverVoltWarnThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.42' },
      enclVoltSensorsUnderVoltFailThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.43' },
      enclVoltSensorsUnderVoltWarnThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.44' },
  };
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclTable = '.1.3.6.1.4.1.789.1.21.1.2';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclTable, begin => $mapping->{enclVoltSensorsPresent}->{oid}, end => $mapping->{enclVoltSensorsUnderVoltWarnThr}->{oid} };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking voltages");
      $self->{components}->{voltage} = {name => 'voltages', total => 0, skip => 0};
      return if ($self->check_filter(section => 'voltage'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_enclTable}, instance => $i);
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my @current_volt = defined($result->{enclVoltSensorsCurrentVolt}) ? split /,/, $result->{enclVoltSensorsCurrentVolt} : ();
          
          my @warn_under_thr = defined($result->{enclVoltSensorsUnderVoltWarnThr}) ? split /,/, $result->{enclVoltSensorsUnderVoltWarnThr} : ();
          my @crit_under_thr = defined($result->{enclVoltSensorsUnderVoltFailThr}) ? split /,/, $result->{enclVoltSensorsUnderVoltFailThr} : ();
          my @warn_over_thr = defined($result->{enclVoltSensorsOverVoltWarnThr}) ? split /,/, $result->{enclVoltSensorsOverVoltWarnThr} : ();
          my @crit_over_thr = defined($result->{enclVoltSensorsOverVoltFailThr}) ? split /,/, $result->{enclVoltSensorsOverVoltFailThr} : ();
  
          my @values = defined($result->{enclVoltSensorsPresent}) ? split /,/, $result->{enclVoltSensorsPresent} : ();
          foreach my $num (@values) {
              $num = centreon::plugins::misc::trim($num);
              next if ($num !~ /[0-9]/ || !defined($current_volt[$num - 1]));
      
              my $wu_thr = (defined($warn_under_thr[$num - 1]) && $warn_under_thr[$num - 1] =~ /(^|\s)(-*[0-9]+)/) ? $2 : '';
              my $cu_thr = (defined($crit_under_thr[$num - 1]) && $crit_under_thr[$num - 1] =~ /(^|\s)(-*[0-9]+)/) ? $2 : '';
              my $wo_thr = (defined($warn_over_thr[$num - 1]) && $warn_over_thr[$num - 1] =~ /(^|\s)(-*[0-9]+)/) ? $2 : '';
              my $co_thr = (defined($crit_over_thr[$num - 1]) && $crit_over_thr[$num - 1] =~ /(^|\s)(-*[0-9]+)/) ? $2 : '';
              my $current_value = ($current_volt[$num - 1] =~ /(^|\s)(-*[0-9]+)/) ? $2 : '';
              
              next if ($self->check_filter(section => 'voltage', instance => $shelf_addr . '.' . $num));
              $self->{components}->{voltage}->{total}++;
              
              my $status = 'ok';
              if ($result->{enclVoltSensorsUnderVoltFailThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'under critical threshold';
              } elsif ($result->{enclVoltSensorsUnderVoltWarnThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'under warning threshold';
              } elsif ($result->{enclVoltSensorsOverVoltFailThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'over critical threshold';
              } elsif ($result->{enclVoltSensorsOverVoltWarnThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'over warning threshold';
              }
              
              $self->{output}->output_add(long_msg => sprintf("Shelve '%s' voltage sensor '%s' is %s [current = %s]", 
                                                              $shelf_addr, $num, $status, $current_value));
              my $exit = $self->get_severity(section => 'voltage', value => $status);
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Shelve '%s' voltage sensor '%s' is %s", 
                                                                   $shelf_addr, $num, $status));
              }
              
              my $warn = $wu_thr . ':' . $wo_thr;
              my $crit = $cu_thr . ':' . $co_thr;
              my ($exit2, $warn2, $crit2, $checked) = $self->get_severity_numeric(section => 'voltage', instance => $shelf_addr . '.' . $num, value => $current_value);
              if ($checked == 1) { 
                 ($warn, $crit) = ($warn2, $crit2);
              }
              
              if (!$self->{output}->is_status(value => $exit2, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit2,
                                              short_msg => sprintf("Shelve '%s' voltage sensor '%s' is %s mV", 
                                                                   $shelf_addr, $num, $current_value));
              }
              
              $self->{output}->perfdata_add(
                  label => "volt", unit => 'mV',
                  nlabel => 'hardware.voltage.millivolt',
                  instances => [$shelf_addr, $num],
                  value => $current_value,
                  warning => $warn,
                  critical => $crit
              );
          }
      }
  }
  
  1;
STORAGE_NETAPP_SNMP_MODE_COMPONENTS_VOLTAGE

$fatpacked{"storage/netapp/snmp/mode/cpstatistics.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_CPSTATISTICS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::cpstatistics;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1, -11 => 1 } }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'timer', nlabel => 'storage.cp.timer.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'timer', diff => 1 }, ],
                  output_template => 'CP timer : %s',
                  perfdatas => [
                      { value => 'timer_absolute', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'snapshot', nlabel => 'storage.cp.snapshot.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'snapshot', diff => 1 }, ],
                  output_template => 'CP snapshot : %s',
                  perfdatas => [
                      { value => 'snapshot_absolute', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'lowerwater', nlabel => 'storage.cp.lowerwatermark.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'lowerwater', diff => 1 }, ],
                  output_template => 'CP low water mark : %s',
                  perfdatas => [
                      { value => 'lowerwater_absolute', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'highwater', nlabel => 'storage.cp.highwatermark.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'highwater', diff => 1 }, ],
                  output_template => 'CP high water mark : %s',
                  perfdatas => [
                      { value => 'highwater_absolute', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'logfull', nlabel => 'storage.cp.logfull.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'logfull', diff => 1 }, ],
                  output_template => 'CP nv-log full : %s',
                  perfdatas => [
                      { value => 'logfull_absolute', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'back', nlabel => 'storage.cp.back2back.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'back', diff => 1 }, ],
                  output_template => 'CP back-to-back : %s',
                  perfdatas => [
                      { value => 'back_absolute', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'flush', nlabel => 'storage.cp.flushunlog.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'flush', diff => 1 }, ],
                  output_template => 'CP flush unlogged write data : %s',
                  perfdatas => [
                      { value => 'flush_absolute', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'sync', nlabel => 'storage.cp.syncrequests.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'sync', diff => 1 }, ],
                  output_template => 'CP sync requests : %s',
                  perfdatas => [
                      { value => 'sync_absolute', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'lowvbuf', nlabel => 'storage.cp.lowvirtualbuffers.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'lowvbuf', diff => 1 }, ],
                  output_template => 'CP low virtual buffers : %s',
                  perfdatas => [
                      { value => 'lowvbuf_absolute', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'deferred', nlabel => 'storage.cp.deferred.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'deferred', diff => 1 }, ],
                  output_template => 'CP deferred : %s',
                  perfdatas => [
                      { value => 'deferred_absolute', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'lowdatavecs', nlabel => 'storage.cp.lowdatavecs.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'lowdatavecs', diff => 1 }, ],
                  output_template => 'CP low datavecs : %s',
                  perfdatas => [
                      { value => 'lowdatavecs_absolute', template => '%d', min => 0 },
                  ],
              }
          },
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  my $oid_cpFromTimerOps = '.1.3.6.1.4.1.789.1.2.6.2.0';
  my $oid_cpFromSnapshotOps = '.1.3.6.1.4.1.789.1.2.6.3.0';
  my $oid_cpFromLowWaterOps = '.1.3.6.1.4.1.789.1.2.6.4.0';
  my $oid_cpFromHighWaterOps = '.1.3.6.1.4.1.789.1.2.6.5.0';
  my $oid_cpFromLogFullOps = '.1.3.6.1.4.1.789.1.2.6.6.0';
  my $oid_cpFromCpOps = '.1.3.6.1.4.1.789.1.2.6.7.0';
  my $oid_cpTotalOps = '.1.3.6.1.4.1.789.1.2.6.8.0';
  my $oid_cpFromFlushOps = '.1.3.6.1.4.1.789.1.2.6.9.0';
  my $oid_cpFromSyncOps = '.1.3.6.1.4.1.789.1.2.6.10.0';
  my $oid_cpFromLowVbufOps = '.1.3.6.1.4.1.789.1.2.6.11.0';
  my $oid_cpFromCpDeferredOps = '.1.3.6.1.4.1.789.1.2.6.12.0';
  my $oid_cpFromLowDatavecsOps = '.1.3.6.1.4.1.789.1.2.6.13.0';
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $request = [
          $oid_cpFromTimerOps, $oid_cpFromSnapshotOps,
          $oid_cpFromLowWaterOps, $oid_cpFromHighWaterOps,
          $oid_cpFromLogFullOps, $oid_cpFromCpOps,
          $oid_cpTotalOps, $oid_cpFromFlushOps,
          $oid_cpFromSyncOps, $oid_cpFromLowVbufOps,
          $oid_cpFromCpDeferredOps, $oid_cpFromLowDatavecsOps
      ];
      
      my $snmp_result = $options{snmp}->get_leef(oids => $request, nothing_quit => 1);
  
      $self->{output}->output_add(
          severity => 'OK',
          short_msg => 'All CP statistics are ok'
      );
  
      $self->{global} = {};
      $self->{global}->{timer} = defined($snmp_result->{$oid_cpFromTimerOps}) ? $snmp_result->{$oid_cpFromTimerOps} : undef;
      $self->{global}->{snapshot} = defined($snmp_result->{$oid_cpFromSnapshotOps}) ? $snmp_result->{$oid_cpFromSnapshotOps} : undef;
      $self->{global}->{lowerwater} = defined($snmp_result->{$oid_cpFromLowWaterOps}) ? $snmp_result->{$oid_cpFromLowWaterOps} : undef;
      $self->{global}->{highwater} = defined($snmp_result->{$oid_cpFromHighWaterOps}) ? $snmp_result->{$oid_cpFromHighWaterOps} : undef;
      $self->{global}->{logfull} = defined($snmp_result->{$oid_cpFromLogFullOps}) ? $snmp_result->{$oid_cpFromLogFullOps} : undef;
      $self->{global}->{back} = defined($snmp_result->{$oid_cpFromCpOps}) ? $snmp_result->{$oid_cpFromCpOps} : undef;
      $self->{global}->{flush} = defined($snmp_result->{$oid_cpFromFlushOps}) ? $snmp_result->{$oid_cpFromFlushOps} : undef;
      $self->{global}->{sync} = defined($snmp_result->{$oid_cpFromSyncOps}) ? $snmp_result->{$oid_cpFromSyncOps} : undef;
      $self->{global}->{lowvbuf} = defined($snmp_result->{$oid_cpFromLowVbufOps}) ? $snmp_result->{$oid_cpFromLowVbufOps} : undef;
      $self->{global}->{deferred} = defined($snmp_result->{$oid_cpFromCpDeferredOps}) ? $snmp_result->{$oid_cpFromCpDeferredOps} : undef;
      $self->{global}->{lowdatavecs} = defined($snmp_result->{$oid_cpFromLowDatavecsOps}) ? $snmp_result->{$oid_cpFromLowDatavecsOps} : undef;
  
      $self->{cache_name} = "cache_netapp_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Check consistency point metrics.
  
  =over 8
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'timer', 'snapshot', 'lowerwater', 'highwater', 
  'logfull', 'back', 'flush', 'sync', 'lowvbuf', 'deferred', 'lowdatavecs'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'timer', 'snapshot', 'lowerwater', 'highwater', 
  'logfull', 'back', 'flush', 'sync', 'lowvbuf', 'deferred', 'lowdatavecs'.
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_CPSTATISTICS

$fatpacked{"storage/netapp/snmp/mode/cpuload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_CPULOAD';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::cpuload;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                    "warning:s"            => { name => 'warning' },
                                    "critical:s"           => { name => 'critical' },
                                  });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (($self->{perfdata}->threshold_validate(label => 'warning', value => $self->{option_results}->{warning})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong warning threshold '" . $self->{option_results}->{warning} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'critical', value => $self->{option_results}->{critical})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong critical threshold '" . $self->{option_results}->{critical} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_cpuBusyTimePerCent = '.1.3.6.1.4.1.789.1.2.1.3.0';
      my $result = $self->{snmp}->get_leef(oids => [$oid_cpuBusyTimePerCent], nothing_quit => 1);
      
      my $exit = $self->{perfdata}->threshold_check(value => $result->{$oid_cpuBusyTimePerCent}, threshold => [ { label => 'critical', 'exit_litteral' => 'critical' }, { label => 'warning', exit_litteral => 'warning' } ]);
      $self->{output}->output_add(severity => $exit,
                                  short_msg => sprintf("CPU Usage %d %%", $result->{$oid_cpuBusyTimePerCent}));
      $self->{output}->perfdata_add(label => 'cpuload', unit => '%',
                                    value => sprintf("%d", $result->{$oid_cpuBusyTimePerCent}),
                                    warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning'),
                                    critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical'),
                                    min => 0, max => 100);
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check CPU usage.
  
  =over 8
  
  =item B<--warning>
  
  Threshold warning in percent.
  
  =item B<--critical>
  
  Threshold critical in percent.
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_CPULOAD

$fatpacked{"storage/netapp/snmp/mode/diskfailed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_DISKFAILED';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::diskfailed;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                  });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_diskFailedCount = '.1.3.6.1.4.1.789.1.6.4.7.0';
      my $oid_diskFailedMessage = '.1.3.6.1.4.1.789.1.6.4.10.0';
      my $result = $self->{snmp}->get_leef(oids => [$oid_diskFailedCount], nothing_quit => 1);
      
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'Disks are ok.');
      if ($result->{$oid_diskFailedCount} != 0) {
          $self->{output}->output_add(severity => 'CRITICAL',
                                      short_msg => sprintf("'%d' disks are failed [message: %s].", 
                                                      $result->{$oid_diskFailedCount}, 
                                                      defined($result->{$oid_diskFailedMessage}) ? $result->{$oid_diskFailedMessage} : '-'));
      }
  
      $self->{output}->perfdata_add(label => 'failed',
                                    value => $result->{$oid_diskFailedCount},
                                    min => 0);
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check the current number of disk broken.
  If you are in cluster mode, the following mode doesn't work. Ask to netapp to add it :)
  
  =over 8
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_DISKFAILED

$fatpacked{"storage/netapp/snmp/mode/fan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_FAN';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::fan;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                  });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_envFailedFanCount = '.1.3.6.1.4.1.789.1.2.4.2';
      my $oid_envFailedFanMessage = '.1.3.6.1.4.1.789.1.2.4.3';
      my $oid_nodeName = '.1.3.6.1.4.1.789.1.25.2.1.1';
      my $oid_nodeEnvFailedFanCount = '.1.3.6.1.4.1.789.1.25.2.1.19';
      my $oid_nodeEnvFailedFanMessage = '.1.3.6.1.4.1.789.1.25.2.1.20';
      my $results = $self->{snmp}->get_multiple_table(oids => [
                                                              { oid => $oid_envFailedFanCount }, 
                                                              { oid => $oid_envFailedFanMessage },
                                                              { oid => $oid_nodeName },
                                                              { oid => $oid_nodeEnvFailedFanCount },
                                                              { oid => $oid_nodeEnvFailedFanMessage }
                                                              ], nothing_quit => 1);
      
      if (defined($results->{$oid_envFailedFanCount}->{$oid_envFailedFanCount . '.0'})) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'Fans are ok.');
          if ($results->{$oid_envFailedFanCount}->{$oid_envFailedFanCount . '.0'} != 0) {
              $self->{output}->output_add(severity => 'CRITICAL',
                                          short_msg => sprintf("'%d' fans are failed [message: %s].", 
                                                          $results->{$oid_envFailedFanCount}->{$oid_envFailedFanCount . '.0'},
                                                          $results->{$oid_envFailedFanMessage}->{$oid_envFailedFanMessage . '.0'}));
          }
      } else {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'Fans are ok on all nodes');
          foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$results->{$oid_nodeEnvFailedFanCount}})) {
              $oid =~ /^$oid_nodeEnvFailedFanCount\.(.*)$/;
              my $instance = $1;
              my $name = $results->{$oid_nodeName}->{$oid_nodeName . '.' . $instance};
              my $count = $results->{$oid_nodeEnvFailedFanCount}->{$oid};
              my $message = $results->{$oid_nodeEnvFailedFanMessage}->{$oid_nodeEnvFailedFanMessage . '.' . $instance};
              $self->{output}->output_add(long_msg => sprintf("'%d' fans are failed on node '%s' [message: %s]", 
                                                              $count, $name, defined($message) ? $message : '-'));
              if ($count != 0) {
                  $self->{output}->output_add(severity => 'CRITICAL',
                                          short_msg => sprintf("'%d' fans are failed on node '%s' [message: %s]", 
                                                          $count, $name, defined($message) ? $message : '-'));
              }
          }
      }
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check if fans are failed (not operating within the recommended RPM range).
  
  =over 8
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_FAN

$fatpacked{"storage/netapp/snmp/mode/filesys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_FILESYS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::filesys;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'fs', type => 1, cb_prefix_output => 'prefix_fs_output', message_multiple => 'All filesystems are ok.' },
      ];
      
      $self->{maps_counters}->{fs} = [
          { label => 'usage', set => {
                  key_values => [ { name => 'display' }, { name => 'used' }, { name => 'total' } ],
                  closure_custom_calc => $self->can('custom_usage_calc'),
                  closure_custom_output => $self->can('custom_usage_output'),
                  closure_custom_perfdata => $self->can('custom_usage_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_usage_threshold'),
              }
          },
          { label => 'inodes', set => {
                  key_values => [ { name => 'dfPerCentInodeCapacity' }, { name => 'display' } ],
                  output_template => 'Inodes Used : %s %%', output_error_template => "Inodes : %s",
                  perfdatas => [
                      { label => 'inodes', value => 'dfPerCentInodeCapacity_absolute', template => '%d',
                         unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
          { label => 'compresssaved', set => {
                  key_values => [ { name => 'dfCompressSavedPercent' }, { name => 'display' } ],
                  output_template => 'Compress Saved : %s %%', output_error_template => "Compress Saved : %s",
                  perfdatas => [
                      { label => 'compresssaved', value => 'dfCompressSavedPercent_absolute', template => '%d',
                         unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
          { label => 'dedupsaved', set => {
                  key_values => [ { name => 'dfDedupeSavedPercent' }, { name => 'display' } ],
                  output_template => 'Dedupe Saved : %s %%', output_error_template => "Dedupe Saved : %s",
                  perfdatas => [
                      { label => 'dedupsaved', value => 'dfDedupeSavedPercent_absolute', template => '%d',
                         unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
      ];
  }
  
  sub custom_usage_perfdata {
      my ($self, %options) = @_;
      
      return if ($self->{result_values}->{total} <= 0);
      my $label = 'used';
      my $value_perf = $self->{result_values}->{used};
      if (defined($self->{instance_mode}->{option_results}->{free})) {
          $label = 'free';
          $value_perf = $self->{result_values}->{free};
      }
  
      my %total_options = ();
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $total_options{total} = $self->{result_values}->{total};
          $total_options{cast_int} = 1;
      }
  
      $self->{output}->perfdata_add(
          label => $label, unit => 'B',
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
          value => $value_perf,
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}, %total_options),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}, %total_options),
          min => 0, max => $self->{result_values}->{total}
      );
  }
  
  sub custom_usage_threshold {
      my ($self, %options) = @_;
      
      return 'ok' if ($self->{result_values}->{total} <= 0);
      my ($exit, $threshold_value);
      $threshold_value = $self->{result_values}->{used};
      $threshold_value = $self->{result_values}->{free} if (defined($self->{instance_mode}->{option_results}->{free}));
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $threshold_value = $self->{result_values}->{prct_used};
          $threshold_value = $self->{result_values}->{prct_free} if (defined($self->{instance_mode}->{option_results}->{free}));
      }
      $exit = $self->{perfdata}->threshold_check(value => $threshold_value, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' } ]);
      return $exit;
  }
  
  sub custom_usage_output {
      my ($self, %options) = @_;
      
      my $msg;
      if ($self->{result_values}->{total} == 0) {
          $msg = 'skipping: total size is 0';
      } elsif ($self->{result_values}->{total} < 0) {
          $msg = 'skipping: negative total value (maybe use snmp v2c)';
      } else {
          my ($total_size_value, $total_size_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{total});
          my ($total_used_value, $total_used_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{used});
          my ($total_free_value, $total_free_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{free});
          $msg = sprintf("Total: %s Used: %s (%.2f%%) Free: %s (%.2f%%)",
                     $total_size_value . " " . $total_size_unit,
                     $total_used_value . " " . $total_used_unit, $self->{result_values}->{prct_used},
                     $total_free_value . " " . $total_free_unit, $self->{result_values}->{prct_free});
      }
      return $msg;
  }
  
  sub custom_usage_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};    
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_total'};
      $self->{result_values}->{used} = $options{new_datas}->{$self->{instance} . '_used'};
  
      return 0 if ($options{new_datas}->{$self->{instance} . '_total'} == 0);
      $self->{result_values}->{prct_used} = $self->{result_values}->{used} * 100 / $self->{result_values}->{total};
  
      $self->{result_values}->{free} = $self->{result_values}->{total} - $self->{result_values}->{used};
      $self->{result_values}->{prct_free} = 100 - $self->{result_values}->{prct_used};
      # snapshot can be over 100%
      if ($self->{result_values}->{free} < 0) {
          $self->{result_values}->{free} = 0;
          $self->{result_values}->{prct_free} = 0;
      }
      
      return 0;
  }
  
  sub prefix_fs_output {
      my ($self, %options) = @_;
      
      return "Filesys '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'units:s'           => { name => 'units', default => '%' },
          'free'              => { name => 'free' },
          'filter-name:s'     => { name => 'filter_name' },
          'filter-type:s'     => { name => 'filter_type' },
          'filter-vserver:s'  => { name => 'filter_vserver' },
      });
  
      return $self;
  }
  
  my %map_types = (
      1 => 'traditionalVolume',
      2 => 'flexibleVolume',
      3 => 'aggregate',
      4 => 'stripedAggregate',
      5 => 'stripedVolume'
  );
  my $mapping = {
      dfType      => { oid => '.1.3.6.1.4.1.789.1.5.4.1.23', map => \%map_types },
  };
  my $mapping2 = {
      dfFileSys               => { oid => '.1.3.6.1.4.1.789.1.5.4.1.2' },
      dfKBytesTotal           => { oid => '.1.3.6.1.4.1.789.1.5.4.1.3' },
      dfKBytesUsed            => { oid => '.1.3.6.1.4.1.789.1.5.4.1.4' },
      dfPerCentInodeCapacity  => { oid => '.1.3.6.1.4.1.789.1.5.4.1.9' },
      df64TotalKBytes         => { oid => '.1.3.6.1.4.1.789.1.5.4.1.29' },
      df64UsedKBytes          => { oid => '.1.3.6.1.4.1.789.1.5.4.1.30' },
      dfVserver               => { oid => '.1.3.6.1.4.1.789.1.5.4.1.34' },
      dfCompressSavedPercent  => { oid => '.1.3.6.1.4.1.789.1.5.4.1.38' },
      dfDedupeSavedPercent    => { oid => '.1.3.6.1.4.1.789.1.5.4.1.40' },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my @oids = (
          $mapping2->{dfKBytesTotal}->{oid},
          $mapping2->{dfKBytesUsed}->{oid},
          $mapping2->{dfPerCentInodeCapacity}->{oid},
          $mapping2->{dfCompressSavedPercent}->{oid},
          $mapping2->{dfDedupeSavedPercent}->{oid},
          $mapping2->{dfVserver}->{oid},
      );
      if (!$options{snmp}->is_snmpv1()) {
          push @oids, $mapping2->{df64TotalKBytes}->{oid};
          push @oids, $mapping2->{df64UsedKBytes}->{oid};
  
      }
  
      my $results;
      if (defined($self->{option_results}->{filter_type}) && $self->{option_results}->{filter_type} ne '') {
          $results = $options{snmp}->get_multiple_table(
              oids => [
                  { oid => $mapping->{dfType}->{oid} }, 
                  { oid => $mapping2->{dfFileSys}->{oid} }
              ],
              return_type => 1,
              nothing_quit => 1
          );
      } else {
          $results = $options{snmp}->get_table(oid => $mapping2->{dfFileSys}->{oid}, nothing_quit => 1);
      }
      my @fs_selected;
      foreach my $oid (keys %{$results}) {
          next if ($oid !~ /^$mapping2->{dfFileSys}->{oid}\.(\d+)/);
          my $instance = $1;
          my $name = $results->{$oid};
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $name !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping  '" . $name . "': no matching filter name.", debug => 1);
              next;
          }
          if (defined($self->{option_results}->{filter_type}) && $self->{option_results}->{filter_type} ne '' &&
              $map_types{$results->{$mapping->{dfType}->{oid} . '.' . $instance}} !~ /$self->{option_results}->{filter_type}/) {
              $self->{output}->output_add(long_msg => "skipping  '" . $name . "': no matching filter type.", debug => 1);
              next;
          }
          push @fs_selected, $instance;
      }
  
      if (scalar(@fs_selected) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No entry found.");
          $self->{output}->option_exit();
      }
  
      $self->{fs} = {};
      $options{snmp}->load(oids => \@oids, instances => \@fs_selected);
      my $snmp_result = $options{snmp}->get_leef(nothing_quit => 1);
      foreach my $instance (sort @fs_selected) {
          my $result2 = $options{snmp}->map_instance(mapping => $mapping2, results => $snmp_result, instance => $instance);
          
          $self->{fs}->{$instance} = {
              display => defined($result2->{dfVserver}) && $result2->{dfVserver} ne '' ? 
                  $result2->{dfVserver} . ':' . $results->{$mapping2->{dfFileSys}->{oid} . '.' . $instance} : 
                  $results->{$mapping2->{dfFileSys}->{oid} . '.' . $instance}
          };
          $self->{fs}->{$instance}->{total} = $result2->{dfKBytesTotal} * 1024;
          $self->{fs}->{$instance}->{used} = $result2->{dfKBytesUsed} * 1024;
          if (defined($result2->{df64TotalKBytes}) && $result2->{df64TotalKBytes} > 0) {
              $self->{fs}->{$instance}->{total} = $result2->{df64TotalKBytes} * 1024;
              $self->{fs}->{$instance}->{used} = $result2->{df64UsedKBytes} * 1024;
          }
          $self->{fs}->{$instance}->{dfCompressSavedPercent} = $result2->{dfCompressSavedPercent};
          $self->{fs}->{$instance}->{dfDedupeSavedPercent} = $result2->{dfDedupeSavedPercent};
          if ($self->{fs}->{$instance}->{total} > 0) {
              $self->{fs}->{$instance}->{dfPerCentInodeCapacity} = $result2->{dfPerCentInodeCapacity};
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check filesystem usage (volumes, snapshots and aggregates also).
  
  =over 8
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: usage, inodes (%), compresssaved (%), dedupsaved (%).
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: usage, inodes (%), compresssaved (%), dedupsaved (%).
  
  =item B<--units>
  
  Units of thresholds (Default: '%') ('%', 'B').
  
  =item B<--free>
  
  Thresholds are on free space left.
  
  =item B<--filter-name>
  
  Filter by filesystem name (can be a regexp).
  
  =item B<--filter-vserver>
  
  Filter by vserver name (can be a regexp).
  
  =item B<--filter-type>
  
  Filter filesystem type (can be a regexp. Example: 'flexibleVolume|aggregate').
  
  =back
  
  =cut
STORAGE_NETAPP_SNMP_MODE_FILESYS

$fatpacked{"storage/netapp/snmp/mode/globalstatus.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_GLOBALSTATUS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::globalstatus;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'read', nlabel => 'storage.io.read.usage.bytespersecond', set => {
                  key_values => [ { name => 'read', diff => 1 } ],
                  per_second => 1,
                  output_template => 'Read I/O : %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { value => 'read_per_second', template => '%d',
                        unit => 'B/s', min => 0 },
                  ],
              }
          },
          { label => 'write', nlabel => 'storage.io.write.usage.bytespersecond', set => {
                  key_values => [ { name => 'write', diff => 1 } ],
                  per_second => 1,
                  output_template => 'Write I/O : %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { value => 'write_per_second', template => '%d',
                        unit => 'B/s', min => 0 },
                  ],
              }
          },
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  my %states = (
      1 => ['other', 'WARNING'], 
      2 => ['unknown', 'UNKNOWN'], 
      3 => ['ok', 'OK'], 
      4 => ['non critical', 'WARNING'],
      5 => ['critical', 'CRITICAL'],
      6 => ['nonRecoverable', 'WARNING'],
  );
  my %fs_states = (
      1 => ['ok', 'OK'], 
      2 => ['nearly full', 'WARNING'], 
      3 => ['full', 'CRITICAL'], 
  );
  
  my $oid_fsOverallStatus = '.1.3.6.1.4.1.789.1.5.7.1.0';
  my $oid_fsStatusMessage = '.1.3.6.1.4.1.789.1.5.7.2.0';
  my $oid_miscGlobalStatus = '.1.3.6.1.4.1.789.1.2.2.4.0';
  my $oid_miscGlobalStatusMessage = '.1.3.6.1.4.1.789.1.2.2.25.0';
  my $oid_misc64DiskReadBytes = '.1.3.6.1.4.1.789.1.2.2.32.0';
  my $oid_misc64DiskWriteBytes = '.1.3.6.1.4.1.789.1.2.2.33.0';
  my $oid_miscHighDiskReadBytes = '.1.3.6.1.4.1.789.1.2.2.15.0';
  my $oid_miscLowDiskReadBytes = '.1.3.6.1.4.1.789.1.2.2.16.0';
  my $oid_miscHighDiskWriteBytes = '.1.3.6.1.4.1.789.1.2.2.17.0';
  my $oid_miscLowDiskWriteBytes = '.1.3.6.1.4.1.789.1.2.2.18.0';
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my $request = [
          $oid_fsOverallStatus, $oid_fsStatusMessage,
          $oid_miscGlobalStatus, $oid_miscGlobalStatusMessage, 
          $oid_miscHighDiskReadBytes, $oid_miscLowDiskReadBytes,
          $oid_miscHighDiskWriteBytes, $oid_miscLowDiskWriteBytes
      ];
      if (!$options{snmp}->is_snmpv1()) {
          push @{$request}, ($oid_misc64DiskReadBytes, $oid_misc64DiskWriteBytes);
      }
      
      my $snmp_result = $options{snmp}->get_leef(oids => $request, nothing_quit => 1);
      
      $self->{global} = {};
      $self->{global}->{read} = defined($snmp_result->{$oid_misc64DiskReadBytes}) ?
                                  $snmp_result->{$oid_misc64DiskReadBytes} : 
                                  ($snmp_result->{$oid_miscHighDiskReadBytes} << 32) + $snmp_result->{$oid_miscLowDiskReadBytes};
      $self->{global}->{write} = defined($snmp_result->{$oid_misc64DiskWriteBytes}) ?
                                  $snmp_result->{$oid_misc64DiskWriteBytes} : 
                                  ($snmp_result->{$oid_miscHighDiskWriteBytes} << 32) + $snmp_result->{$oid_miscLowDiskWriteBytes};
  
      $snmp_result->{$oid_miscGlobalStatusMessage} =~ s/\n//g;
      $self->{output}->output_add(severity =>  ${$states{$snmp_result->{$oid_miscGlobalStatus}}}[1],
                                  short_msg => sprintf("Overall global status is '%s' [message: '%s']", 
                                                  ${$states{$snmp_result->{$oid_miscGlobalStatus}}}[0], $snmp_result->{$oid_miscGlobalStatusMessage}));
      $snmp_result->{$oid_fsStatusMessage} =~ s/\n//g;
      $self->{output}->output_add(severity =>  ${$fs_states{$snmp_result->{$oid_fsOverallStatus}}}[1],
                                  short_msg => sprintf("Overall file system status is '%s' [message: '%s']", 
                                                  ${$fs_states{$snmp_result->{$oid_fsOverallStatus}}}[0], $snmp_result->{$oid_fsStatusMessage}));
  
      $self->{cache_name} = "cache_netapp_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Check the overall status of the appliance and some metrics (total read bytes per seconds and total write bytes per seconds).
  If you are in cluster mode, the following mode doesn't work. Ask to netapp to add it :)
  
  =over 8
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'read', 'write'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'read', 'write'.
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_GLOBALSTATUS

$fatpacked{"storage/netapp/snmp/mode/listfilesys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_LISTFILESYS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::listfilesys;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'filter-name:s'     => { name => 'filter_name' },
          'filter-type:s'     => { name => 'filter_type' },
          'skip-total-zero'   => { name => 'skip_total_zero' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  my %map_types = (
      1 => 'traditionalVolume',
      2 => 'flexibleVolume',
      3 => 'aggregate',
      4 => 'stripedAggregate',
      5 => 'stripedVolume'
  );
  
  my $mapping = {
      dfFileSys       => { oid => '.1.3.6.1.4.1.789.1.5.4.1.2' },
      dfKBytesTotal   => { oid => '.1.3.6.1.4.1.789.1.5.4.1.3' },
      dfType          => { oid => '.1.3.6.1.4.1.789.1.5.4.1.23', map => \%map_types },
      df64TotalKBytes => { oid => '.1.3.6.1.4.1.789.1.5.4.1.29' },
      dfVserver       => { oid => '.1.3.6.1.4.1.789.1.5.4.1.34' },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $snmp_result = $options{snmp}->get_multiple_table(
          oids => [ 
              { oid => $mapping->{dfFileSys}->{oid} },
              { oid => $mapping->{dfKBytesTotal}->{oid} },
              { oid => $mapping->{dfType}->{oid} },
              { oid => $mapping->{df64TotalKBytes}->{oid} },
              { oid => $mapping->{dfVserver}->{oid} },
          ],
          return_type => 1,
          nothing_quit => 1
      );
  
      $self->{fs} = {};
      foreach my $oid (keys %$snmp_result) {
          next if ($oid !~ /^$mapping->{dfFileSys}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $instance);
  
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $result->{dfFileSys} !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $result->{dfFileSys} . "': no matching filter.", debug => 1);
              next;
          }
          if (defined($self->{option_results}->{filter_type}) && $self->{option_results}->{filter_type} ne '' &&
              $result->{dfType} !~ /$self->{option_results}->{filter_type}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $result->{dfFileSys} . "': no matching filter.", debug => 1);
              next;
          }
  
          $self->{fs}->{$instance} = {
              name => $result->{dfFileSys},
              total => defined($result->{df64TotalKBytes}) ? $result->{df64TotalKBytes} * 1024 : $result->{dfKBytesTotal} * 1024,
              type => $result->{dfType},
              vserver => $result->{dfVserver}
          };
      }
  }
  
  sub run {
      my ($self, %options) = @_;
  
      $self->manage_selection(%options);
      foreach my $instance (sort keys %{$self->{fs}}) {
          next if (defined($self->{option_results}->{skip_total_zero}) && $self->{fs}->{$instance}->{total} == 0);
          
          $self->{output}->output_add(long_msg => '[instance = ' . $instance . '] ' . 
              "[name = '" . $self->{fs}->{$instance}->{name} . "'] " .
              "[type = '" . $self->{fs}->{$instance}->{type} . "'] " .
              "[vserver = '" . $self->{fs}->{$instance}->{vserver} . "'] " .
              "[total = '" . $self->{fs}->{$instance}->{total} . "']");
      }
      
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'List filesys:');
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
      
      $self->{output}->add_disco_format(elements => ['name', 'total', 'type', 'vserver']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      $self->manage_selection(%options);
      foreach my $instance (sort keys %{$self->{fs}}) {
          next if (defined($self->{option_results}->{skip_total_zero}) && $self->{fs}->{$instance}->{total} == 0);
  
          $self->{output}->add_disco_entry(%{$self->{fs}->{$instance}});
      }
  }
  
  1;
  
  
  =head1 MODE
  
  List filesystems (volumes and aggregates also).
  
  =over 8
  
  =item B<--filter-name>
  
  Filter the filesystem name.
  
  =item B<--filter-type>
  
  Filter filesystem type (a regexp. Example: 'flexibleVolume|aggregate').
  
  =item B<--skip-total-zero>
  
  Don't display filesys with total equals 0.
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_LISTFILESYS

$fatpacked{"storage/netapp/snmp/mode/listsnapvault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_LISTSNAPVAULT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::listsnapvault;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  my $map_status = {
      1 => 'idle', 2 => 'transferring', 3 => 'pending',
      4 => 'aborting', 6 => 'quiescing', 7 => 'resyncing',
      12 => 'paused',
  };
  my $map_state = {
      1 => 'uninitialized', 2 => 'snapvaulted',
      3 => 'brokenOff', 4 => 'quiesced',
      5 => 'source', 6 => 'unknown', 7 => 'restoring',
  };
  
  my $oid_snapvaultStatusTable = '.1.3.6.1.4.1.789.1.19.11';
  my $mapping = {
      svSrc       => { oid => '.1.3.6.1.4.1.789.1.19.11.1.2' }, 
      svDst       => { oid => '.1.3.6.1.4.1.789.1.19.11.1.3' }, 
      svStatus    => { oid => '.1.3.6.1.4.1.789.1.19.11.1.4', map => $map_status }, 
      svState     => { oid => '.1.3.6.1.4.1.789.1.19.11.1.5', map => $map_state },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $snmp_result = $options{snmp}->get_table(
          oid => $oid_snapvaultStatusTable, start => $mapping->{svSrc}->{oid}, end => $mapping->{svState}->{oid},
          nothing_quit => 1
      );
      
      $self->{snapvault} = {};
      foreach my $oid (keys %{$snmp_result}) {
          next if ($oid !~ /^$mapping->{svSrc}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $instance);
          
          $self->{snapvault}->{$instance} = { %$result };
      }
  }
  
  sub run {
      my ($self, %options) = @_;
    
      $self->manage_selection(%options);
      foreach my $instance (sort keys %{$self->{snapvault}}) { 
          $self->{output}->output_add(long_msg => '[src = ' . $self->{snapvault}->{$instance}->{svSrc} . 
              '] [dst = ' . $self->{snapvault}->{$instance}->{svDst} . 
              '] [status = ' . $self->{snapvault}->{$instance}->{svStatus} . 
              '] [state = ' . $self->{snapvault}->{$instance}->{svState} . ']'
          );
      }
      
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'List snapvaults:');
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
      
      $self->{output}->add_disco_format(elements => ['src', 'dst', 'status', 'state']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      $self->manage_selection(%options);
      foreach my $instance (sort keys %{$self->{snapvault}}) {             
          $self->{output}->add_disco_entry(
              src => $self->{snapvault}->{$instance}->{svSrc},
              dst => $self->{snapvault}->{$instance}->{svDst},
              status => $self->{snapvault}->{$instance}->{svStatus},
              state => $self->{snapvault}->{$instance}->{svState}
          );
      }
  }
  
  1;
  
  
  =head1 MODE
  
  List snapvaults.
  
  =over 8
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_LISTSNAPVAULT

$fatpacked{"storage/netapp/snmp/mode/ndmpsessions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_NDMPSESSIONS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::ndmpsessions;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                    "warning:s"            => { name => 'warning' },
                                    "critical:s"           => { name => 'critical' },
                                  });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (($self->{perfdata}->threshold_validate(label => 'warning', value => $self->{option_results}->{warning})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong warning threshold '" . $self->{option_results}->{warning} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'critical', value => $self->{option_results}->{critical})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong critical threshold '" . $self->{option_results}->{critical} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_ndmpSessionOpened = '.1.3.6.1.4.1.789.1.10.2.0';
      my $result = $self->{snmp}->get_leef(oids => [$oid_ndmpSessionOpened], nothing_quit => 1);
      
      my $exit = $self->{perfdata}->threshold_check(value => $result->{$oid_ndmpSessionOpened}, threshold => [ { label => 'critical', 'exit_litteral' => 'critical' }, { label => 'warning', exit_litteral => 'warning' } ]);
      $self->{output}->output_add(severity => $exit,
                                  short_msg => sprintf("Current number of ndmp sessions opened: %d", $result->{$oid_ndmpSessionOpened}));
      $self->{output}->perfdata_add(label => 'sessions',
                                    value => $result->{$oid_ndmpSessionOpened},
                                    warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning'),
                                    critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical'),
                                    min => 0);
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check current total of ndmp sessions opened.
  
  =over 8
  
  =item B<--warning>
  
  Threshold warning.
  
  =item B<--critical>
  
  Threshold critical.
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_NDMPSESSIONS

$fatpacked{"storage/netapp/snmp/mode/nvram.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_NVRAM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::nvram;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my %mapping_nvram_state = (
      1 => 'ok',
      2 => 'partiallyDischarged',
      3 => 'fullyDischarged',
      4 => 'notPresent',
      5 => 'nearEndOfLife',
      6 => 'atEndOfLife',
      7 => 'unknown',
      8 => 'overCharged',
      9 => 'fullyCharged',
  );
  
  my $thresholds = {
      nvram => [
          ['ok', 'OK'],
          ['partiallyDischarged', 'WARNING'],
          ['fullyDischarged', 'CRITICAL'],
          ['notPresent', 'CRITICAL'],
          ['nearEndOfLife', 'WARNING'],
          ['atEndOfLife', 'CRITICAL'],
          ['unknown', 'UNKNOWN'],
          ['overCharged', 'OK'],
          ['fullyCharged', 'OK'],
      ],
  };
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                    "threshold-overload:s@"   => { name => 'threshold_overload' },
                                  });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      $self->{overload_th} = {};
      foreach my $val (@{$self->{option_results}->{threshold_overload}}) {
          if ($val !~ /^(.*?),(.*?),(.*)$/) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload option '" . $val . "'.");
              $self->{output}->option_exit();
          }
          my ($section, $status, $filter) = ($1, $2, $3);
          if ($self->{output}->is_litteral_status(status => $status) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload status '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->{overload_th}->{$section} = [] if (!defined($self->{overload_th}->{$section}));
          push @{$self->{overload_th}->{$section}}, {filter => $filter, status => $status};
      }
  }
  
  my $mapping = {
      nvramBatteryStatus => { oid => '.1.3.6.1.4.1.789.1.2.5.1', map => \%mapping_nvram_state },  
  };
  my $mapping2 = {
      nodeNvramBatteryStatus => { oid => '.1.3.6.1.4.1.789.1.25.2.1.17', map => \%mapping_nvram_state },  
  };
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_nodeName = '.1.3.6.1.4.1.789.1.25.2.1.1';
      my $results = $self->{snmp}->get_multiple_table(oids => [
                                                              { oid => $mapping->{nvramBatteryStatus}->{oid} },
                                                              { oid => $oid_nodeName },
                                                              { oid => $mapping2->{nodeNvramBatteryStatus}->{oid} },
                                                              ], nothing_quit => 1);
      
      if (defined($results->{$mapping->{nvramBatteryStatus}->{oid}}->{$mapping->{nvramBatteryStatus}->{oid} . '.0'})) {
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $results->{$mapping->{nvramBatteryStatus}->{oid}}, instance => '0');
          my $exit = $self->get_severity(section => 'nvram', value => $result->{nvramBatteryStatus});
          $self->{output}->output_add(severity => $exit,
                                      short_msg => sprintf("NVRAM Batteries status is '%s'", $result->{nvramBatteryStatus}));
      } else {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'NVRAM Batteries status are ok on all nodes');
          foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$results->{$mapping2->{nodeNvramBatteryStatus}->{oid}}})) {
              $oid =~ /^$mapping2->{nodeNvramBatteryStatus}->{oid}\.(.*)$/;
              my $instance = $1;
              my $name = $results->{$oid_nodeName}->{$oid_nodeName . '.' . $instance};
              my $result = $self->{snmp}->map_instance(mapping => $mapping2, results => $results->{$mapping2->{nodeNvramBatteryStatus}->{oid}}, instance => $instance);
              
              my $exit = $self->get_severity(section => 'nvram', value => $result->{nodeNvramBatteryStatus});
              $self->{output}->output_add(long_msg => sprintf("NVRAM Batteries status is '%s' on node '%s'", 
                                                              $result->{nodeNvramBatteryStatus}, $name));
              if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("NVRAM Batteries status is '%s' on node '%s'", 
                                                              $result->{nodeNvramBatteryStatus}, $name));
              }
          }
      }
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub get_severity {
      my ($self, %options) = @_;
      my $status = 'UNKNOWN'; # default 
      
      if (defined($self->{overload_th}->{$options{section}})) {
          foreach (@{$self->{overload_th}->{$options{section}}}) {            
              if ($options{value} =~ /$_->{filter}/i) {
                  $status = $_->{status};
                  return $status;
              }
          }
      }
      foreach (@{$thresholds->{$options{section}}}) {           
          if ($options{value} =~ /$$_[0]/i) {
              $status = $$_[1];
              return $status;
          }
      }
      
      return $status;
  }
  
  1;
  
  
  =head1 MODE
  
  Check current status of the NVRAM batteries.
  
  =over 8
  
  =item B<--threshold-overload>
  
  Set to overload default threshold values (syntax: section,status,regexp)
  It used before default thresholds (order stays).
  Example: --threshold-overload='nvram,CRITICAL,^(?!(ok)$)'
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_NVRAM

$fatpacked{"storage/netapp/snmp/mode/partnerstatus.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_PARTNERSTATUS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::partnerstatus;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my %mapping_partner_status = (
      1 => 'maybeDown',
      2 => 'ok',
      3 => 'dead',
  );
  my %mapping_interconnect_status = (
      1 => 'notPresent',
      2 => 'down',
      3 => 'partialFailure',
      4 => 'up',
  );
  my $thresholds = {
      partner => [
          ['maybeDown', 'WARNING'],
          ['ok', 'OK'],
          ['dead', 'CRITICAL'],
      ],
      interconnect => [
          ['notPresent', 'CRITICAL'],
          ['down', 'CRITICAL'],
          ['partialFailure', 'WARNING'],
          ['up', 'OK'],
      ],
  };
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                    "threshold-overload:s@"   => { name => 'threshold_overload' },
                                  });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      $self->{overload_th} = {};
      foreach my $val (@{$self->{option_results}->{threshold_overload}}) {
          if ($val !~ /^(.*?),(.*?),(.*)$/) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload option '" . $val . "'.");
              $self->{output}->option_exit();
          }
          my ($section, $status, $filter) = ($1, $2, $3);
          if ($self->{output}->is_litteral_status(status => $status) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload status '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->{overload_th}->{$section} = [] if (!defined($self->{overload_th}->{$section}));
          push @{$self->{overload_th}->{$section}}, {filter => $filter, status => $status};
      }
  }
  
  my $mapping = {
      cfPartnerStatus => { oid => '.1.3.6.1.4.1.789.1.2.3.4', map => \%mapping_partner_status },  
  };
  my $mapping2 = {
      cfInterconnectStatus => { oid => '.1.3.6.1.4.1.789.1.2.3.8', map => \%mapping_interconnect_status },  
  };
  my $mapping3 = {
      haPartnerStatus => { oid => '.1.3.6.1.4.1.789.1.21.2.1.6', map => \%mapping_partner_status },  
  };
  my $mapping4 = {
      haInterconnectStatus => { oid => '.1.3.6.1.4.1.789.1.21.2.1.10', map => \%mapping_interconnect_status },  
  };
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_cfPartnerName = '.1.3.6.1.4.1.789.1.2.3.6';
      my $oid_haNodeName = '.1.3.6.1.4.1.789.1.21.2.1.1';
      my $results = $self->{snmp}->get_multiple_table(oids => [
                                                              { oid => $oid_cfPartnerName },
                                                              { oid => $mapping->{cfPartnerStatus}->{oid} },
                                                              { oid => $mapping2->{cfInterconnectStatus}->{oid} },
                                                              { oid => $oid_haNodeName },
                                                              { oid => $mapping3->{haPartnerStatus}->{oid} },
                                                              { oid => $mapping4->{haInterconnectStatus}->{oid} },
                                                              ], nothing_quit => 1);
      
      if (defined($results->{$mapping->{cfPartnerStatus}->{oid}}->{$mapping->{cfPartnerStatus}->{oid} . '.0'})) {
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $results->{$mapping->{cfPartnerStatus}->{oid}}, instance => '0');
          my $exit = $self->get_severity(section => 'partner', value => $result->{cfPartnerStatus});
          $self->{output}->output_add(severity => $exit,
                                      short_msg => sprintf("Partner '%s' status is '%s'", $results->{$oid_cfPartnerName}->{$oid_cfPartnerName . '.0'}, $result->{cfPartnerStatus}));
          $result = $self->{snmp}->map_instance(mapping => $mapping2, results => $results->{$mapping2->{cfInterconnectStatus}->{oid}}, instance => '0');
          $exit = $self->get_severity(section => 'interconnect', value => $result->{cfInterconnectStatus});
          $self->{output}->output_add(severity => $exit,
                                      short_msg => sprintf("Interconnect status is '%s'", $result->{cfInterconnectStatus}));
      } else {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'HA status are ok on all nodes');
          foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$results->{$mapping3->{haPartnerStatus}->{oid}}})) {
              $oid =~ /^$mapping3->{haPartnerStatus}->{oid}\.(.*)$/;
              my $instance = $1;
              my $name = $results->{$oid_haNodeName}->{$oid_haNodeName . '.' . $instance};
              my $result = $self->{snmp}->map_instance(mapping => $mapping3, results => $results->{$mapping3->{haPartnerStatus}->{oid}}, instance => $instance);
              
              my $exit = $self->get_severity(section => 'partner', value => $result->{haPartnerStatus});
              $self->{output}->output_add(long_msg => sprintf("Partner status of node '%s' is '%s'", 
                                                              $name, $result->{haPartnerStatus}));
              if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Partner status of node '%s' is '%s'", 
                                                              $name, $result->{haPartnerStatus}));
              }
              
              $result = $self->{snmp}->map_instance(mapping => $mapping4, results => $results->{$mapping4->{haInterconnectStatus}->{oid}}, instance => $instance);
              $exit = $self->get_severity(section => 'interconnect', value => $result->{haInterconnectStatus});
              $self->{output}->output_add(long_msg => sprintf("Interconnect status on node '%s' is '%s'", 
                                                              $name, $result->{haInterconnectStatus}));
              if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Interconnect status on node '%s' is '%s'", 
                                                              $name, $result->{haInterconnectStatus}));
              }
          }
      }
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub get_severity {
      my ($self, %options) = @_;
      my $status = 'UNKNOWN'; # default 
      
      if (defined($self->{overload_th}->{$options{section}})) {
          foreach (@{$self->{overload_th}->{$options{section}}}) {            
              if ($options{value} =~ /$_->{filter}/i) {
                  $status = $_->{status};
                  return $status;
              }
          }
      }
      foreach (@{$thresholds->{$options{section}}}) {           
          if ($options{value} =~ /$$_[0]/i) {
              $status = $$_[1];
              return $status;
          }
      }
      
      return $status;
  }
  
  
  1;
  
  
  =head1 MODE
  
  Check status of clustered failover partner.
  
  =over 8
  
  =item B<--threshold-overload>
  
  Set to overload default threshold values (syntax: section,status,regexp)
  It used before default thresholds (order stays).
  Example: --threshold-overload='partner,CRITICAL,^(?!(ok)$)'
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_PARTNERSTATUS

$fatpacked{"storage/netapp/snmp/mode/psu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_PSU';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::psu;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                  });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_envFailedPowerSupplyCount = '.1.3.6.1.4.1.789.1.2.4.4';
      my $oid_envFailedPowerSupplyMessage = '.1.3.6.1.4.1.789.1.2.4.5';
      my $oid_nodeName = '.1.3.6.1.4.1.789.1.25.2.1.1';
      my $oid_nodeEnvFailedPowerSupplyCount = '.1.3.6.1.4.1.789.1.25.2.1.21';
      my $oid_nodeEnvFailedPowerSupplyMessage = '.1.3.6.1.4.1.789.1.25.2.1.22';
      my $results = $self->{snmp}->get_multiple_table(oids => [
                                                              { oid => $oid_envFailedPowerSupplyCount }, 
                                                              { oid => $oid_envFailedPowerSupplyMessage },
                                                              { oid => $oid_nodeName },
                                                              { oid => $oid_nodeEnvFailedPowerSupplyCount },
                                                              { oid => $oid_nodeEnvFailedPowerSupplyMessage }
                                                              ], nothing_quit => 1);
      
      if (defined($results->{$oid_envFailedPowerSupplyCount}->{$oid_envFailedPowerSupplyCount . '.0'})) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'Power supplies are ok.');
          if ($results->{$oid_envFailedPowerSupplyCount}->{$oid_envFailedPowerSupplyCount . '.0'} != 0) {
              $self->{output}->output_add(severity => 'CRITICAL',
                                          short_msg => sprintf("'%d' power supplies are failed [message: %s].", 
                                                          $results->{$oid_envFailedPowerSupplyCount}->{$oid_envFailedPowerSupplyCount . '.0'},
                                                          $results->{$oid_envFailedPowerSupplyMessage}->{$oid_envFailedPowerSupplyMessage . '.0'}));
          }
      } else {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'Power supplies are ok on all nodes');
          foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$results->{$oid_nodeEnvFailedPowerSupplyCount}})) {
              $oid =~ /^$oid_nodeEnvFailedPowerSupplyCount\.(.*)$/;
              my $instance = $1;
              my $name = $results->{$oid_nodeName}->{$oid_nodeName . '.' . $instance};
              my $count = $results->{$oid_nodeEnvFailedPowerSupplyCount}->{$oid};
              my $message = $results->{$oid_nodeEnvFailedPowerSupplyMessage}->{$oid_nodeEnvFailedPowerSupplyMessage . '.' . $instance};
              $self->{output}->output_add(long_msg => sprintf("'%d' power supplies are failed on node '%s' [message: %s]", 
                                                              $count, $name, defined($message) ? $message : '-'));
              if ($count != 0) {
                  $self->{output}->output_add(severity => 'CRITICAL',
                                          short_msg => sprintf("'%d' power supplies are failed on node '%s' [message: %s]", 
                                                          $count, $name, defined($message) ? $message : '-'));
              }
          }
      }
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check if power supplies are failed (in degraded mode).
  
  =over 8
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_PSU

$fatpacked{"storage/netapp/snmp/mode/qtreeusage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_QTREEUSAGE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::qtreeusage;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'qtree', type => 1, cb_prefix_output => 'prefix_qtree_output', message_multiple => 'All qtree usages are ok.' },
      ];
      
      $self->{maps_counters}->{qtree} = [
          { label => 'usage', set => {
                  key_values => [ { name => 'name' }, { name => 'used' }, { name => 'total' } ],
                  closure_custom_calc => $self->can('custom_usage_calc'),
                  closure_custom_output => $self->can('custom_usage_output'),
                  closure_custom_perfdata => $self->can('custom_usage_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_usage_threshold'),
              }
          },
      ];
  }
  
  sub custom_usage_perfdata {
      my ($self, %options) = @_;
      
      my $label = 'used';
      my $value_perf = $self->{result_values}->{used};
      if ($self->{result_values}->{total} > 0 && defined($self->{instance_mode}->{option_results}->{free})) {
          $label = 'free';
          $value_perf = $self->{result_values}->{free};
      }
  
      my %total_options = ();
      if ($self->{result_values}->{total} > 0 && $self->{instance_mode}->{option_results}->{units} eq '%') {
          $total_options{total} = $self->{result_values}->{total};
          $total_options{cast_int} = 1;
      }
  
      $self->{output}->perfdata_add(
          label => $label, unit => 'B',
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{name} : undef,
          value => $value_perf,
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}, %total_options),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}, %total_options),
          min => 0, max => $self->{result_values}->{total}
      );
  }
  
  sub custom_usage_threshold {
      my ($self, %options) = @_;
      
      # cannot use '%' or free option with unlimited system 
      return 'ok' if ($self->{result_values}->{total} <= 0 && ($self->{instance_mode}->{option_results}->{units} eq '%' || $self->{instance_mode}->{option_results}->{free}));
      my ($exit, $threshold_value);
      $threshold_value = $self->{result_values}->{used};
      $threshold_value = $self->{result_values}->{free} if (defined($self->{instance_mode}->{option_results}->{free}));
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $threshold_value = $self->{result_values}->{prct_used};
          $threshold_value = $self->{result_values}->{prct_free} if (defined($self->{instance_mode}->{option_results}->{free}));
      }
      $exit = $self->{perfdata}->threshold_check(value => $threshold_value, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' } ]);
      return $exit;
  }
  
  sub custom_usage_output {
      my ($self, %options) = @_;
  
      my ($total_used_value, $total_used_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{used});    
      my $msg;
      if ($self->{result_values}->{total} <= 0) {
          $msg = sprintf("Used: %s (unlimited)", $total_used_value . " " . $total_used_unit);
      } else {
          my ($total_size_value, $total_size_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{total});
          my ($total_free_value, $total_free_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{free});
          $msg = sprintf("Total: %s Used: %s (%.2f%%) Free: %s (%.2f%%)",
                     $total_size_value . " " . $total_size_unit,
                     $total_used_value . " " . $total_used_unit, $self->{result_values}->{prct_used},
                     $total_free_value . " " . $total_free_unit, $self->{result_values}->{prct_free});
      }
      return $msg;
  }
  
  sub custom_usage_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{name} = $options{new_datas}->{$self->{instance} . '_name'};
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_total'};
      $self->{result_values}->{used} = $options{new_datas}->{$self->{instance} . '_used'};
      
      return 0 if ($self->{result_values}->{total} == 0);
      $self->{result_values}->{prct_used} = $self->{result_values}->{used} * 100 / $self->{result_values}->{total};
      $self->{result_values}->{prct_free} = 100 - $self->{result_values}->{prct_used};
      $self->{result_values}->{free} = $self->{result_values}->{total} - $self->{result_values}->{used};
      # qtree can be over 100%
      if ($self->{result_values}->{free} < 0) {
          $self->{result_values}->{free} = 0;
          $self->{result_values}->{prct_free} = 0;
      }
      
      return 0;
  }
  
  sub prefix_qtree_output {
      my ($self, %options) = @_;
      
      return "Qtree '" . $options{instance_value}->{name} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "units:s"               => { name => 'units', default => '%' },
          "free"                  => { name => 'free' },
          "filter-vserver:s"      => { name => 'filter_vserver' },
          "filter-volume:s"       => { name => 'filter_volume' },
          "filter-qtree:s"        => { name => 'filter_qtree' },
          "not-kbytes"            => { name => 'not_kbytes' },
      });
  
      return $self;
  }
  
  my $mapping = {
      qrV2Tree            => { oid => '.1.3.6.1.4.1.789.1.4.6.1.14' },
      qrV264KBytesUsed    => { oid => '.1.3.6.1.4.1.789.1.4.6.1.25' },
      qrV264KBytesLimit   => { oid => '.1.3.6.1.4.1.789.1.4.6.1.26' },
      qrV2VolumeName      => { oid => '.1.3.6.1.4.1.789.1.4.6.1.29' },
      qrV2Vserver         => { oid => '.1.3.6.1.4.1.789.1.4.6.1.30' },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my $multi = 1;
      $multi = 1024 unless defined($self->{option_results}->{not_kbytes});
  
      if ($options{snmp}->is_snmpv1()) {
          $self->{output}->add_option_msg(short_msg => "Need to use SNMP v2c or v3.");
          $self->{output}->option_exit();
      }
      my $results = $options{snmp}->get_multiple_table(oids => [
                                                         { oid => $mapping->{qrV2Tree}->{oid} },
                                                         { oid => $mapping->{qrV264KBytesUsed}->{oid} },
                                                         { oid => $mapping->{qrV264KBytesLimit}->{oid} },
                                                         { oid => $mapping->{qrV2VolumeName}->{oid} },
                                                         { oid => $mapping->{qrV2Vserver}->{oid} },
                                                      ], return_type => 1, nothing_quit => 1);
      $self->{qtree} = {};
      foreach my $oid (keys %{$results}) {
          next if ($oid !~ /^$mapping->{qrV2Tree}->{oid}\.(.*)/);
          my $instance = $1;
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $results, instance => $instance);
  
          if (defined($self->{option_results}->{filter_vserver}) && $self->{option_results}->{filter_vserver} ne '' &&
              defined($result->{qrV2Vserver}) && $result->{qrV2Vserver} ne '' && $result->{qrV2Vserver} !~ /$self->{option_results}->{filter_vserver}/) {
              $self->{output}->output_add(long_msg => "Skipping '" . $result->{qrV2Vserver} . "': no matching vserver name.", debug => 1);
              next;
          }
          if (defined($self->{option_results}->{filter_volume}) && $self->{option_results}->{filter_volume} ne '' &&
              defined($result->{qrV2VolumeName}) && $result->{qrV2VolumeName} ne '' && $result->{qrV2VolumeName} !~ /$self->{option_results}->{filter_volume}/) {
              $self->{output}->output_add(long_msg => "Skipping '" . $result->{qrV2VolumeName} . "': no matching volume name.", debug => 1);
              next;
          }
          if (defined($self->{option_results}->{filter_qtree}) && $self->{option_results}->{filter_qtree} ne '' &&
              $result->{qrV2Tree} !~ /$self->{option_results}->{filter_qtree}/) {
              $self->{output}->output_add(long_msg => "Skipping '" . $result->{qrV2Tree} . "': no matching qtree name.", debug => 1);
              next;
          }        
          if (!defined($result->{qrV264KBytesUsed}) && !defined($result->{qrV264KBytesLimit})) {
              $self->{output}->output_add(long_msg => "Skipping qtree '" . $result->{qrV2Tree} . "': no used or total values.", debug => 1);
              next;
          }
  
          my $name = '';
          $name = $result->{qrV2Vserver} . '/' if (defined($result->{qrV2Vserver}) && $result->{qrV2Vserver} ne ''); 
          $name .= $result->{qrV2VolumeName} . '/' if (defined($result->{qrV2VolumeName}) && $result->{qrV2VolumeName} ne ''); 
          $name .= $result->{qrV2Tree};
          
          $self->{qtree}->{$instance} = { name => $name, used => $result->{qrV264KBytesUsed} * $multi, total => $result->{qrV264KBytesLimit} * $multi }; 
      }
      
      if (scalar(keys %{$self->{qtree}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No entry found.");
          $self->{output}->option_exit();
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check qtree quote usage.
  
  =over 8
  
  =item B<--warning-usage>
  
  Threshold warning.
  
  =item B<--critical-usage>
  
  Threshold critical.
  
  =item B<--units>
  
  Units of thresholds (Default: '%') ('%', 'B').
  
  =item B<--free>
  
  Thresholds are on free space left.
  
  =item B<--filter-vserver>
  
  Filter by vserver name (can be a regexp).
  
  =item B<--filter-volume>
  
  Filter by volume name (can be a regexp).
  
  =item B<--filter-qtree>
  
  Filter by qtree name (can be a regexp).
  
  =item B<--not-kbytes>
  
  If qrV264KBytesUsed and qrV264KBytesLimit OIDs are not really KBytes.
  
  =back
  
  =cut
STORAGE_NETAPP_SNMP_MODE_QTREEUSAGE

$fatpacked{"storage/netapp/snmp/mode/sharecalls.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_SHARECALLS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::sharecalls;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'cifs', nlabel => 'storage.cifs.calls.persecond', set => {
                  key_values => [ { name => 'cifs', diff => 1 }, ],
                  per_second => 1,
                  output_template => 'CIFS : %s calls/s',
                  perfdatas => [
                      { value => 'cifs_per_second', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'nfs', nlabel => 'storage.nfs.calls.persecond', set => {
                  key_values => [ { name => 'nfs', diff => 1 }, ],
                  per_second => 1,
                  output_template => 'NFS : %s calls/s',
                  perfdatas => [
                      { value => 'nfs_per_second', template => '%d', min => 0 },
                  ],
              }
          },
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  my $oid_miscHighNfsOps = '.1.3.6.1.4.1.789.1.2.2.5.0';
  my $oid_miscLowNfsOps = '.1.3.6.1.4.1.789.1.2.2.6.0';
  my $oid_miscHighCifsOps = '.1.3.6.1.4.1.789.1.2.2.7.0';
  my $oid_miscLowCifsOps = '.1.3.6.1.4.1.789.1.2.2.8.0';
  my $oid_misc64NfsOps = '.1.3.6.1.4.1.789.1.2.2.27.0';
  my $oid_misc64CifsOps = '.1.3.6.1.4.1.789.1.2.2.28.0';
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my $request = [
          $oid_miscHighNfsOps, $oid_miscLowNfsOps,
          $oid_miscHighCifsOps, $oid_miscLowCifsOps
      ];
      if (!$options{snmp}->is_snmpv1()) {
          push @{$request}, ($oid_misc64NfsOps, $oid_misc64CifsOps);
      }
      
      my $snmp_result = $options{snmp}->get_leef(oids => $request, nothing_quit => 1);
      
      $self->{global} = {};
      $self->{global}->{cifs} = defined($snmp_result->{$oid_misc64CifsOps}) ?
                                  $snmp_result->{$oid_misc64CifsOps} : 
                                  ($snmp_result->{$oid_miscHighCifsOps} << 32) + $snmp_result->{$oid_miscLowCifsOps};
      $self->{global}->{nfs} = defined($snmp_result->{$oid_misc64NfsOps}) ?
                                  $snmp_result->{$oid_misc64NfsOps} : 
                                  ($snmp_result->{$oid_miscHighNfsOps} << 32) + $snmp_result->{$oid_miscLowNfsOps};
  
      $self->{cache_name} = "cache_netapp_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Check cifs and nfs calls per seconds.
  If you are in cluster mode, the following mode doesn't work. Ask to netapp to add it :)
  
  =over 8
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'cifs', 'nfs'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'cifs', 'nfs'.
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_SHARECALLS

$fatpacked{"storage/netapp/snmp/mode/shelf.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_SHELF';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::shelf;
  
  use base qw(centreon::plugins::templates::hardware);
  
  use strict;
  use warnings;
  
  sub set_system {
      my ($self, %options) = @_;
      
      $self->{regexp_threshold_numeric_check_section_option} = '^(voltage|temperature|fan)$';
      
      $self->{cb_hook1} = 'init_shelf';
      $self->{cb_hook2} = 'snmp_execute';
      
      $self->{thresholds} = {
          communication => [
              ['initializing', 'WARNING'],
              ['transitioning', 'WARNING'],
              ['inactive', 'CRITICAL'],
              ['reconfiguring', 'WARNING'],
              ['nonexistent', 'CRITICAL'],
              ['active', 'OK'],
          ],
          raid => [
              ['initializing', 'WARNING'],
              ['reconstructionInProgress', 'WARNING'],
              ['parityVerificationInProgress', 'OK'],
              ['scrubbingInProgress', 'OK'],
              ['prefailed', 'CRITICAL'],
              ['failed', 'CRITICAL'],
              ['active', 'OK'],
          ],
          fan => [
              ['failed', 'CRITICAL'],
              ['ok', 'OK'],
          ],
          psu => [
              ['failed', 'CRITICAL'],
              ['ok', 'OK'],
          ],
          electronics => [
              ['failed', 'CRITICAL'],
              ['ok', 'OK'],
          ],
          voltage => [
              ['under critical threshold', 'CRITICAL'],
              ['under warning threshold', 'WARNING'],
              ['over critical threshold', 'CRITICAL'],
              ['over warning threshold', 'WARNING'],
              ['ok', 'OK'],
          ],
          temperature => [
              ['under critical threshold', 'CRITICAL'],
              ['under warning threshold', 'WARNING'],
              ['over critical threshold', 'CRITICAL'],
              ['over warning threshold', 'WARNING'],
              ['ok', 'OK'],
          ],
      };
      
      $self->{components_path} = 'storage::netapp::snmp::mode::components';
      $self->{components_module} = ['communication', 'psu', 'fan', 'temperature', 'voltage', 'electronics', 'raid'];
  }
  
  my $oid_enclNumber = '.1.3.6.1.4.1.789.1.21.1.1';
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  
  sub snmp_execute {
      my ($self, %options) = @_;
      
      $self->{snmp} = $options{snmp};
      $self->{results} = $self->{snmp}->get_multiple_table(oids => $self->{request});
      $self->{number_shelf} = defined($self->{results}->{$oid_enclNumber}->{$oid_enclNumber . '.0'}) ? $self->{results}->{$oid_enclNumber}->{$oid_enclNumber . '.0'} : -1;
      $self->{shelf_addr} = $self->{results}->{$oid_enclChannelShelfAddr};
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                  });
  
      return $self;
  }
  
  sub init_shelf {
      my ($self, %options) = @_;
  
      push @{$self->{request}}, ({ oid => $oid_enclNumber }, { oid => $oid_enclChannelShelfAddr });
  }
  
  1;
  
  
  =head1 MODE
  
  Check Shelves hardware (temperatures, voltages, electronics, fan, power supplies).
  
  =over 8
  
  =item B<--component>
  
  Which component to check (Default: '.*').
  Can be: 'psu', 'fan', 'communication', 'voltage', 'temperature', 'electronics', 'raid'.
  
  =item B<--filter>
  
  Exclude some parts (comma seperated list) (Example: --filter=fan --filter=psu)
  Can also exclude specific instance: --filter=psu,41239F00647-A
  
  =item B<--absent-problem>
  
  Return an error if an entity is not 'present' (default is skipping) (comma seperated list)
  Can be specific or global: --absent-problem=fan,41239F00647-fan02
  
  =item B<--no-component>
  
  Return an error if no compenents are checked.
  If total (with skipped) is 0. (Default: 'critical' returns).
  
  =item B<--threshold-overload>
  
  Set to overload default threshold values (syntax: section,[instance,]status,regexp)
  It used before default thresholds (order stays).
  Example: --threshold-overload='gfc,CRITICAL,^(?!(Online)$)'
  
  =item B<--warning>
  
  Set warning threshold for temperature, fan, voltage (syntax: type,regexp,threshold)
  Example: --warning='41239F00647-vimm46,20' --warning='41239F00647-vimm5.*,30'
  
  =item B<--critical>
  
  Set critical threshold for temperature, fan, voltage (syntax: type,regexp,threshold)
  Example: --critical='temperature,.*,25' --warning='temperature,.*,35'
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_SHELF

$fatpacked{"storage/netapp/snmp/mode/sis.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_SIS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::sis;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  use Digest::MD5 qw(md5_hex);
  
  sub custom_status_output { 
      my ($self, %options) = @_;
  
      my $msg = sprintf('status : %s [state: %s] [lastOpError: %s]',
          $self->{result_values}->{status},
          $self->{result_values}->{state},
          $self->{result_values}->{lastOpError},
      );
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_sisStatus'};
      $self->{result_values}->{state} = $options{new_datas}->{$self->{instance} . '_sisState'};
      $self->{result_values}->{lastOpError} = $options{new_datas}->{$self->{instance} . '_sisLastOpError'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'sis', type => 1, cb_prefix_output => 'prefix_sis_output', message_multiple => 'All single instance storages are ok', skipped_code => { -10 => 1, -11 => 1 } }
      ];
  
      $self->{maps_counters}->{sis} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'sisStatus' }, { name => 'sisState' }, { name => 'sisLastOpError' }, { name => 'display' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
  }
  
  sub prefix_sis_output {
      my ($self, %options) = @_;
  
      return "Single instance storage '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
          'filter-name:s'     => { name => 'filter_name' },
          'unknown-status:s'  => { name => 'unknown_status', default => '' },
          'warning-status:s'  => { name => 'warning_status', default => '' },
          'critical-status:s' => { name => 'critical_status', default => '%{state} eq "enabled" and %{lastOpError} !~ /-|Success/i' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => ['warning_status', 'critical_status', 'unknown_status']);
  }
  
  my $map_status = {
      1 => 'idle', 2 => 'active', 3 => 'undoing',
      4 => 'pending', 5 => 'initializing',
      6 => 'downgrading', 7 => 'disabled',
  };
  
  my $map_state = { 1 => 'disabled', 2 => 'enabled' };
  
  my $mapping = {
      sisState        => { oid => '.1.3.6.1.4.1.789.1.23.2.1.3', map => $map_state }, 
      sisStatus       => { oid => '.1.3.6.1.4.1.789.1.23.2.1.4', map => $map_status },
      sisLastOpError  => { oid => '.1.3.6.1.4.1.789.1.23.2.1.12' },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my $oid_sisIsLicensed = '.1.3.6.1.4.1.789.1.23.1.0';
      my $snmp_result = $options{snmp}->get_leef(oids => [$oid_sisIsLicensed]);
      if (!defined($snmp_result->{$oid_sisIsLicensed}) || $snmp_result->{$oid_sisIsLicensed} != 2) {
          $self->{output}->add_option_msg(short_msg => 'single instance storage is not licensed');
          $self->{output}->option_exit();
      }
      
      my $oid_sisPath = '.1.3.6.1.4.1.789.1.23.2.1.2';
      my $oid_sisVserver = '.1.3.6.1.4.1.789.1.23.2.1.16';
      
      $self->{snapvault} = {};
      $snmp_result = $options{snmp}->get_multiple_table(oids => [ { oid => $oid_sisPath }, { oid => $oid_sisVserver }], return_type => 1, nothing_quit => 1);
      foreach my $oid (keys %{$snmp_result}) {
          next if ($oid !~ /^$oid_sisPath\.(.*)$/);
          my $instance = $1;
          my $name = defined($snmp_result->{$oid_sisVserver . '.' . $instance}) && $snmp_result->{$oid_sisVserver . '.' . $instance} ne '' ?
              $snmp_result->{$oid_sisVserver . '.' . $instance} . ':' . $snmp_result->{$oid} :
              $snmp_result->{$oid};
  
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $name !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping sis '" . $name . "'.", debug => 1);
              next;
          }
  
          $self->{sis}->{$instance} = { display => $name };
      }
  
      if (scalar(keys %{$self->{sis}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No entry found.");
          $self->{output}->option_exit();
      }
      
      $options{snmp}->load(oids => [
              map($_->{oid}, values(%$mapping)) 
          ],
          instances => [keys %{$self->{sis}}], instance_regexp => '^(.*)$');
      $snmp_result = $options{snmp}->get_leef(nothing_quit => 1);
      
      foreach (keys %{$self->{sis}}) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $_);
          
          $self->{sis}->{$_} = { %{$self->{sis}->{$_}}, %$result };
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check single instance storage.
  
  =over 8
  
  =item B<--filter-name>
  
  Filter name (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{state}, %{status}, %{lastOpError}, %{display}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{state}, %{status}, %{lastOpError}, %{display}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '%{state} eq "enabled" and %{lastOpError} !~ /-|Success/i').
  Can used special variables like: %{state}, %{status}, %{lastOpError}, %{display}
  
  =back
  
  =cut
STORAGE_NETAPP_SNMP_MODE_SIS

$fatpacked{"storage/netapp/snmp/mode/snapmirrorlag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_SNAPMIRRORLAG';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::snapmirrorlag;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_status'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'snapmirror', type => 1, cb_prefix_output => 'prefix_snapmirror_output', message_multiple => 'All snapmirrors lags are ok' },
      ];
  
      $self->{maps_counters}->{snapmirror} = [
           { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'status' }, { name => 'display' } ],
                  output_template => "status is '%s'",
                  output_use => 'status',
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'lag', set => {
                  key_values => [ { name => 'lag' }, { name => 'display' } ],
                  output_template => 'lag: %s seconds',
                  perfdatas => [
                      { label => 'lag', value => 'lag_absolute', template => '%s', min => 0, unit => 's',
                        label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
      ];
  }
  
  sub prefix_snapmirror_output {
      my ($self, %options) = @_;
  
      return "Snapmirror '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
          "filter-status:s"   => { name => 'filter_status' },
          "unknown-status:s"  => { name => 'unknown_status', default => '' },
          "warning-status:s"  => { name => 'warning_status', default => '%{status} =~ /quiesced/i' },
          "critical-status:s" => { name => 'critical_status', default => '%{status} =~ /unknown|brokenOff|uninitialized/i' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => ['warning_status', 'critical_status', 'unknown_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_snapmirrorOn = '.1.3.6.1.4.1.789.1.9.1.0';
      my $oid_snapmirrorSrc = '.1.3.6.1.4.1.789.1.9.20.1.2';
  
      my $result = $options{snmp}->get_leef(oids => [$oid_snapmirrorOn]);
      if (!defined($result->{$oid_snapmirrorOn}) || $result->{$oid_snapmirrorOn} != 2) {
          $self->{output}->add_option_msg(short_msg => "Snapmirror is not turned on.");
          $self->{output}->option_exit();
      }
      
      my $id_selected = [];
      my $snmp_result_name = $options{snmp}->get_table(oid => $oid_snapmirrorSrc, nothing_quit => 1);
      foreach my $oid (keys %{$snmp_result_name}) {
          next if ($oid !~ /\.([0-9]+)$/);
          my $instance = $1;
          
          # Get all without a name
          if (!defined($self->{option_results}->{name})) {
              push @{$id_selected}, $instance; 
              next;
          }
          
          if (!defined($self->{option_results}->{use_regexp}) && $snmp_result_name->{$oid} eq $self->{option_results}->{name}) {
              push @{$id_selected}, $instance; 
          }
          if (defined($self->{option_results}->{use_regexp}) && $snmp_result_name->{$oid} =~ /$self->{option_results}->{name}/) {
              push @{$id_selected}, $instance;
          }
      }
  
      if (scalar(@{$id_selected}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No snapmirrors found for name '" . $self->{option_results}->{name} . "'.");
          $self->{output}->option_exit();
      }
      
      my %map_state = (
          1 => 'uninitialized', 
          2 => 'snapmirrored', 
          3 => 'brokenOff', 
          4 => 'quiesced',
          5 => 'source',
          6 => 'unknown',
      );
      my $mapping = {
          snapmirrorState => { oid => '.1.3.6.1.4.1.789.1.9.20.1.5', map => \%map_state },
          snapmirrorLag   => { oid => '.1.3.6.1.4.1.789.1.9.20.1.6' },
      };
      
      $options{snmp}->load(oids => [$mapping->{snapmirrorState}->{oid}, $mapping->{snapmirrorLag}->{oid}], instances => $id_selected);
      my $snmp_result = $options{snmp}->get_leef(nothing_quit => 1);
      
      $self->{snapmirror} = {};
      
      foreach (@{$id_selected}) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $_);
          if (defined($self->{option_results}->{filter_status}) && $self->{option_results}->{filter_status} ne '' &&
              $result->{snapmirrorState} !~ /$self->{option_results}->{filter_status}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $snmp_result_name->{$oid_snapmirrorSrc . '.' . $_} . "': no matching filter.", debug => 1);
              next;
          }
          
          $self->{snapmirror}->{$_} = {
              display => $snmp_result_name->{$oid_snapmirrorSrc . '.' . $_},
              status => $result->{snapmirrorState},
              lag => int($result->{snapmirrorLag} / 100),
          };
      }
      
      if (scalar(keys %{$self->{snapmirror}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No snapmirrors found.");
          $self->{output}->option_exit();
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check snapmirrors status and lag.
  
  =over 8
  
  =item B<--name>
  
  Set the snapmirror name.
  
  =item B<--regexp>
  
  Allows to use regexp to filter snampmirror name (with option --name).
  
  =item B<--filter-status>
  
  Filter on status (can be a regexp).
  
  =item B<--filter-counters>
  
  Only display some counters (regexp can be used).
  Example: --filter-counters='^status$'
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}, %{display}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '%{status} =~ /quiesced/i').
  Can used special variables like: %{status}, %{display}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '%{status} =~ /unknown|brokenOff|uninitialized/i').
  Can used special variables like: %{status}, %{display}
  
  =item B<--warning-lag>
  
  Threshold warning.
  
  =item B<--critical-lag>
  
  Threshold critical.
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_SNAPMIRRORLAG

$fatpacked{"storage/netapp/snmp/mode/snapshotage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_SNAPSHOTAGE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::snapshotage;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  use DateTime;
  
  my $oid_slvMonth = '.1.3.6.1.4.1.789.1.5.5.2.1.2';
  my $oid_slvDay = '.1.3.6.1.4.1.789.1.5.5.2.1.3';
  my $oid_slvHour = '.1.3.6.1.4.1.789.1.5.5.2.1.4';
  my $oid_slvMinutes = '.1.3.6.1.4.1.789.1.5.5.2.1.5';
  my $oid_slvName = '.1.3.6.1.4.1.789.1.5.5.2.1.6';
  my $oid_slvVolumeName = '.1.3.6.1.4.1.789.1.5.5.2.1.9';
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                    "name:s"          => { name => 'name' },
                                    "regexp"          => { name => 'use_regexp' },
                                    "warning:s"       => { name => 'warning' },
                                    "critical:s"      => { name => 'critical' },
                                  });
      $self->{snapshot_id_selected} = [];
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      if (($self->{perfdata}->threshold_validate(label => 'warning', value => $self->{option_results}->{warning})) == 0) {
         $self->{output}->add_option_msg(short_msg => "Wrong warning threshold '" . $self->{option_results}->{warning} . "'.");
         $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'critical', value => $self->{option_results}->{critical})) == 0) {
         $self->{output}->add_option_msg(short_msg => "Wrong critical threshold '" . $self->{option_results}->{critical} . "'.");
         $self->{output}->option_exit();
      }    
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{result_names} = $self->{snmp}->get_table(oid => $oid_slvName, nothing_quit => 1);
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{result_names}})) {
          next if ($oid !~ /\.([0-9]+\.[0-9]+)$/);
          my $instance = $1;
  
          # Get all without a name
          if (!defined($self->{option_results}->{name})) {
              push @{$self->{snapshot_id_selected}}, $instance; 
              next;
          }
          
          if (!defined($self->{option_results}->{use_regexp}) && $self->{result_names}->{$oid} eq $self->{option_results}->{name}) {
              push @{$self->{snapshot_id_selected}}, $instance; 
          }
          if (defined($self->{option_results}->{use_regexp}) && $self->{result_names}->{$oid} =~ /$self->{option_results}->{name}/) {
              push @{$self->{snapshot_id_selected}}, $instance;
          }
      }
  
      if (scalar(@{$self->{snapshot_id_selected}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No snapshot found for name '" . $self->{option_results}->{name} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      $self->manage_selection();
      $self->{snmp}->load(oids => [$oid_slvName, $oid_slvMonth, $oid_slvDay, $oid_slvHour, $oid_slvMinutes, $oid_slvVolumeName],
                          instances => $self->{snapshot_id_selected},
                          instance_regexp => '(\d+\.\d+)$');
      my $result = $self->{snmp}->get_leef();
      
      if (!defined($self->{option_results}->{name}) || defined($self->{option_results}->{use_regexp})) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'All snapshot age are ok.');
      }
  
      my $count = 0;
      my $now = time();
      foreach my $instance (sort @{$self->{snapshot_id_selected}}) {
          $count++;
          my $name = $self->{result_names}->{$oid_slvName . '.' . $instance};
          my $month = $result->{$oid_slvMonth . '.' . $instance};
          my $day = $result->{$oid_slvDay . '.' . $instance};
          my $hour = $result->{$oid_slvHour . '.' . $instance};
          my $minutes = $result->{$oid_slvMinutes . '.' . $instance};
          my $volume_name = $result->{$oid_slvVolumeName . '.' . $instance};
  
          my ($sec,$min,$hr,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
          $year = $year + 1900;     
          my $dt = DateTime->new(
                                  year       => $year,
                                  month      => $month,
                                  day        => $day,
                                  hour       => $hour,
                                  minute     => $minutes,
                                  second     => 0,
                                  time_zone  => 'local',
          );
          my $distant_time = $dt->epoch;
  
          my $age = $now - $distant_time;
  
          # Fix if snapshot was last year
          if ($age < 0) {
              $dt = DateTime->new(
                                  year       => $year - 1,
                                  month      => $month,
                                  day        => $day,
                                  hour       => $hour,
                                  minute     => $minutes,
                                  second     => 0,
                                  time_zone  => 'local',
              );
              $distant_time = $dt->epoch;
              $age = $now - $distant_time;
          }
  
          my $readable_age = centreon::plugins::misc::change_seconds(value => $age);
          $self->{output}->output_add(long_msg => sprintf("Snapshot '%s' age: %s [Volume: %s]", $name, $readable_age, $volume_name));
  
          my $exit = $self->{perfdata}->threshold_check(value => $age, threshold => [ { label => 'critical', 'exit_litteral' => 'critical' }, { label => 'warning', exit_litteral => 'warning' } ]);
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Snapshot '%s' age: %s [Volume: %s]", $name, $readable_age, $volume_name));
          }
      }
      
      $self->{output}->perfdata_add(label => 'snapshots',
                                    value => $count,
                                    min => 0);
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check snapshot age of volumes.
  
  =over 8
  
  =item B<--warning>
  
  Threshold warning in seconds.
  
  =item B<--critical>
  
  Threshold critical in seconds.
  
  =item B<--name>
  
  Set the snapshot name.
  
  =item B<--regexp>
  
  Allows to use regexp to filter snapshot name (with option --name).
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_SNAPSHOTAGE

$fatpacked{"storage/netapp/snmp/mode/snapvaultusage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_SNAPVAULTUSAGE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::snapvaultusage;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  use Digest::MD5 qw(md5_hex);
  
  sub custom_status_output { 
      my ($self, %options) = @_;
  
      my $msg = 'status : ' . $self->{result_values}->{status} . ' [state : ' . $self->{result_values}->{state} . ']';
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_svStatus'};
      $self->{result_values}->{state} = $options{new_datas}->{$self->{instance} . '_svState'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'snapvault', type => 1, cb_prefix_output => 'prefix_snapvault_output', message_multiple => 'All snapvault usages are ok', skipped_code => { -10 => 1, -11 => 1 } }
      ];
  
      $self->{maps_counters}->{snapvault} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'svState' }, { name => 'svStatus' }, { name => 'display' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'lag', set => {
                  key_values => [ { name => 'svLag' }, { name => 'display' } ],
                  output_template => 'lag : %s seconds',
                  perfdatas => [
                      { label => 'lag', value => 'svLag_absolute', template => '%s', min => 0, unit => 's',
                        label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
          { label => 'transfer-traffic', set => {
                  key_values => [ { name => 'svTotalTransMBs', diff => 1 }, { name => 'display' } ],
                  per_second => 1, output_change_bytes => 1,
                  output_template => 'transfer traffic : %s %s/s',
                  perfdatas => [
                      { label => 'transfer_traffic', template => '%.2f', value => 'svTotalTransMBs_per_second',
                        unit => 'B/s', min => 0, label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
          { label => 'transfer-succeed', displa_ok => 0, set => {
                  key_values => [ { name => 'svTotalSuccesses' }, { name => 'display' } ],
                  output_template => 'transfer succeed : %s',
                  perfdatas => [
                      { label => 'transfer_succeed', value => 'svTotalSuccesses_absolute', template => '%s', min => 0,
                        label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
          { label => 'transfer-failed', displa_ok => 0, set => {
                  key_values => [ { name => 'svTotalFailures' }, { name => 'display' } ],
                  output_template => 'transfer failed : %s',
                  perfdatas => [
                      { label => 'transfer_failed', value => 'svTotalFailures_absolute', template => '%s', min => 0,
                        label_extra_instance => 1, instance_use => 'display_absolute' },
                  ],
              }
          },
      ];
  }
  
  sub prefix_snapvault_output {
      my ($self, %options) = @_;
  
      return "Snapvault '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
          "filter-name:s"     => { name => 'filter_name' },
          "unknown-status:s"  => { name => 'unknown_status', default => '' },
          "warning-status:s"  => { name => 'warning_status', default => '' },
          "critical-status:s" => { name => 'critical_status', default => '' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => ['warning_status', 'critical_status', 'unknown_status']);
  }
  
  my $map_status = {
      1 => 'idle', 2 => 'transferring', 3 => 'pending',
      4 => 'aborting', 6 => 'quiescing', 7 => 'resyncing',
      12 => 'paused',
  };
  
  my $map_state = {
      1 => 'uninitialized', 2 => 'snapvaulted',
      3 => 'brokenOff', 4 => 'quiesced',
      5 => 'source', 6 => 'unknown', 7 => 'restoring',
  };
  
  my $mapping = {
      svStatus            => { oid => '.1.3.6.1.4.1.789.1.19.11.1.4', map => $map_status }, 
      svState             => { oid => '.1.3.6.1.4.1.789.1.19.11.1.5', map => $map_state },
      svLag               => { oid => '.1.3.6.1.4.1.789.1.19.11.1.6' }, # timeticks
      svTotalSuccesses    => { oid => '.1.3.6.1.4.1.789.1.19.11.1.7' },
      svTotalFailures     => { oid => '.1.3.6.1.4.1.789.1.19.11.1.9' },
      svTotalTransMBs     => { oid => '.1.3.6.1.4.1.789.1.19.11.1.11' },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my $oid_svOn = '.1.3.6.1.4.1.789.1.19.1.0';
  
      my $snmp_result = $options{snmp}->get_leef(oids => [$oid_svOn]);
      if (!defined($snmp_result->{$oid_svOn}) || $snmp_result->{$oid_svOn} != 2) {
          $self->{output}->add_option_msg(short_msg => "snapvault is not turned on.");
          $self->{output}->option_exit();
      }
      
      my $oid_svSrc = '.1.3.6.1.4.1.789.1.19.11.1.2';
      my $oid_svDst = '.1.3.6.1.4.1.789.1.19.11.1.3';
      
      $self->{snapvault} = {};
      $snmp_result = $options{snmp}->get_multiple_table(oids => [{ oid => $oid_svSrc }, { oid => $oid_svDst }], return_type => 1, nothing_quit => 1);
      foreach my $oid (keys %{$snmp_result}) {
          next if ($oid !~ /^$oid_svSrc\.(.*)$/);
          my $instance = $1;
          my $name = $snmp_result->{$oid_svSrc . '.' . $instance} . '.' . $snmp_result->{$oid_svDst . '.' . $instance};
  
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $name !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping snapvault '" . $name . "'.", debug => 1);
              next;
          }
  
          $self->{snapvault}->{$instance} = { display => $name };
      }
  
      if (scalar(keys %{$self->{snapvault}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No entry found.");
          $self->{output}->option_exit();
      }
      
      $options{snmp}->load(oids => [
              map($_->{oid}, values(%$mapping)) 
          ],
          instances => [keys %{$self->{snapvault}}], instance_regexp => '^(.*)$');
      $snmp_result = $options{snmp}->get_leef(nothing_quit => 1);
      
      foreach (keys %{$self->{snapvault}}) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $_);
  
          $result->{svTotalTransMBs} *= 1024 * 1024;
          $result->{svLag} = int($result->{svLag} / 100);
          
          $self->{snapvault}->{$_} = { %{$self->{snapvault}->{$_}}, %$result };
      }
      
      $self->{cache_name} = "netapp_" . $self->{mode} . '_' . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' .
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all')) . '_' .
          (defined($self->{option_results}->{filter_name}) ? md5_hex($self->{option_results}->{filter_name}) : md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Check snapvault usage.
  
  =over 8
  
  =item B<--filter-name>
  
  Filter snapvault name (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{state}, %{status}, %{display}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{state}, %{status}, %{display}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{state}, %{status}, %{display}
  
  =item B<--warning-*> B<--critical-*>
  
  Threshold warning.
  Can be:  'lag' (s), 'transfer-traffic' (B/s), 'transfer-succeed',
  'transfer-failed'.
  
  =back
  
  =cut
STORAGE_NETAPP_SNMP_MODE_SNAPVAULTUSAGE

$fatpacked{"storage/netapp/snmp/mode/temperature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_TEMPERATURE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::temperature;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my %mapping_temperature = (
      1 => 'no',
      2 => 'yes'
  );
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                  });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_envOverTemperature = '.1.3.6.1.4.1.789.1.2.4.1';
      my $oid_nodeName = '.1.3.6.1.4.1.789.1.25.2.1.1';
      my $oid_nodeEnvOverTemperature = '.1.3.6.1.4.1.789.1.25.2.1.18';
      my $results = $self->{snmp}->get_multiple_table(oids => [
                                                              { oid => $oid_envOverTemperature },
                                                              { oid => $oid_nodeName },
                                                              { oid => $oid_nodeEnvOverTemperature },
                                                              ], nothing_quit => 1);
      
      if (defined($results->{$oid_envOverTemperature}->{$oid_envOverTemperature . '.0'})) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'Hardware temperature is ok.');
          if ($mapping_temperature{$results->{$oid_envOverTemperature}->{$oid_envOverTemperature . '.0'}} eq 'yes') {
              $self->{output}->output_add(severity => 'CRITICAL',
                                          short_msg => 'Hardware temperature is over temperature range.');
          }
      } else {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'Hardware temperature are ok on all nodes');
          foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$results->{$oid_nodeEnvOverTemperature}})) {
              $oid =~ /^$oid_nodeEnvOverTemperature\.(.*)$/;
              my $instance = $1;
              my $name = $results->{$oid_nodeName}->{$oid_nodeName . '.' . $instance};
              my $temp = $results->{$oid_nodeEnvOverTemperature}->{$oid};
              $self->{output}->output_add(long_msg => sprintf("hardware temperature on node '%s' is over range: '%s'", 
                                                              $name, $mapping_temperature{$temp}));
              if ($mapping_temperature{$temp} eq 'yes') {
                  $self->{output}->output_add(severity => 'CRITICAL',
                                              short_msg => sprintf("Hardware temperature is over temperature range on node '%s'", $name));
              }
          }
      }
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check if hardware is currently operating outside of its recommended temperature range.
  
  =over 8
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_TEMPERATURE

$fatpacked{"storage/netapp/snmp/mode/volumeoptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_MODE_VOLUMEOPTIONS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::mode::volumeoptions;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_options_threshold {
      my ($self, %options) = @_;
      
      my $status = catalog_status_threshold($self, %options);
      if (!$self->{output}->is_status(value => $status, compare => 'ok', litteral => 1)) {
          $self->{instance_mode}->{global}->{failed}++;
      }
      return $status;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_status'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  sub custom_options_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{options} = $options{new_datas}->{$self->{instance} . '_options'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'volumes', type => 1, cb_prefix_output => 'prefix_volume_output', message_multiple => 'All volumes are ok', skipped_code => { -10 => 1 } },
          { name => 'global', type => 0 },
      ];
  
      $self->{maps_counters}->{volumes} = [
           { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'status' }, { name => 'display' } ],
                  output_template => "status is '%s'",
                  output_use => 'status',
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'options', threshold => 0, set => {
                  key_values => [ { name => 'options' }, { name => 'display' } ],
                  output_template => "options: '%s'",
                  output_use => 'options',
                  closure_custom_calc => $self->can('custom_options_calc'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => $self->can('custom_options_threshold'),
              }
          },
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'failed', display_ok => 0, set => {
                  key_values => [ { name => 'failed' } ],
                  output_template => 'Failed: %s',
                  perfdatas => [
                      { label => 'failed', value => 'failed_absolute', template => '%s', min => 0 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_volume_output {
      my ($self, %options) = @_;
  
      return "Volume '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "filter-name:s"         => { name => 'filter_name' },
          "filter-status:s"       => { name => 'filter_status' },
          "unknown-status:s"      => { name => 'unknown_status', default => '' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
          "unknown-options:s"     => { name => 'unknown_options', default => '' },
          "warning-options:s"     => { name => 'warning_options', default => '' },
          "critical-options:s"    => { name => 'critical_options', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->{test_option} = 0;
      foreach ('warning', 'unknown', 'critical') {
          $self->{test_option} = 1 if (defined($self->{option_results}->{$_ . '_options'}) && $self->{option_results}->{$_ . '_options'} ne '');
      }
      $self->change_macros(macros => ['warning_options', 'critical_options', 'unknown_options',
          'warning_status', 'critical_status', 'unknown_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_volName = '.1.3.6.1.4.1.789.1.5.8.1.2';    
      my $id_selected = [];
      my $snmp_result_name = $options{snmp}->get_table(oid => $oid_volName, nothing_quit => 1);
      foreach my $oid (keys %{$snmp_result_name}) {
          next if ($oid !~ /\.([0-9]+)$/);
          my $instance = $1;
          
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $snmp_result_name->{oid} !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $snmp_result_name->{oid} . "': no matching filter.", debug => 1);
              next;
          }
          push @{$id_selected}, $instance; 
      }
  
      if (scalar(@{$id_selected}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No volume found for name '" . $self->{option_results}->{filter_name} . "'.");
          $self->{output}->option_exit();
      }
      
      my $mapping = {
          volState     => { oid => '.1.3.6.1.4.1.789.1.5.8.1.5' },
          volOptions   => { oid => '.1.3.6.1.4.1.789.1.5.8.1.7' },
      };
      
      my $load_oids = [$mapping->{volState}->{oid}];
      push @$load_oids, $mapping->{volOptions}->{oid} if ($self->{test_option} == 1);
      $options{snmp}->load(oids => $load_oids, instances => $id_selected);
      my $snmp_result = $options{snmp}->get_leef(nothing_quit => 1);
      
      $self->{global} = { failed => 0 };
      $self->{volumes} = {};
      foreach (@{$id_selected}) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $_);
          if (defined($self->{option_results}->{filter_status}) && $self->{option_results}->{filter_status} ne '' &&
              $result->{volState} !~ /$self->{option_results}->{filter_status}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $snmp_result_name->{$oid_volName . '.' . $_} . "': no matching filter.", debug => 1);
              next;
          }
          
          $self->{volumes}->{$_} = {
              display => $snmp_result_name->{$oid_volName . '.' . $_},
              status => $result->{volState},
              options => $result->{volOptions},
          };
      }
      
      if (scalar(keys %{$self->{volumes}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No volume found.");
          $self->{output}->option_exit();
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check options from volumes.
  
  =over 8
  
  =item B<--filter-name>
  
  Filter on volume name (can be a regexp).
  
  =item B<--filter-status>
  
  Filter on volume status (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}, %{display}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}, %{display}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}, %{display}
  
  =item B<--unknown-options>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{options}, %{display}
  
  =item B<--warning-options>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{options}, %{display}
  
  =item B<--critical-options>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{options}, %{display}
  
  =back
  
  =cut
      
STORAGE_NETAPP_SNMP_MODE_VOLUMEOPTIONS

$fatpacked{"storage/netapp/snmp/plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_SNMP_PLUGIN';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::snmp::plugin;
  
  use strict;
  use warnings;
  use base qw(centreon::plugins::script_snmp);
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $self->{version} = '1.0';
      %{$self->{modes}} = (
          'aggregatestate'   => 'storage::netapp::snmp::mode::aggregatestate',
          'cache-age'        => 'storage::netapp::snmp::mode::cacheage',
          'cp-statistics'    => 'storage::netapp::snmp::mode::cpstatistics',
          'cpuload'          => 'storage::netapp::snmp::mode::cpuload',
          'diskfailed'       => 'storage::netapp::snmp::mode::diskfailed',
          'fan'              => 'storage::netapp::snmp::mode::fan',
          'filesys'          => 'storage::netapp::snmp::mode::filesys',
          'list-filesys'     => 'storage::netapp::snmp::mode::listfilesys',
          'list-snapvault'   => 'storage::netapp::snmp::mode::listsnapvault',
          'global-status'    => 'storage::netapp::snmp::mode::globalstatus',
          'ndmpsessions'     => 'storage::netapp::snmp::mode::ndmpsessions',
          'nvram'            => 'storage::netapp::snmp::mode::nvram',
          'partnerstatus'    => 'storage::netapp::snmp::mode::partnerstatus',
          'psu'              => 'storage::netapp::snmp::mode::psu',
          'qtree-usage'      => 'storage::netapp::snmp::mode::qtreeusage',
          'share-calls'      => 'storage::netapp::snmp::mode::sharecalls',
          'shelf'            => 'storage::netapp::snmp::mode::shelf',
          'sis'              => 'storage::netapp::snmp::mode::sis',
          'snapmirrorlag'    => 'storage::netapp::snmp::mode::snapmirrorlag',
          'snapshotage'      => 'storage::netapp::snmp::mode::snapshotage',
          'snapvault-usage'  => 'storage::netapp::snmp::mode::snapvaultusage',
          'temperature'      => 'storage::netapp::snmp::mode::temperature',
          'uptime'           => 'snmp_standard::mode::uptime',
          'volumeoptions'    => 'storage::netapp::snmp::mode::volumeoptions',
      );
  
      return $self;
  }
  
  1;
  
  
  =head1 PLUGIN DESCRIPTION
  
  Check Netapp in SNMP (Some Check needs ONTAP 8.x).
  
  =cut
STORAGE_NETAPP_SNMP_PLUGIN

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#
# Copyright 2019 Centreon (http://www.centreon.com/)
#
# Centreon is a full-fledged industry-strength solution that meets
# the needs in IT infrastructure and application monitoring for
# service performance.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

use strict;
use warnings;
# Not perl embedded compliant at all
use FindBin;
use lib "$FindBin::Bin";
# use lib '/usr/lib/nagios/plugins/';

use centreon::plugins::script;

centreon::plugins::script->new()->run();
