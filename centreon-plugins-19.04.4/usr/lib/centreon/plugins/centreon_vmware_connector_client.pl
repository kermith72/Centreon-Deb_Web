#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"apps/vmware/connector/custom/connector.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_CUSTOM_CONNECTOR';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::custom::connector;
  
  use strict;
  use warnings;
  use JSON;
  use ZMQ::LibZMQ4;
  use ZMQ::Constants qw(:all);
  use UUID;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      # $options{options} = options object
      # $options{output} = output object
      # $options{exit_value} = integer
      # $options{noptions} = integer
  
      if (!defined($options{output})) {
          print "Class Custom: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class Custom: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
      
      if (!defined($options{noptions})) {
          $options{options}->add_options(arguments => {
              'connector-hostname:s@'    => { name => 'connector_hostname' },
              'connector-port:s@'        => { name => 'connector_port' },
              'vsphere-address:s@'       => { name => 'vsphere_address' },
              'vsphere-username:s@'      => { name => 'vsphere_username' },
              'vsphere-password:s@'      => { name => 'vsphere_password' },
              'container:s@'             => { name => 'container' },
              'timeout:s@'               => { name => 'timeout' },
              'sampling-period:s@'       => { name => 'sampling_period' },
              'time-shift:s@'            => { name => 'time_shift' },
              'case-insensitive'         => { name => 'case_insensitive' },
              'unknown-connector-status:s'  => { name => 'unknown_connector_status' },
              'warning-connector-status:s'  => { name => 'warning_connector_status' },
              'critical-connector-status:s' => { name => 'critical_connector_status' },
          });
      }
      $options{options}->add_help(package => __PACKAGE__, sections => 'CONNECTOR OPTIONS', once => 1);
  
      $self->{output} = $options{output};
      $self->{mode} = $options{mode};
  
      $self->{json_send} = {};
      $self->{result} = undef;
      return $self;
  }
  
  # Method to manage multiples
  sub set_options {
      my ($self, %options) = @_;
      # options{options_result}
  
      $self->{option_results} = $options{option_results};
  }
  
  # Method to manage multiples
  sub set_defaults {
      my ($self, %options) = @_;
      # options{default}
      
      # Manage default value
      foreach (keys %{$options{default}}) {
          if ($_ eq $self->{mode}) {
              for (my $i = 0; $i < scalar(@{$options{default}->{$_}}); $i++) {
                  foreach my $opt (keys %{$options{default}->{$_}[$i]}) {
                      if (!defined($self->{option_results}->{$opt}[$i])) {
                          $self->{option_results}->{$opt}[$i] = $options{default}->{$_}[$i]->{$opt};
                      }
                  }
              }
          }
      }
  }
  
  sub check_options {
      my ($self, %options) = @_;
      # return 1 = ok still hostname
      # return 0 = no hostname left
  
      $self->{connector_hostname} = (defined($self->{option_results}->{connector_hostname})) ? shift(@{$self->{option_results}->{connector_hostname}}) : undef;
      $self->{connector_port} = (defined($self->{option_results}->{connector_port})) ? shift(@{$self->{option_results}->{connector_port}}) : 5700;
      $self->{container} = (defined($self->{option_results}->{container})) ? shift(@{$self->{option_results}->{container}}) : 'default';
      $self->{timeout} = (defined($self->{option_results}->{timeout})) ? shift(@{$self->{option_results}->{timeout}}) : undef;
      $self->{vsphere_address} = (defined($self->{option_results}->{vsphere_address})) ? shift(@{$self->{option_results}->{vsphere_address}}) : undef;
      $self->{vsphere_username} = (defined($self->{option_results}->{vsphere_username})) ? shift(@{$self->{option_results}->{vsphere_username}}) : undef;
      $self->{vsphere_password} = (defined($self->{option_results}->{vsphere_password})) ? shift(@{$self->{option_results}->{vsphere_password}}) : undef;
      $self->{sampling_period} = (defined($self->{option_results}->{sampling_period})) ? shift(@{$self->{option_results}->{sampling_period}}) : undef;
      $self->{time_shift} = (defined($self->{option_results}->{sampling_period})) ? shift(@{$self->{option_results}->{time_shift}}) : 0;
      $self->{unknown_connector_status} = (defined($self->{option_results}->{unknown_connector_status})) ? $self->{option_results}->{unknown_connector_status} : '%{code} < 0 || (%{code} > 0 && %{code} < 200)';
      $self->{warning_connector_status} = (defined($self->{option_results}->{warning_connector_status})) ? $self->{option_results}->{warning_connector_status} : '';
      $self->{critical_connector_status} = (defined($self->{option_results}->{critical_connector_status})) ? $self->{option_results}->{critical_connector_status} : '';
      $self->{case_insensitive} = (defined($self->{option_results}->{case_insensitive})) ? $self->{option_results}->{case_insensitive} : undef;
      
      $self->{connector_port} = 5700 if ($self->{connector_port} eq '');
      $self->{container} = 'default' if ($self->{container} eq '');
      if (!defined($self->{connector_hostname}) || $self->{connector_hostname} eq '') {
          $self->{output}->add_option_msg(short_msg => 'Please set option --connector-hostname.');
          $self->{output}->option_exit();
      }
      if (defined($self->{timeout}) && $self->{timeout} =~ /^\d+$/ &&
          $self->{timeout} > 0) {
          $self->{timeout} = $self->{timeout};
      } else {
          $self->{timeout} = 50;
      }
      
      if (!defined($self->{connector_hostname}) ||
          scalar(@{$self->{option_results}->{connector_hostname}}) == 0) {
          return 0;
      }
      return 1;
  }
  
  sub add_params {
      my ($self, %options) = @_;
      
      $self->{json_send}->{command} = $options{command} if (defined($options{command}));
      foreach (keys %{$options{params}}) {
          $self->{json_send}->{$_} = $options{params}->{$_};
      }
  }
  
  sub connector_response {
      my ($self, %options) = @_;
      
      if (!defined($options{response})) {
          $self->{output}->add_option_msg(short_msg => "Cannot read response: $!");
          $self->{output}->option_exit();
      }
      
      my $data = zmq_msg_data($options{response});
      if ($data !~ /^RESPSERVER (.*)/msi) {
          $self->{output}->add_option_msg(short_msg => "Response not formatted: $data");
          $self->{output}->option_exit();
      }
      
      my $json = $1;
      eval {
          $self->{output}->output_add(long_msg => $json, debug => 1);
          $self->{result} = JSON->new->utf8->decode($json);
      };
      if ($@) {
          $self->{output}->add_option_msg(short_msg => "Cannot decode json result: $@");
          $self->{output}->option_exit();
      }
  }
  
  sub connector_response_status {
      my ($self, %options) = @_;
      
      if (!defined($self->{result})) {
          $self->{output}->add_option_msg(short_msg => 'Cannot get response (timeout received)');
          $self->{output}->option_exit();
      }
      if (!defined($self->{result}->{code})) {
          $self->{output}->add_option_msg(short_msg => 'response format incorrect - need connector vmware version >= 3.x.x');
          $self->{output}->option_exit();
      }
      
      foreach (('unknown_connector_status', 'warning_connector_status', 'critical_connector_status')) {
          $self->{$_} =~ s/%\{(.*?)\}/\$self->{result}->{$1}/g;
      }
          
      # Check response
      my $status = 'ok';
      my $message;
      eval {
          local $SIG{__WARN__} = sub { $message = $_[0]; };
          local $SIG{__DIE__} = sub { $message = $_[0]; };
  
          if (defined($self->{critical_connector_status}) && $self->{critical_connector_status} ne '' &&
              eval "$self->{critical_connector_status}") {
              $status = 'critical';
          } elsif (defined($self->{warning_connector_status}) && $self->{warning_connector_status} ne '' &&
                   eval "$self->{warning_connector_status}") {
              $status = 'warning';
          } elsif (defined($self->{unknown_connector_status}) && $self->{unknown_connector_status} ne '' &&
                   eval "$self->{unknown_connector_status}") {
              $status = 'unknown';
          }
      };
      if (defined($message)) {
          $self->{output}->add_option_msg(short_msg => 'filter connector status issue: ' . $message);
          $self->{output}->option_exit();
      }
  
      if (!$self->{output}->is_status(value => $status, compare => 'ok', litteral => 1)) {
          $self->{output}->output_add(long_msg => $self->{result}->{extra_message}, debug => 1);
          $self->{output}->output_add(severity => $status,
                                      short_msg => $self->{result}->{short_message});
          $self->{output}->display();
          $self->{output}->exit();
      }
  }
  
  sub entity_is_connected {
      my ($self, %options) = @_;
       
      if ($options{state} !~ /^connected$/i) {
          return 0;
      }
      return 1;
  }
  
  sub vm_is_running {
      my ($self, %options) = @_;
      
      if ($options{power} !~ /^poweredOn$/i) {
          return 0;
      }
      return 1;
  }
  
  sub get_id {
      my ($self, %options) = @_;
      
      return $self->{connector_hostname} . '.' . $self->{connector_port} . '.' .  $self->{container};
  }
  
  sub strip_cr {
       my ($self, %options) = @_;
      
      $options{value} =~ s/^\s+.*\s+$//mg;
      $options{value} =~ s/\r//mg;
      $options{value} =~ s/\n/ -- /mg;
      return $options{value};
  }
  
  sub execute {
      my ($self, %options) = @_;
      
      $self->add_params(%options);
      
      # Build request
      my $uuid;
      UUID::generate($uuid);
      $self->{uuid} = $uuid;
      $self->{json_send}->{identity} = 'client-' . unpack('H*', $self->{uuid});
      $self->{json_send}->{connector_hostname} = $self->{connector_hostname};
      $self->{json_send}->{connector_port} = $self->{connector_port};
      $self->{json_send}->{container} = $self->{container};
      $self->{json_send}->{vsphere_address} = $self->{vsphere_address};
      $self->{json_send}->{vsphere_username} = $self->{vsphere_username};
      $self->{json_send}->{vsphere_password} = $self->{vsphere_password};
      $self->{json_send}->{sampling_period} = $self->{sampling_period};
      $self->{json_send}->{time_shift} = $self->{time_shift};
      $self->{json_send}->{case_insensitive} = $self->{case_insensitive};
      
      # Init
      my $context = zmq_init();
      $self->{requester} = zmq_socket($context, ZMQ_DEALER);
      if (!defined($self->{requester})) {
          $self->{output}->add_option_msg(short_msg => "Cannot create socket: $!");
          $self->{output}->option_exit();
      }
      
      my $flag = ZMQ_NOBLOCK | ZMQ_SNDMORE;
      zmq_setsockopt($self->{requester}, ZMQ_IDENTITY, "client-" . $self->{uuid});
      zmq_setsockopt($self->{requester}, ZMQ_LINGER, 0); # we discard
      zmq_connect($self->{requester}, 'tcp://' . $self->{connector_hostname} . ':' . $self->{connector_port});
      zmq_sendmsg($self->{requester}, "REQCLIENT " . JSON->new->utf8->encode($self->{json_send}), ZMQ_NOBLOCK);
      
      my @poll = (
          {
              socket  => $self->{requester},
              events  => ZMQ_POLLIN,
              callback => sub {
                 my $response = zmq_recvmsg($self->{requester});
                 zmq_close($self->{requester});
                 $self->connector_response(response => $response);
              },
          },
      );
      
      zmq_poll(\@poll, $self->{timeout} * 1000);    
      zmq_close($self->{requester});
      
      $self->connector_response_status();
      
      return $self->{result};
  }
  
  1;
  
  
  =head1 NAME
  
  VMWare connector library
  
  =head1 SYNOPSIS
  
  my vmware connector
  
  =head1 CONNECTOR OPTIONS
  
  =over 8
  
  =item B<--connector-hostname>
  
  Connector hostname (required).
  
  =item B<--connector-port>
  
  Connector port (default: 5700).
  
  =item B<--container>
  
  Container to use (it depends of the connector configuration).
  
  =item B<--vsphere-address>
  
  Address of vpshere/ESX to connect.
  
  =item B<--vsphere-username>
  
  Username of vpshere/ESX connection (with --vsphere-address).
  
  =item B<--vsphere-password>
  
  Password of vpshere/ESX connection (with --vsphere-address).
  
  =item B<--timeout>
  
  Set global execution timeout (Default: 50)
  
  =item B<--sampling-period>
  
  Choose the sampling period (can change the default sampling for counters).
  Should be not different than 300 or 20.
  
  =item B<--time-shift>
  
  Can shift the time. We the following option you can average X counters values (default: 0).
  
  =item B<--case-insensitive>
  
  Searchs are case insensitive.
  
  =item B<--unknown-connector-status>
  
  Set unknown threshold for connector status (Default: '%{code} < 0 || (%{code} > 0 && %{code} < 200)').
  Can used special variables like: %{code}, %{short_message}, %{extra_message}.
  
  =item B<--warning-connector-status>
  
  Set warning threshold for connector status (Default: '').
  Can used special variables like: %{code}, %{short_message}, %{extra_message}.
  
  =item B<--critical-connector-status>
  
  Set critical threshold for connector status (Default: '').
  Can used special variables like: %{code}, %{short_message}, %{extra_message}.
  
  =back
  
  =head1 DESCRIPTION
  
  B<custom>.
  
  =cut
APPS_VMWARE_CONNECTOR_CUSTOM_CONNECTOR

$fatpacked{"apps/vmware/connector/mode/alarmdatacenter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_ALARMDATACENTER';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::alarmdatacenter;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use centreon::plugins::statefile;
  
  sub catalog_status_threshold {
      my ($self, %options) = @_;
      my $status = 'ok';
      my $message;
  
      eval {
          local $SIG{__WARN__} = sub { $message = $_[0]; };
          local $SIG{__DIE__} = sub { $message = $_[0]; };
  
          my $label = $self->{label};
          $label =~ s/-/_/g;
          if (defined($self->{instance_mode}->{option_results}->{'critical_' . $label}) && $self->{instance_mode}->{option_results}->{'critical_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'critical_' . $label}") {
              $self->{instance_mode}->{dc_critical}++;
              $status = 'critical';
          } elsif (defined($self->{instance_mode}->{option_results}->{'warning_' . $label}) && $self->{instance_mode}->{option_results}->{'warning_' . $label} ne '' &&
                   eval "$self->{instance_mode}->{option_results}->{'warning_' . $label}") {
              $self->{instance_mode}->{dc_warning}++;
              $status = 'warning';
          }
      };
      if (defined($message)) {
          $self->{output}->output_add(long_msg => 'filter status issue: ' . $message);
      }
  
      return $status;
  }
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = sprintf("alarm [%s] [%s] [%s] [%s] %s/%s", 
          $self->{result_values}->{status},
          $self->{result_values}->{type},
          $self->{result_values}->{entity_name},
          $self->{result_values}->{time},
          $self->{result_values}->{name},
          $self->{result_values}->{description}
      );
  
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{entity_name} = $options{new_datas}->{$self->{instance} . '_entity_name'};
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_status'};
      $self->{result_values}->{name} = $options{new_datas}->{$self->{instance} . '_name'};
      $self->{result_values}->{type} = $options{new_datas}->{$self->{instance} . '_type'};
      $self->{result_values}->{since} = $options{new_datas}->{$self->{instance} . '_since'};
      $self->{result_values}->{description} = $options{new_datas}->{$self->{instance} . '_description'};
      $self->{result_values}->{time} = $options{new_datas}->{$self->{instance} . '_time'};
      return 0;
  }
  
  sub custom_dcmetrics_perfdata {
      my ($self, %options) = @_;
  
      my $extra_label;
      # We do it manually. Because we have only 1 instance in group.
      if (scalar(keys %{$self->{instance_mode}->{datacenter}}) > 1 || $self->{output}->use_new_perfdata()) {
          $extra_label = $self->{result_values}->{name};
      }
      
      $self->{output}->perfdata_add(
          label => 'alarm_' . $self->{result_values}->{label_ref},
          nlabel => 'datacenter.alarms.' . $self->{result_values}->{label_ref} . '.current.count',
          instances => $extra_label,
          value => $self->{result_values}->{alarm_value},
          min => 0
      );
  }
  
  sub custom_dcmetrics_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{label_ref} = $options{extra_options}->{label_ref};
      $self->{result_values}->{alarm_value} = $self->{instance_mode}->{'dc_' . $options{extra_options}->{label_ref}};
      $self->{result_values}->{name} = $options{new_datas}->{$self->{instance} . '_name'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
          { name => 'datacenter', type => 2, cb_prefix_output => 'prefix_datacenter_output', cb_long_output => 'datacenter_long_output', message_multiple => 'All datacenters are ok', 
              group => [ 
                  { name => 'alarm', cb_init => 'alarm_reset', skipped_code => { -11 => 1 } },
                  { name => 'dc_metrics', display => 0, skipped_code => { -11 => 1 } },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'total-alarm-warning', nlabel => 'datacenter.alarms.warning.current.count', set => {
                  key_values => [ { name => 'yellow' } ],
                  output_template => '%s warning alarm(s) found(s)',
                  perfdatas => [
                      { label => 'total_alarm_warning', value => 'yellow_absolute', template => '%s', min => 0 },
                  ],
              }
          },
          { label => 'total-alarm-critical', nlabel => 'datacenter.alarms.critical.current.count', set => {
                  key_values => [ { name => 'red' } ],
                  output_template => '%s critical alarm(s) found(s)',
                  perfdatas => [
                      { label => 'total_alarm_critical', value => 'red_absolute', template => '%s', min => 0 },
                  ],
              }
          },
      ];
  
      $self->{maps_counters}->{alarm} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'entity_name' }, { name => 'status' }, 
                      { name => 'time' }, { name => 'description' }, { name => 'name' }, { name => 'type' }, { name => 'since' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{dc_metrics} = [
          { label => 'alarm-warning', threshold => 0, set => {
                  key_values => [ { name => 'name' }  ],
                  output_template => '',
                  closure_custom_threshold_check => sub { return 'ok' },
                  closure_custom_calc => $self->can('custom_dcmetrics_calc'), closure_custom_calc_extra_options => { label_ref => 'warning' },
                  closure_custom_perfdata => $self->can('custom_dcmetrics_perfdata'),
              }
          },
          { label => 'alarm-critical', threshold => 0, set => {
                  key_values => [ { name => 'name' }  ],
                  output_template => '',
                  closure_custom_threshold_check => sub { return 'ok' },
                  closure_custom_calc => $self->can('custom_dcmetrics_calc'), closure_custom_calc_extra_options => { label_ref => 'critical' },
                  closure_custom_perfdata => $self->can('custom_dcmetrics_perfdata'),
              }
          },
      ];
  }
  
  sub prefix_datacenter_output {
      my ($self, %options) = @_;
  
      return "Datacenter '" . $options{instance_value}->{display} . "' ";
  }
  
  sub alarm_reset {
      my ($self, %options) = @_;
      
      $self->{dc_warning} = 0;
      $self->{dc_critical} = 0;
  }
  
  sub datacenter_long_output {
      my ($self, %options) = @_;
  
      return "checking datacenter '" . $options{instance_value}->{display} . "'";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "datacenter:s"            => { name => 'datacenter' },
          "filter"                  => { name => 'filter' },
          "filter-time:s"           => { name => 'filter_time', },
          "memory"                  => { name => 'memory', },
          "warning-status:s"        => { name => 'warning_status', default => '%{status} =~ /yellow/i' },
          "critical-status:s"       => { name => 'critical_status', default => '%{status} =~ /red/i' },
      });
      
      centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Date::Parse',
                                             error_msg => "Cannot load module 'Date::Parse'.");
      $self->{statefile_cache} = centreon::plugins::statefile->new(%options);
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => ['warning_status', 'critical_status']);
      if (defined($self->{option_results}->{memory})) {
          $self->{statefile_cache}->check_options(%options);
      }
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{global} = { yellow => 0, red => 0 };
      $self->{datacenter} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'alarmdatacenter');
  
      my $last_time;
      if (defined($self->{option_results}->{memory})) {
          $self->{statefile_cache}->read(statefile => "cache_vmware_" . $options{custom}->get_id() . '_' . $self->{mode});
          $last_time = $self->{statefile_cache}->get(name => 'last_time');
      }
  
      my ($i, $current_time) = (1, time());
      foreach my $datacenter_id (keys %{$response->{data}}) {
          my $datacenter_name = $response->{data}->{$datacenter_id}->{name};
          $self->{datacenter}->{$datacenter_name} = { display => $datacenter_name, alarm => {}, dc_metrics => { 1 => { name => $datacenter_name } } };
          
          foreach (keys %{$response->{data}->{$datacenter_id}->{alarms}}) {
              my $create_time = Date::Parse::str2time($response->{data}->{$datacenter_id}->{alarms}->{$_}->{time});
              if (!defined($create_time)) {
                  $self->{manager}->{output}->output_add(severity => 'UNKNOWN',
                                                         short_msg => "Can't Parse date '" . $response->{data}->{$datacenter_id}->{alarms}->{$_}->{time} . "'");
                  next;
              }
  
              next if (defined($self->{option_results}->{memory}) && defined($last_time) && $last_time > $create_time);
  
              my $diff_time = $current_time - $create_time;
              if (defined($self->{option_results}->{filter_time}) && $self->{option_results}->{filter_time} ne '') {
                  next if ($diff_time > $self->{option_results}->{filter_time});
              }
  
              $self->{datacenter}->{$datacenter_name}->{alarm}->{$i} = { %{$response->{data}->{$datacenter_id}->{alarms}->{$_}}, since => $diff_time };
              $self->{global}->{$response->{data}->{$datacenter_id}->{alarms}->{$_}->{status}}++;
              $i++;
          }
      }
  
      if (defined($self->{option_results}->{memory})) {
          $self->{statefile_cache}->write(data => { last_time => $current_time });
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check datacenter alarms (red an yellow).
  
  =over 8
  
  =item B<--datacenter>
  
  Datacenter to check.
  If not set, we check all datacenters.
  
  =item B<--filter>
  
  Datacenter is a regexp.
  
  =item B<--filter-time>
  
  Don't check alarm older (value in seconds).
  
  =item B<--memory>
  
  Check new alarms only.
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '%{status} =~ /yellow/i).
  Can used special variables like: %{status}, %{name}, %{entity}, %{type}.
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '%{status} =~ /red/i').
  Can used special variables like: %{status}, %{name}, %{entity}, %{type}.
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-alarm-warning', 'total-alarm-critical'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-alarm-warning', 'total-alarm-critical'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_ALARMDATACENTER

$fatpacked{"apps/vmware/connector/mode/alarmhost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_ALARMHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::alarmhost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use centreon::plugins::statefile;
  
  sub catalog_status_threshold {
      my ($self, %options) = @_;
      my $status = 'ok';
      my $message;
  
      eval {
          local $SIG{__WARN__} = sub { $message = $_[0]; };
          local $SIG{__DIE__} = sub { $message = $_[0]; };
  
          my $label = $self->{label};
          $label =~ s/-/_/g;
          if (defined($self->{instance_mode}->{option_results}->{'critical_' . $label}) && $self->{instance_mode}->{option_results}->{'critical_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'critical_' . $label}") {
              $self->{instance_mode}->{host_critical}++;
              $status = 'critical';
          } elsif (defined($self->{instance_mode}->{option_results}->{'warning_' . $label}) && $self->{instance_mode}->{option_results}->{'warning_' . $label} ne '' &&
                   eval "$self->{instance_mode}->{option_results}->{'warning_' . $label}") {
              $self->{instance_mode}->{host_warning}++;
              $status = 'warning';
          }
      };
      if (defined($message)) {
          $self->{output}->output_add(long_msg => 'filter status issue: ' . $message);
      }
  
      return $status;
  }
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = sprintf("alarm [%s] [%s] [%s] [%s] %s/%s", 
          $self->{result_values}->{status},
          $self->{result_values}->{type},
          $self->{result_values}->{entity_name},
          $self->{result_values}->{time},
          $self->{result_values}->{name},
          $self->{result_values}->{description}
      );
  
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{entity_name} = $options{new_datas}->{$self->{instance} . '_entity_name'};
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_status'};
      $self->{result_values}->{name} = $options{new_datas}->{$self->{instance} . '_name'};
      $self->{result_values}->{type} = $options{new_datas}->{$self->{instance} . '_type'};
      $self->{result_values}->{since} = $options{new_datas}->{$self->{instance} . '_since'};
      $self->{result_values}->{description} = $options{new_datas}->{$self->{instance} . '_description'};
      $self->{result_values}->{time} = $options{new_datas}->{$self->{instance} . '_time'};
      return 0;
  }
  
  sub custom_esxhost_perfdata {
      my ($self, %options) = @_;
  
      my $extra_label;
      # We do it manually. Because we have only 1 instance in group.
      if (scalar(keys %{$self->{instance_mode}->{esxhost}}) > 1 || $self->{output}->use_new_perfdata()) {
          $extra_label = $self->{result_values}->{name};
      }
      $self->{output}->perfdata_add(
          label => 'alarm_' . $self->{result_values}->{label_ref},
          nlabel => 'host.alarms.' . $self->{result_values}->{label_ref} . '.current.count',
          instances => $extra_label,
          value => $self->{result_values}->{alarm_value},
          min => 0
      );
  }
  
  sub custom_esxhost_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{label_ref} = $options{extra_options}->{label_ref};
      $self->{result_values}->{alarm_value} = $self->{instance_mode}->{'host_' . $options{extra_options}->{label_ref}};
      $self->{result_values}->{name} = $options{new_datas}->{$self->{instance} . '_name'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
          { name => 'esxhost', type => 2, cb_prefix_output => 'prefix_esxhost_output', cb_long_output => 'esxhost_long_output', message_multiple => 'All hosts are ok', 
              group => [ 
                  { name => 'alarm', cb_init => 'alarm_reset', skipped_code => { -11 => 1 } },
                  { name => 'esxhost_metrics', display => 0, skipped_code => { -11 => 1 } },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'total-alarm-warning', nlabel => 'host.alarms.warning.current.count', set => {
                  key_values => [ { name => 'yellow' } ],
                  output_template => '%s warning alarm(s) found(s)',
                  perfdatas => [
                      { label => 'total_alarm_warning', value => 'yellow_absolute', template => '%s', min => 0 },
                  ],
              }
          },
          { label => 'total-alarm-critical', nlabel => 'host.alarms.critical.current.count', set => {
                  key_values => [ { name => 'red' } ],
                  output_template => '%s critical alarm(s) found(s)',
                  perfdatas => [
                      { label => 'total_alarm_critical', value => 'red_absolute', template => '%s', min => 0 },
                  ],
              }
          },
      ];
  
      $self->{maps_counters}->{alarm} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'entity_name' }, { name => 'status' }, 
                      { name => 'time' }, { name => 'description' }, { name => 'name' }, { name => 'type' }, { name => 'since' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{esxhost_metrics} = [
          { label => 'alarm-warning', threshold => 0, set => {
                  key_values => [ { name => 'name' }  ],
                  output_template => '',
                  closure_custom_threshold_check => sub { return 'ok' },
                  closure_custom_calc => $self->can('custom_esxhost_calc'), closure_custom_calc_extra_options => { label_ref => 'warning' },
                  closure_custom_perfdata => $self->can('custom_esxhost_perfdata'),
              }
          },
          { label => 'alarm-critical', threshold => 0, set => {
                  key_values => [ { name => 'name' }  ],
                  output_template => '',
                  closure_custom_threshold_check => sub { return 'ok' },
                  closure_custom_calc => $self->can('custom_esxhost_calc'), closure_custom_calc_extra_options => { label_ref => 'critical' },
                  closure_custom_perfdata => $self->can('custom_esxhost_perfdata'),
              }
          },
      ];
  }
  
  sub prefix_esxhost_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' ";
  }
  
  sub alarm_reset {
      my ($self, %options) = @_;
      
      $self->{host_warning} = 0;
      $self->{host_critical} = 0;
  }
  
  sub esxhost_long_output {
      my ($self, %options) = @_;
  
      return "checking host '" . $options{instance_value}->{display} . "'";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  { 
                                    "esx-hostname:s"          => { name => 'esx_hostname' },
                                    "filter"                  => { name => 'filter' },
                                    "scope-datacenter:s"      => { name => 'scope_datacenter' },
                                    "scope-cluster:s"         => { name => 'scope_cluster' },
                                    "filter-time:s"           => { name => 'filter_time', },
                                    "memory"                  => { name => 'memory', },
                                    "warning-status:s"        => { name => 'warning_status', default => '%{status} =~ /yellow/i' },
                                    "critical-status:s"       => { name => 'critical_status', default => '%{status} =~ /red/i' },
                                  });
  
      centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Date::Parse',
                                             error_msg => "Cannot load module 'Date::Parse'.");
      $self->{statefile_cache} = centreon::plugins::statefile->new(%options);
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => ['warning_status', 'critical_status']);
      if (defined($self->{option_results}->{memory})) {
          $self->{statefile_cache}->check_options(%options);
      }
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{global} = { yellow => 0, red => 0 };
      $self->{esxhost} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'alarmhost');
  
      my $last_time;
      if (defined($self->{option_results}->{memory})) {
          $self->{statefile_cache}->read(statefile => "cache_vmware_" . $options{custom}->get_id() . '_' . $self->{mode});
          $last_time = $self->{statefile_cache}->get(name => 'last_time');
      }
  
      my ($i, $current_time) = (1, time());
      foreach my $esxhost_id (keys %{$response->{data}}) {
          my $esxhost_name = $response->{data}->{$esxhost_id}->{name};
          $self->{esxhost}->{$esxhost_name} = { display => $esxhost_name, alarm => {}, esxhost_metrics => { 1 => { name => $esxhost_name } } };
          
          foreach (keys %{$response->{data}->{$esxhost_id}->{alarms}}) {
              my $create_time = Date::Parse::str2time($response->{data}->{$esxhost_id}->{alarms}->{$_}->{time});
              if (!defined($create_time)) {
                  $self->{manager}->{output}->output_add(severity => 'UNKNOWN',
                                                         short_msg => "Can't Parse date '" . $response->{data}->{$esxhost_id}->{alarms}->{$_}->{time} . "'");
                  next;
              }
  
              next if (defined($self->{option_results}->{memory}) && defined($last_time) && $last_time > $create_time);
  
              my $diff_time = $current_time - $create_time;
              if (defined($self->{option_results}->{filter_time}) && $self->{option_results}->{filter_time} ne '') {
                  next if ($diff_time > $self->{option_results}->{filter_time});
              }
  
              $self->{esxhost}->{$esxhost_name}->{alarm}->{$i} = { %{$response->{data}->{$esxhost_id}->{alarms}->{$_}}, since => $diff_time };
              $self->{global}->{$response->{data}->{$esxhost_id}->{alarms}->{$_}->{status}}++;
              $i++;
          }
      }
  
      if (defined($self->{option_results}->{memory})) {
          $self->{statefile_cache}->write(data => { last_time => $current_time });
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check ESX host alarms (red an yellow).
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  Datacenter is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--filter-time>
  
  Don't check alarm older (value in seconds).
  
  =item B<--memory>
  
  Check new alarms only.
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '%{status} =~ /yellow/i).
  Can used special variables like: %{status}, %{name}, %{entity}, %{type}.
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '%{status} =~ /red/i').
  Can used special variables like: %{status}, %{name}, %{entity}, %{type}.
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-alarm-warning', 'total-alarm-critical'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-alarm-warning', 'total-alarm-critical'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_ALARMHOST

$fatpacked{"apps/vmware/connector/mode/countvmhost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_COUNTVMHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::countvmhost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{status};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
          { name => 'host', type => 1, cb_prefix_output => 'prefix_host_output', message_multiple => 'All ESX Hosts are ok' },
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'total-on', nlabel => 'host.vm.poweredon.current.count', set => {
                  key_values => [ { name => 'poweredon' }, { name => 'total' } ],
                  output_template => '%s VM(s) poweredon',
                  perfdatas => [
                      { label => 'poweredon', value => 'poweredon_absolute', template => '%s',
                        min => 0, max => 'total_absolute' },
                  ],
              }
          },
          { label => 'total-off', nlabel => 'host.vm.poweredoff.current.count', set => {
                  key_values => [ { name => 'poweredoff' }, { name => 'total' } ],
                  output_template => '%s VM(s) poweredoff',
                  perfdatas => [
                      { label => 'poweredoff', value => 'poweredoff_absolute', template => '%s',
                        min => 0, max => 'total_absolute' },
                  ],
              }
          },
           { label => 'total-suspended', nlabel => 'host.vm.suspended.current.count', set => {
                  key_values => [ { name => 'suspended' }, { name => 'total' } ],
                  output_template => '%s VM(s) suspended',
                  perfdatas => [
                      { label => 'suspended', value => 'suspended_absolute', template => '%s',
                        min => 0, max => 'total_absolute' },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{host} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'on', nlabel => 'host.vm.poweredon.current.count', set => {
                  key_values => [ { name => 'poweredon' }, { name => 'total' } ],
                  output_template => '%s VM(s) poweredon',
                  perfdatas => [
                      { label => 'poweredon', value => 'poweredon_absolute', template => '%s',
                        min => 0, max => 'total_absolute', label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'off', nlabel => 'host.vm.poweredoff.current.count', set => {
                  key_values => [ { name => 'poweredoff' }, { name => 'total' } ],
                  output_template => '%s VM(s) poweredoff',
                  perfdatas => [
                      { label => 'poweredoff', value => 'poweredoff_absolute', template => '%s',
                        min => 0, max => 'total_absolute', label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'suspended', nlabel => 'host.vm.suspended.current.count', set => {
                  key_values => [ { name => 'suspended' }, { name => 'total' } ],
                  output_template => '%s VM(s) suspended',
                  perfdatas => [
                      { label => 'suspended', value => 'suspended_absolute', template => '%s',
                        min => 0, max => 'total_absolute', label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "esx-hostname:s"        => { name => 'esx_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{status} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{global} = { poweredon => 0, poweredoff => 0, suspended => 0, total => 0 };
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'countvmhost');
  
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          $self->{host}->{$host_name} = {
              display => $host_name, 
              state => $response->{data}->{$host_id}->{state},
              poweredon => $response->{data}->{$host_id}->{poweredon},
              poweredoff => $response->{data}->{$host_id}->{poweredoff},
              suspended => $response->{data}->{$host_id}->{suspended},
              total => $response->{data}->{$host_id}->{poweredon} + $response->{data}->{$host_id}->{poweredoff} + $response->{data}->{$host_id}->{suspended},
          };
          $self->{global}->{poweredon} += $response->{data}->{$host_id}->{poweredon} if (defined($response->{data}->{$host_id}->{poweredon}));
          $self->{global}->{poweredoff} += $response->{data}->{$host_id}->{poweredoff} if (defined($response->{data}->{$host_id}->{poweredoff}));
          $self->{global}->{suspended} += $response->{data}->{$host_id}->{suspended} if (defined($response->{data}->{$host_id}->{suspended}));
      }
      
      $self->{global}->{total} = $self->{global}->{poweredon} + $self->{global}->{poweredoff} + $self->{global}->{suspended};
  }
  
  1;
  
  
  =head1 MODE
  
  Check number of vm running/off on ESX hosts.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-on', 'total-off', 'total-suspended', 
  'on', 'off', 'suspended'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-on', 'total-off', 'total-suspended', 
  'on', 'off', 'suspended'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_COUNTVMHOST

$fatpacked{"apps/vmware/connector/mode/cpuhost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_CPUHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::cpuhost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{status};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'host', type => 3, cb_prefix_output => 'prefix_host_output', cb_long_output => 'host_long_output', indent_long_output => '    ', message_multiple => 'All ESX hosts are ok', 
              group => [
                  { name => 'global', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_cpu', cb_prefix_output => 'prefix_global_cpu_output', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'cpu', display_long => 0, cb_prefix_output => 'prefix_cpu_output',  message_multiple => 'All CPUs are ok', type => 1, skipped_code => { -10 => 1 } },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{global_cpu} = [
          { label => 'total-cpu', nlabel => 'host.cpu.utilization.percentage', set => {
                  key_values => [ { name => 'cpu_average' } ],
                  output_template => '%s %%',
                  perfdatas => [
                      { label => 'cpu_total', value => 'cpu_average_absolute', template => '%s', unit => '%', 
                        min => 0, max => 100, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'total-cpu-mhz', nlabel => 'host.cpu.utilization.mhz', set => {
                  key_values => [ { name => 'cpu_average_mhz' }, { name => 'cpu_average_mhz_max' } ],
                  output_template => '%s MHz',
                  perfdatas => [
                      { label => 'cpu_total_MHz', value => 'cpu_average_mhz_absolute', template => '%s', unit => 'MHz', 
                        min => 0, max => 'cpu_average_mhz_max_absolute', label_extra_instance => 1 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{cpu} = [
          { label => 'cpu', nlabel => 'host.core.cpu.utilization.percentage', set => {
                  key_values => [ { name => 'cpu_usage' }, { name => 'display' } ],
                  output_template => 'usage : %s',
                  perfdatas => [
                      { label => 'cpu', value => 'cpu_usage_absolute', template => '%s', unit => '%', 
                        min => 0, max => 100, label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub host_long_output {
      my ($self, %options) = @_;
  
      return "checking host '" . $options{instance_value}->{display} . "'";
  }
  
  sub prefix_global_cpu_output {
      my ($self, %options) = @_;
  
      return "cpu total average : ";
  }
  
  sub prefix_cpu_output {
      my ($self, %options) = @_;
  
      return "cpu '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "esx-hostname:s"        => { name => 'esx_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{status} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'cpuhost');
  
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          $self->{host}->{$host_name} = { display => $host_name, 
              cpu => {}, 
              global => {
                  state => $response->{data}->{$host_id}->{state},    
              },
              global_cpu => {
                  cpu_average => $response->{data}->{$host_id}->{'cpu.usage.average'},
                  cpu_average_mhz => $response->{data}->{$host_id}->{'cpu.usagemhz.average'},
                  cpu_average_mhz_max => $response->{data}->{$host_id}->{numCpuCores} * $response->{data}->{$host_id}->{cpuMhz},
              }, 
          };
          
          foreach my $cpu_id (sort keys %{$response->{data}->{$host_id}->{cpu}}) {
              $self->{host}->{$host_name}->{cpu}->{$cpu_id} = { display => $cpu_id, cpu_usage => $response->{data}->{$host_id}->{cpu}->{$cpu_id} };
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check ESX cpu usage.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-cpu', 'total-cpu-mhz', 'cpu'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-cpu', 'total-cpu-mhz', 'cpu'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_CPUHOST

$fatpacked{"apps/vmware/connector/mode/cpuvm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_CPUVM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::cpuvm;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = '[connection state ' . $self->{result_values}->{connection_state} . '][power state ' . $self->{result_values}->{power_state} . ']';
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{connection_state} = $options{new_datas}->{$self->{instance} . '_connection_state'};
      $self->{result_values}->{power_state} = $options{new_datas}->{$self->{instance} . '_power_state'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'vm', type => 3, cb_prefix_output => 'prefix_vm_output', cb_long_output => 'vm_long_output', indent_long_output => '    ', message_multiple => 'All virtual machines are ok', 
              group => [
                  { name => 'global', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_cpu', cb_prefix_output => 'prefix_global_cpu_output', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'cpu', display_long => 0, cb_prefix_output => 'prefix_cpu_output', message_multiple => 'All CPUs are ok', type => 1, skipped_code => { -10 => 1 } },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'connection_state' }, { name => 'power_state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{global_cpu} = [
          { label => 'total-cpu', nlabel => 'vm.cpu.utilization.percentage', set => {
                  key_values => [ { name => 'cpu_average' } ],
                  output_template => '%s %%',
                  perfdatas => [
                      { label => 'cpu_total', value => 'cpu_average_absolute', template => '%s', unit => '%', 
                        min => 0, max => 100, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'total-cpu-mhz', nlabel => 'vm.cpu.utilization.mhz', set => {
                  key_values => [ { name => 'cpu_average_mhz' } ],
                  output_template => '%s MHz',
                  perfdatas => [
                      { label => 'cpu_total_MHz', value => 'cpu_average_mhz_absolute', template => '%s', unit => 'MHz', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'cpu-ready',  nlabel => 'vm.cpu.ready.percentage', set => {
                  key_values => [ { name => 'cpu_ready' } ],
                  output_template => 'ready %s %%',
                  perfdatas => [
                      { label => 'cpu_ready', value => 'cpu_ready_absolute', template => '%s', unit => '%', 
                        min => 0, max => 100, label_extra_instance => 1 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{cpu} = [
          { label => 'cpu', nlabel => 'vm.core.cpu.utilization.percentage', set => {
                  key_values => [ { name => 'cpu_usage' }, { name => 'display' } ],
                  output_template => 'usage : %s MHz',
                  perfdatas => [
                      { label => 'cpu', value => 'cpu_usage_absolute', template => '%s', unit => 'MHz', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_vm_output {
      my ($self, %options) = @_;
  
      my $msg = "Virtual machine '" . $options{instance_value}->{display} . "'";
      if (defined($options{instance_value}->{config_annotation})) {
          $msg .= ' [annotation: ' . $options{instance_value}->{config_annotation} . ']';
      }
      $msg .= ' : ';
      
      return $msg;
  }
  
  sub vm_long_output {
      my ($self, %options) = @_;
  
      my $msg = "checking virtual machine '" . $options{instance_value}->{display} . "'";
      if (defined($options{instance_value}->{config_annotation})) {
          $msg .= ' [annotation: ' . $options{instance_value}->{config_annotation} . ']';
      }
      
      return $msg;
  }
  
  sub prefix_global_cpu_output {
      my ($self, %options) = @_;
  
      return "cpu total average : ";
  }
  
  sub prefix_cpu_output {
      my ($self, %options) = @_;
  
      return "cpu '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "vm-hostname:s"         => { name => 'vm_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "scope-host:s"          => { name => 'scope_host' },
          "display-description"   => { name => 'display_description' },
          "filter-description:s"  => { name => 'filter_description' },
          "filter-os:s"           => { name => 'filter_os' },
          "filter-uuid:s"         => { name => 'filter_uuid' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{connection_state} !~ /^connected$/i or %{power_state}  !~ /^poweredOn$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{vm} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'cpuvm');
  
      foreach my $vm_id (keys %{$response->{data}}) {
          my $vm_name = $response->{data}->{$vm_id}->{name};
          
          $self->{vm}->{$vm_name} = { display => $vm_name, 
              cpu => {}, 
              global => {
                  connection_state => $response->{data}->{$vm_id}->{connection_state},
                  power_state => $response->{data}->{$vm_id}->{power_state},
              },
              global_cpu => {
                  cpu_average => $response->{data}->{$vm_id}->{'cpu.usage.average'},
                  cpu_average_mhz => $response->{data}->{$vm_id}->{'cpu.usagemhz.average'},
                  cpu_ready => $response->{data}->{$vm_id}->{'cpu_ready'},
              },
          };
          
          if (defined($self->{option_results}->{display_description})) {
              $self->{vm}->{$vm_name}->{config_annotation} = $options{custom}->strip_cr(value => $response->{data}->{$vm_id}->{'config.annotation'});
          }
          
          foreach my $cpu_id (sort keys %{$response->{data}->{$vm_id}->{cpu}}) {
              $self->{vm}->{$vm_name}->{cpu}->{$cpu_id} = { display => $cpu_id, cpu_usage => $response->{data}->{$vm_id}->{cpu}->{$cpu_id} };
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check virtual machine cpu usage.
  
  =over 8
  
  =item B<--vm-hostname>
  
  VM hostname to check.
  If not set, we check all VMs.
  
  =item B<--filter>
  
  VM hostname is a regexp.
  
  =item B<--filter-description>
  
  Filter also virtual machines description (can be a regexp).
  
  =item B<--filter-os>
  
  Filter also virtual machines OS name (can be a regexp).
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--scope-host>
  
  Search in following host(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{connection_state} !~ /^connected$/i or %{power_state}  !~ /^poweredOn$/i').
  Can used special variables like: %{connection_state}, %{power_state}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{connection_state}, %{power_state}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{connection_state}, %{power_state}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-cpu', 'total-cpu-mhz', 'cpu-ready', 'cpu'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-cpu', 'total-cpu-mhz', 'cpu-ready', 'cpu'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_CPUVM

$fatpacked{"apps/vmware/connector/mode/datastorecountvm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_DATASTORECOUNTVM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::datastorecountvm;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'accessible ' . $self->{result_values}->{accessible};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{accessible} = $options{new_datas}->{$self->{instance} . '_accessible'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
          { name => 'datastore', type => 1, cb_prefix_output => 'prefix_datastore_output', message_multiple => 'All Datastores are ok' },
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'total-on', nlabel => 'datastore.vm.poweredon.current.count', set => {
                  key_values => [ { name => 'poweredon' }, { name => 'total' } ],
                  output_template => '%s VM(s) poweredon',
                  perfdatas => [
                      { label => 'poweredon', value => 'poweredon_absolute', template => '%s',
                        min => 0, max => 'total_absolute' },
                  ],
              }
          },
          { label => 'total-off', nlabel => 'datastore.vm.poweredoff.current.count', set => {
                  key_values => [ { name => 'poweredoff' }, { name => 'total' } ],
                  output_template => '%s VM(s) poweredoff',
                  perfdatas => [
                      { label => 'poweredoff', value => 'poweredoff_absolute', template => '%s',
                        min => 0, max => 'total_absolute' },
                  ],
              }
          },
          { label => 'total-suspended', nlabel => 'datastore.vm.suspended.current.count', set => {
                  key_values => [ { name => 'suspended' }, { name => 'total' } ],
                  output_template => '%s VM(s) suspended',
                  perfdatas => [
                      { label => 'suspended', value => 'suspended_absolute', template => '%s',
                        min => 0, max => 'total_absolute' },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{datastore} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'accessible' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'on', nlabel => 'datastore.vm.poweredon.current.count', set => {
                  key_values => [ { name => 'poweredon' }, { name => 'total' } ],
                  output_template => '%s VM(s) poweredon',
                  perfdatas => [
                      { label => 'poweredon', value => 'poweredon_absolute', template => '%s',
                        min => 0, max => 'total_absolute', label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'off', nlabel => 'datastore.vm.poweredoff.current.count', set => {
                  key_values => [ { name => 'poweredoff' }, { name => 'total' } ],
                  output_template => '%s VM(s) poweredoff',
                  perfdatas => [
                      { label => 'poweredoff', value => 'poweredoff_absolute', template => '%s',
                        min => 0, max => 'total_absolute', label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'suspended', nlabel => 'datastore.vm.suspended.current.count', set => {
                  key_values => [ { name => 'suspended' }, { name => 'total' } ],
                  output_template => '%s VM(s) suspended',
                  perfdatas => [
                      { label => 'suspended', value => 'suspended_absolute', template => '%s',
                        min => 0, max => 'total_absolute', label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_datastore_output {
      my ($self, %options) = @_;
  
      return "Datastore '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "datastore-name:s"      => { name => 'datastore_name' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{accessible} !~ /^true|1$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{global} = { poweredon => 0, poweredoff => 0, suspended => 0, total => 0 };
      $self->{datastore} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'datastorecountvm');
  
      foreach my $ds_id (keys %{$response->{data}}) {
          my $ds_name = $response->{data}->{$ds_id}->{name};
          $self->{datastore}->{$ds_name} = {
              display => $ds_name, 
              accessible => $response->{data}->{$ds_id}->{accessible},
              poweredon => $response->{data}->{$ds_id}->{poweredon},
              poweredoff => $response->{data}->{$ds_id}->{poweredoff},
              suspended => $response->{data}->{$ds_id}->{suspended},
              total => $response->{data}->{$ds_id}->{poweredon} + $response->{data}->{$ds_id}->{poweredoff} + $response->{data}->{$ds_id}->{suspended},
          };
          $self->{global}->{poweredon} += $response->{data}->{$ds_id}->{poweredon} if (defined($response->{data}->{$ds_id}->{poweredon}));
          $self->{global}->{poweredoff} += $response->{data}->{$ds_id}->{poweredoff} if (defined($response->{data}->{$ds_id}->{poweredoff}));
          $self->{global}->{suspended} += $response->{data}->{$ds_id}->{suspended} if (defined($response->{data}->{$ds_id}->{suspended}));
      }
      
      $self->{global}->{total} = $self->{global}->{poweredon} + $self->{global}->{poweredoff} + $self->{global}->{suspended};
  }
  
  1;
  
  
  =head1 MODE
  
  Check number of vm running/off on datastores.
  
  =over 8
  
  =item B<--datastore-name>
  
  datastore name to check.
  
  =item B<--filter>
  
  Datastore name is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{accessible} !~ /^true|1$/i').
  Can used special variables like: %{accessible}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{accessible}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{accessible}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-on', 'total-off', 'total-suspended', 
  'on', 'off', 'suspended'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-on', 'total-off', 'total-suspended', 
  'on', 'off', 'suspended'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_DATASTORECOUNTVM

$fatpacked{"apps/vmware/connector/mode/datastorehost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_DATASTOREHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::datastorehost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{status};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'host', type => 3, cb_prefix_output => 'prefix_host_output', cb_long_output => 'host_long_output', indent_long_output => '    ', message_multiple => 'All ESX hosts are ok', 
              group => [
                  { name => 'global', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'datastore', cb_prefix_output => 'prefix_datastore_output',  message_multiple => 'All datastores latencies are ok', type => 1, skipped_code => { -10 => 1 } },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{datastore} = [
          { label => 'read-latency', nlabel => 'host.datastore.latency.read.milliseconds', set => {
                  key_values => [ { name => 'read_latency' }, { name => 'display' } ],
                  output_template => 'read : %s ms',
                  perfdatas => [
                      { label => 'trl', value => 'read_latency_absolute', template => '%s', unit => 'ms', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'write-latency', nlabel => 'host.datastore.latency.write.milliseconds', set => {
                  key_values => [ { name => 'write_latency' }, { name => 'display' } ],
                  output_template => 'write : %s ms',
                  perfdatas => [
                      { label => 'twl', value => 'write_latency_absolute', template => '%s', unit => 'ms', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub host_long_output {
      my ($self, %options) = @_;
  
      return "checking host '" . $options{instance_value}->{display} . "'";
  }
  
  sub prefix_datastore_output {
      my ($self, %options) = @_;
  
      return "datastore '" . $options{instance_value}->{display} . "' latency : ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "esx-hostname:s"        => { name => 'esx_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "datastore-name:s"      => { name => 'datastore_name' },
          "filter-datastore:s"    => { name => 'filter_datastore' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{status} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'datastorehost');
  
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          $self->{host}->{$host_name} = { display => $host_name, 
              datastore => {}, 
              global => {
                  state => $response->{data}->{$host_id}->{state},    
              },
          };
          
          foreach my $ds_id (sort keys %{$response->{data}->{$host_id}->{datastore}}) {
              $self->{host}->{$host_name}->{datastore}->{$ds_id} = {
                  display => $ds_id, 
                  read_latency => $response->{data}->{$host_id}->{datastore}->{$ds_id}->{'datastore.totalReadLatency.average'},
                  write_latency => $response->{data}->{$host_id}->{datastore}->{$ds_id}->{'datastore.totalWriteLatency.average'},
              };
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check ESX datastore latency.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--datastore-name>
  
  Datastore to check.
  If not set, we check all datastores.
  
  =item B<--filter-datastore>
  
  Datastore name is a regexp.
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'read-latency', 'write-latency'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'read-latency', 'write-latency'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_DATASTOREHOST

$fatpacked{"apps/vmware/connector/mode/datastoreio.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_DATASTOREIO';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::datastoreio;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'accessible ' . $self->{result_values}->{accessible};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{accessible} = $options{new_datas}->{$self->{instance} . '_accessible'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
          { name => 'datastore', type => 1, cb_prefix_output => 'prefix_datastore_output', message_multiple => 'All Datastores are ok' },
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'total-read', nlabel => 'datastore.read.usage.bytespersecond', set => {
                  key_values => [ { name => 'read' } ],
                  output_template => 'Total rate of reading data: %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'total_read_rate', value => 'read_absolute', template => '%s',
                        unit => 'B/s', min => 0 },
                  ],
              }
          },
          { label => 'total-write', nlabel => 'datastore.write.usage.bytespersecond', set => {
                  key_values => [ { name => 'write' } ],
                  output_template => 'Total rate of writing data: %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'total_write_rate', value => 'write_absolute', template => '%s',
                        unit => 'B/s', min => 0 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{datastore} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'accessible' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'read', nlabel => 'datastore.read.usage.bytespersecond', set => {
                  key_values => [ { name => 'read' } ],
                  output_template => 'rate of reading data: %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'read_rate', value => 'read_absolute', template => '%s',
                        unit => 'B/s', min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'write', nlabel => 'datastore.write.usage.bytespersecond', set => {
                  key_values => [ { name => 'write' } ],
                  output_template => 'rate of writing data: %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'write_rate', value => 'write_absolute', template => '%s',
                        unit => 'B/s', min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_datastore_output {
      my ($self, %options) = @_;
  
      return "Datastore '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "datastore-name:s"      => { name => 'datastore_name' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{accessible} !~ /^true|1$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{global} = { read => 0, write => 0 };
      $self->{datastore} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'datastoreio');
  
      foreach my $ds_id (keys %{$response->{data}}) {
          my $ds_name = $response->{data}->{$ds_id}->{name};
          $self->{datastore}->{$ds_name} = {
              display => $ds_name, 
              accessible => $response->{data}->{$ds_id}->{accessible},
              read => $response->{data}->{$ds_id}->{'datastore.read.average'},
              write => $response->{data}->{$ds_id}->{'datastore.write.average'},
          };
          $self->{global}->{read} += $response->{data}->{$ds_id}->{'datastore.read.average'} if (defined($response->{data}->{$ds_id}->{'datastore.read.average'}));
          $self->{global}->{write} += $response->{data}->{$ds_id}->{'datastore.write.average'} if (defined($response->{data}->{$ds_id}->{'datastore.write.average'}));
      }    
  }
  
  1;
  
  
  =head1 MODE
  
  Check datastore IO.
  
  =over 8
  
  =item B<--datastore-name>
  
  datastore name to list.
  
  =item B<--filter>
  
  Datastore name is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{accessible} !~ /^true|1$/i').
  Can used special variables like: %{accessible}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{accessible}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{accessible}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-read', 'total-write', 'read', 'write'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-read', 'total-write', 'read', 'write'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_DATASTOREIO

$fatpacked{"apps/vmware/connector/mode/datastoreiops.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_DATASTOREIOPS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::datastoreiops;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'accessible ' . $self->{result_values}->{accessible};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{accessible} = $options{new_datas}->{$self->{instance} . '_accessible'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'datastore', type => 3, cb_prefix_output => 'prefix_datastore_output', cb_long_output => 'datastore_long_output', indent_long_output => '    ', message_multiple => 'All datastores are ok', 
              group => [
                  { name => 'global', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_iops', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'vm', cb_prefix_output => 'prefix_vm_output',  message_multiple => 'All virtual machines IOPs are ok', type => 1, skipped_code => { -10 => 1 } },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'accessible' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{global_iops} = [
          { label => 'read', nlabel => 'datastore.read.usage.iops', set => {
                  key_values => [ { name => 'read' } ],
                  output_template => '%s read iops',
                  perfdatas => [
                      { label => 'riops', value => 'read_absolute', template => '%s', unit => 'iops', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'write', nlabel => 'datastore.write.usage.iops', set => {
                  key_values => [ { name => 'write' } ],
                  output_template => '%s write iops',
                  perfdatas => [
                      { label => 'wiops', value => 'write_absolute', template => '%s', unit => 'iops', 
                        min => 0, max => 'write_absolute', label_extra_instance => 1 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{vm} = [
          { label => 'read-vm', nlabel => 'datastore.vm.read.usage.iops', set => {
                  key_values => [ { name => 'read' } ],
                  output_template => '%s read iops',
                  perfdatas => [
                      { label => 'vm_riops', value => 'read_absolute', template => '%s', unit => 'iops', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'write-vm', nlabel => 'datastore.vm.write.usage.iops', set => {
                  key_values => [ { name => 'write' } ],
                  output_template => '%s write iops',
                  perfdatas => [
                      { label => 'vm_wiops', value => 'write_absolute', template => '%s', unit => 'iops', 
                        min => 0, max => 'write_absolute', label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_datastore_output {
      my ($self, %options) = @_;
  
      return "Datastore '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub datastore_long_output {
      my ($self, %options) = @_;
  
      return "checking datastore '" . $options{instance_value}->{display} . "'";
  }
  
  sub prefix_vm_output {
      my ($self, %options) = @_;
  
      return "virtual machine '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "datastore-name:s"      => { name => 'datastore_name' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "detail-iops-min:s"     => { name => 'detail_iops_min', default => 50 },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{accessible} !~ /^true|1$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{datastore} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'datastoreiops');
  
      if ($response->{code} == 200) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => $response->{short_message});
          return ;
          
      }
  
      foreach my $ds_id (keys %{$response->{data}}) {
          my $ds_name = $response->{data}->{$ds_id}->{name};
          $self->{datastore}->{$ds_name} = { display => $ds_name, 
              vm => {}, 
              global => {
                  accessible => $response->{data}->{$ds_id}->{accessible},    
              },
              global_iops => {
                  write => $response->{data}->{$ds_id}->{'disk.numberWrite.summation'},
                  read => $response->{data}->{$ds_id}->{'disk.numberRead.summation'},
              }, 
          };
          
          foreach my $vm_name (sort keys %{$response->{data}->{$ds_id}->{vm}}) {
              $self->{datastore}->{$ds_name}->{vm}->{$vm_name} = { 
                  display => $vm_name, 
                  write => $response->{data}->{$ds_id}->{vm}->{$vm_name}->{'disk.numberWrite.summation'},
                  read => $response->{data}->{$ds_id}->{vm}->{$vm_name}->{'disk.numberRead.summation'},
              };
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check datastore IOPs.
  
  =over 8
  
  =item B<--datastore-name>
  
  datastore name to list.
  
  =item B<--filter>
  
  Datastore name is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--detail-iops-min>
  
  Only display VMs with iops higher value (default: 50).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{accessible} !~ /^true|1$/i').
  Can used special variables like: %{accessible}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{accessible}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{accessible}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'read', 'write', 'read-vm', 'write-vm'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'read', 'write', 'read-vm', 'write-vm'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_DATASTOREIOPS

$fatpacked{"apps/vmware/connector/mode/datastoresnapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_DATASTORESNAPSHOT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::datastoresnapshot;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'accessible ' . $self->{result_values}->{accessible};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{accessible} = $options{new_datas}->{$self->{instance} . '_accessible'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'datastore', type => 3, cb_prefix_output => 'prefix_datastore_output', cb_long_output => 'datastore_long_output', indent_long_output => '    ', message_multiple => 'All datastores are ok', 
              group => [
                  { name => 'global', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_snapshot', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'files', cb_prefix_output => 'prefix_files_output',  message_multiple => 'All snapshot files are ok', type => 1, skipped_code => { -10 => 1 } },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'accessible' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{global_snapshot} = [
          { label => 'total', nlabel => 'datastore.snapshots.usage.bytes', set => {
                  key_values => [ { name => 'total' } ],
                  output_template => 'total snapshots [size = %s %s]',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'total_size', value => 'total_absolute', template => '%s', unit => 'B', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{files} = [
          { label => 'snapshot', nlabel => 'datastore.snapshot.usage.bytes', set => {
                  key_values => [ { name => 'total' } ],
                  output_template => '[size = %s %s]',
                  output_change_bytes => 1,
                  closure_custom_perfdata => sub { return 0; },
              }
          },
      ];
  }
  
  sub prefix_datastore_output {
      my ($self, %options) = @_;
  
      return "Datastore '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub datastore_long_output {
      my ($self, %options) = @_;
  
      return "checking datastore '" . $options{instance_value}->{display} . "'";
  }
  
  sub prefix_files_output {
      my ($self, %options) = @_;
  
      return sprintf("file snapshot [%s]=>[%s] ", $options{instance_value}->{folder_path}, $options{instance_value}->{path});
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "datastore-name:s"      => { name => 'datastore_name' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{accessible} !~ /^true|1$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{datastore} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'datastoresnapshot');
  
      my $i = 0;
      foreach my $ds_id (keys %{$response->{data}}) {
          my $ds_name = $response->{data}->{$ds_id}->{name};
          $self->{datastore}->{$ds_name} = { display => $ds_name, 
              files => {}, 
              global => {
                  accessible => $response->{data}->{$ds_id}->{accessible},    
              },
              global_snapshot => {
                  total => 0
              }, 
          };
          
          foreach (@{$response->{data}->{$ds_id}->{snapshost}}) {
              $self->{datastore}->{$ds_name}->{files}->{$i} = { 
                  folder_path => $_->{folder_path},
                  path        => $_->{path},
                  total       => $_->{size},  
              };
              $self->{datastore}->{$ds_name}->{global_snapshot}->{total} += $_->{size};
              $i++;
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check snapshots usage on datastores.
  
  =over 8
  
  =item B<--datastore-name>
  
  datastore name to list.
  
  =item B<--filter>
  
  Datastore name is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{accessible} !~ /^true|1$/i').
  Can used special variables like: %{accessible}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{accessible}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{accessible}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total', 'snapshot'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total', 'snapshot'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_DATASTORESNAPSHOT

$fatpacked{"apps/vmware/connector/mode/datastoreusage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_DATASTOREUSAGE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::datastoreusage;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'accessible ' . $self->{result_values}->{accessible};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{accessible} = $options{new_datas}->{$self->{instance} . '_accessible'};
      return 0;
  }
  
  sub custom_usage_perfdata {
      my ($self, %options) = @_;
  
      my ($label, $nlabel) = ('used', $self->{nlabel});
      my $value_perf = $self->{result_values}->{used};
      if (defined($self->{instance_mode}->{option_results}->{free})) {
          ($label, $nlabel) = ('free', 'datastore.space.free.bytes');
          $value_perf = $self->{result_values}->{free};
      }
  
      my %total_options = ();
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $total_options{total} = $self->{result_values}->{total};
          $total_options{cast_int} = 1;
      }
  
      $self->{output}->perfdata_add(
          label => $label, unit => 'B',
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
          nlabel => $nlabel,
          value => $value_perf,
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}, %total_options),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}, %total_options),
          min => 0, max => $self->{result_values}->{total}
      );
  }
  
  sub custom_usage_threshold {
      my ($self, %options) = @_;
  
      my ($exit, $threshold_value);
      $threshold_value = $self->{result_values}->{used};
      $threshold_value = $self->{result_values}->{free} if (defined($self->{instance_mode}->{option_results}->{free}));
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $threshold_value = $self->{result_values}->{prct_used};
          $threshold_value = $self->{result_values}->{prct_free} if (defined($self->{instance_mode}->{option_results}->{free}));
      }
      $exit = $self->{perfdata}->threshold_check(value => $threshold_value, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' } ]);
      return $exit;
  }
  
  sub custom_usage_output {
      my ($self, %options) = @_;
  
      my ($total_size_value, $total_size_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{total});
      my ($total_used_value, $total_used_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{used});
      my ($total_free_value, $total_free_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{free});
      my $msg = sprintf("Usage Total: %s Used: %s (%.2f%%) Free: %s (%.2f%%)",
                     $total_size_value . " " . $total_size_unit,
                     $total_used_value . " " . $total_used_unit, $self->{result_values}->{prct_used},
                     $total_free_value . " " . $total_free_unit, $self->{result_values}->{prct_free});
      return $msg;
  }
  
  sub custom_usage_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_total'};
      
      if ($self->{result_values}->{total} <= 0) {
          $self->{error_msg} = 'size is 0';
          return -20;
      }
      
      $self->{result_values}->{free} = $options{new_datas}->{$self->{instance} . '_free'};
      $self->{result_values}->{used} = $self->{result_values}->{total} - $self->{result_values}->{free};
      $self->{result_values}->{prct_used} = $self->{result_values}->{used} * 100 / $self->{result_values}->{total};
      $self->{result_values}->{prct_free} = 100 - $self->{result_values}->{prct_used};
  
      return 0;
  }
  
  sub custom_provisioned_output {
      my ($self, %options) = @_;
  
      my ($total_uncomitted_value, $total_uncommitted_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{total_uncommitted});
      my $msg = sprintf("Provisioned: %s (%.2f%%)",
                     $total_uncomitted_value . " " . $total_uncommitted_unit,
                     $self->{result_values}->{prct_uncommitted});
      return $msg;
  }
  
  sub custom_provisioned_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_total'};
  
      if ($self->{result_values}->{total} <= 0) {
          return -10;
      }
      
      $self->{result_values}->{total_uncommitted} = 
          ($self->{result_values}->{total} - $options{new_datas}->{$self->{instance} . '_free'}) + $options{new_datas}->{$self->{instance} . '_uncommitted'};
      $self->{result_values}->{prct_uncommitted} = $self->{result_values}->{total_uncommitted} * 100 / $self->{result_values}->{total};
  
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'datastore', type => 1, cb_prefix_output => 'prefix_datastore_output', message_multiple => 'All datastores are ok', skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{datastore} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'accessible' }, { name => 'display' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'usage', nlabel => 'datastore.space.usage.bytes', set => {
                  key_values => [ { name => 'display' }, { name => 'free' }, { name => 'total' } ],
                  closure_custom_calc => $self->can('custom_usage_calc'),
                  closure_custom_output => $self->can('custom_usage_output'),
                  closure_custom_perfdata => $self->can('custom_usage_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_usage_threshold'),
              }
          },
          { label => 'provisioned', nlabel => 'datastore.space.provisioned.bytes', set => {
                  key_values => [ { name => 'display' }, { name => 'uncommitted' }, { name => 'total' }, { name => 'free' } ],
                  closure_custom_calc => $self->can('custom_provisioned_calc'),
                  closure_custom_output => $self->can('custom_provisioned_output'),
                  threshold_use => 'prct_uncommitted',
                  perfdatas => [
                      { label => 'provisioned', value => 'total_uncommitted', template => '%s', unit => 'B', 
                        min => 0, max => 'total', label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_datastore_output {
      my ($self, %options) = @_;
  
      return "Datastore '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "datastore-name:s"      => { name => 'datastore_name' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "units:s"               => { name => 'units', default => '%' },
          "free"                  => { name => 'free' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{accessible} !~ /^true|1$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
      if (!defined($self->{option_results}->{units}) || $self->{option_results}->{units} !~ /^(%|B)$/) {
          $self->{output}->add_option_msg(short_msg => "Wrong units option '" . $self->{option_results}->{units} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{datastore} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'datastoreusage');
      foreach my $ds_id (keys %{$response->{data}}) {
          my $ds_name = $response->{data}->{$ds_id}->{name};
          $self->{datastore}->{$ds_name} = { 
              display => $ds_name, 
              accessible => $response->{data}->{$ds_id}->{accessible},
              free => $response->{data}->{$ds_id}->{free},
              total => $response->{data}->{$ds_id}->{size},
              uncommitted => $response->{data}->{$ds_id}->{uncommitted},
          };        
      }    
  }
  
  1;
  
  
  =head1 MODE
  
  Check datastore usage.
  
  =over 8
  
  =item B<--datastore-name>
  
  datastore name to list.
  
  =item B<--filter>
  
  Datastore name is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--units>
  
  Units of thresholds (Default: '%') ('%', 'B').
  
  =item B<--free>
  
  Thresholds are on free space left.
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{accessible} !~ /^true|1$/i').
  Can used special variables like: %{accessible}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{accessible}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{accessible}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'usage', 'provisioned'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'usage', 'provisioned'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_DATASTOREUSAGE

$fatpacked{"apps/vmware/connector/mode/datastorevm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_DATASTOREVM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::datastorevm;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = '[connection state ' . $self->{result_values}->{connection_state} . '][power state ' . $self->{result_values}->{power_state} . ']';
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{connection_state} = $options{new_datas}->{$self->{instance} . '_connection_state'};
      $self->{result_values}->{power_state} = $options{new_datas}->{$self->{instance} . '_power_state'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'vm', type => 3, cb_prefix_output => 'prefix_vm_output', cb_long_output => 'vm_long_output', indent_long_output => '    ', message_multiple => 'All virtual machines are ok', 
              group => [
                  { name => 'global', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_vm', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'datastore', cb_prefix_output => 'prefix_datastore_output',  message_multiple => 'All datastores are ok', type => 1, skipped_code => { -10 => 1 } },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'connection_state' }, { name => 'power_state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{global_vm} = [
          { label => 'max-total-latency', nlabel => 'vm.datastore.latency.max.milliseconds', set => {
                  key_values => [ { name => 'total_latency' } ],
                  output_template => 'max total latency is %s ms',
                  perfdatas => [
                      { label => 'max_total_latency', value => 'total_latency_absolute', template => '%s', unit => 'ms', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{datastore} = [
          { label => 'read', nlabel => 'vm.datastore.read.usage.iops', set => {
                  key_values => [ { name => 'read' } ],
                  output_template => '%s read iops',
                  perfdatas => [
                      { label => 'riops', value => 'read_absolute', template => '%s', unit => 'iops', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'write', nlabel => 'vm.datastore.write.usage.iops', set => {
                  key_values => [ { name => 'write' } ],
                  output_template => '%s write iops',
                  perfdatas => [
                      { label => 'wiops', value => 'write_absolute', template => '%s', unit => 'iops', 
                        min => 0, max => 'write_absolute', label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_vm_output {
      my ($self, %options) = @_;
  
      my $msg = "Virtual machine '" . $options{instance_value}->{display} . "'";
      if (defined($options{instance_value}->{config_annotation})) {
          $msg .= ' [annotation: ' . $options{instance_value}->{config_annotation} . ']';
      }
      $msg .= ' : ';
      
      return $msg;
  }
  
  sub vm_long_output {
      my ($self, %options) = @_;
  
      my $msg = "checking virtual machine '" . $options{instance_value}->{display} . "'";
      if (defined($options{instance_value}->{config_annotation})) {
          $msg .= ' [annotation: ' . $options{instance_value}->{config_annotation} . ']';
      }
      
      return $msg;
  }
  
  sub prefix_datastore_output {
      my ($self, %options) = @_;
  
      return "datastore '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "vm-hostname:s"         => { name => 'vm_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "scope-host:s"          => { name => 'scope_host' },
          "filter-description:s"  => { name => 'filter_description' },
          "filter-os:s"           => { name => 'filter_os' },
          "filter-uuid:s"         => { name => 'filter_uuid' },
          "display-description"   => { name => 'display_description' },
          "datastore-name:s"      => { name => 'datastore_name' },
          "filter-datastore:s"    => { name => 'filter_datastore' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{connection_state} !~ /^connected$/i or %{power_state}  !~ /^poweredOn$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{vm} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'datastorevm');
  
      foreach my $vm_id (keys %{$response->{data}}) {
          my $vm_name = $response->{data}->{$vm_id}->{name};
          
          $self->{vm}->{$vm_name} = { display => $vm_name, 
              datastore => {}, 
              global => {
                  connection_state => $response->{data}->{$vm_id}->{connection_state},
                  power_state => $response->{data}->{$vm_id}->{power_state},    
              },
              global_vm => {
                  total_latency => $response->{data}->{$vm_id}->{'disk.maxTotalLatency.latest'},
              },
          };
          
          if (defined($self->{option_results}->{display_description})) {
              $self->{vm}->{$vm_name}->{config_annotation} = $options{custom}->strip_cr(value => $response->{data}->{$vm_id}->{'config.annotation'});
          }
          
          foreach my $ds_name (sort keys %{$response->{data}->{$vm_id}->{datastore}}) {
              $self->{vm}->{$vm_name}->{datastore}->{$ds_name} = { display => $ds_name, 
                  read => $response->{data}->{$vm_id}->{datastore}->{$ds_name}->{'disk.numberRead.summation'},
                  write => $response->{data}->{$vm_id}->{datastore}->{$ds_name}->{'disk.numberWrite.summation'},
              };
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check virtual machine IOPs on datastore(s).
  
  =over 8
  
  =item B<--vm-hostname>
  
  VM hostname to check.
  If not set, we check all VMs.
  
  =item B<--filter>
  
  VM hostname is a regexp.
  
  =item B<--filter-description>
  
  Filter also virtual machines description (can be a regexp).
  
  =item B<--filter-os>
  
  Filter also virtual machines OS name (can be a regexp).
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--scope-host>
  
  Search in following host(s) (can be a regexp).
  
  =item B<--datastore-name>
  
  Datastore to check.
  If not set, we check all datastores.
  
  =item B<--filter-datastore>
  
  Datastore name is a regexp.
  
  =item B<--display-description>
  
  Display virtual machine description.
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{connection_state} !~ /^connected$/i or %{power_state}  !~ /^poweredOn$/i').
  Can used special variables like: %{connection_state}, %{power_state}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like:  %{connection_state}, %{power_state}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like:  %{connection_state}, %{power_state}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'max-total-latency', 'read', 'write'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'max-total-latency', 'read', 'write'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_DATASTOREVM

$fatpacked{"apps/vmware/connector/mode/devicevm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_DEVICEVM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::devicevm;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = '[connection state ' . $self->{result_values}->{connection_state} . '][power state ' . $self->{result_values}->{power_state} . ']';
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{connection_state} = $options{new_datas}->{$self->{instance} . '_connection_state'};
      $self->{result_values}->{power_state} = $options{new_datas}->{$self->{instance} . '_power_state'};
      return 0;
  }
  
  sub custom_device_output {
      my ($self, %options) = @_;
  
      my $msg = sprintf("%s %s device connected",  $self->{result_values}->{device_connected_absolute}, $self->{instance_mode}->{option_results}->{device});
      return $msg;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
          { name => 'vm', type => 1, cb_prefix_output => 'prefix_vm_output', message_multiple => 'All virtual machines are ok' },
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'total-device-connected', nlabel => 'vm.devices.connected.count', set => {
                  key_values => [ { name => 'device_connected' } ],
                  closure_custom_output => $self->can('custom_device_output'),
                  perfdatas => [
                      { label => 'total_device_connected', value => 'device_connected_absolute', template => '%s',
                        min => 0 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{vm} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'connection_state' }, { name => 'power_state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'device-connected', nlabel => 'vm.devices.connected.count', set => {
                  key_values => [ { name => 'device_connected' }, { name => 'display' } ],
                  oclosure_custom_output => $self->can('custom_device_output'),
                  perfdatas => [
                      { label => 'device_connected', value => 'device_connected_absolute', template => '%s',
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_vm_output {
      my ($self, %options) = @_;
  
      my $msg = "Virtual machine '" . $options{instance_value}->{display} . "'";
      if (defined($options{instance_value}->{config_annotation})) {
          $msg .= ' [annotation: ' . $options{instance_value}->{config_annotation} . ']';
      }
      $msg .= ' : ';
      
      return $msg;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "vm-hostname:s"         => { name => 'vm_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "scope-host:s"          => { name => 'scope_host' },
          "filter-description:s"  => { name => 'filter_description' },
          "filter-os:s"           => { name => 'filter_os' },
          "filter-uuid:s"         => { name => 'filter_uuid' },
          "display-description"   => { name => 'display_description' },
          "device:s"              => { name => 'device' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{connection_state} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
      if (!defined($self->{option_results}->{device}) || $self->{option_results}->{device} eq '') {
          $self->{output}->add_option_msg(short_msg => "Please set device option.");
          $self->{output}->option_exit();
      }
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{global} = { device_connected => 0 };
      $self->{vm} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'devicevm');
  
      foreach my $vm_id (keys %{$response->{data}}) {
          my $vm_name = $response->{data}->{$vm_id}->{name};
          $self->{vm}->{$vm_name} = {
              display => $vm_name, 
              connection_state => $response->{data}->{$vm_id}->{connection_state},
              power_state => $response->{data}->{$vm_id}->{power_state},
              device_connected => $response->{data}->{$vm_id}->{total_device_connected},
          };
          
          if (defined($self->{option_results}->{display_description})) {
              $self->{vm}->{$vm_name}->{config_annotation} = $options{custom}->strip_cr(value => $response->{data}->{$vm_id}->{'config.annotation'});
          }
          
          $self->{global}->{device_connected} += $self->{vm}->{$vm_name}->{device_connected};
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check virtual machine device connected.
  
  =over 8
  
  =item B<--vm-hostname>
  
  VM hostname to check.
  If not set, we check all VMs.
  
  =item B<--filter>
  
  VM hostname is a regexp.
  
  =item B<--filter-description>
  
  Filter also virtual machines description (can be a regexp).
  
  =item B<--filter-os>
  
  Filter also virtual machines OS name (can be a regexp).
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--scope-host>
  
  Search in following host(s) (can be a regexp).
  
  =item B<--display-description>
  
  Display virtual machine description.
  
  =item B<--device>
  
  Device to check (Required) (Example: --device='VirtualCdrom').
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{connection_state} !~ /^connected$/i').
  Can used special variables like: %{connection_state}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{connection_state}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{connection_state}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-device-connected', 'device-connected'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-device-connected', 'device-connected'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_DEVICEVM

$fatpacked{"apps/vmware/connector/mode/discovery.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_DISCOVERY';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::discovery;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  use JSON::XS;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "resource-type:s"   => { name => 'resource_type' },
          "prettify"          => { name => 'prettify' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub run {
      my ($self, %options) = @_;
  
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'discovery', force_response => 1);
      
      my $encoded_data;
      eval {
          if (defined($self->{option_results}->{prettify})) {
              $encoded_data = JSON::XS->new->utf8->pretty->encode($response->{data});
          } else {
              $encoded_data = JSON::XS->new->utf8->encode($response->{data});
          }
      };
      if ($@) {
          $encoded_data = '{"code":"encode_error","message":"Cannot encode discovered data into JSON format"}';
      }
  
      $self->{output}->output_add(short_msg => $encoded_data);
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1);
  }
  
  1;
  
  
  =head1 MODE
  
  Resources discovery.
  
  =over 8
  
  =item B<--resource-type>
  
  Choose the type of resources
  to discover (Can be: 'esx', 'vm') (Mandatory).
  
  =item B<--prettify>
  
  Prettify JSON output.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_DISCOVERY

$fatpacked{"apps/vmware/connector/mode/getmap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_GETMAP';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::getmap;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                    "esx-hostname:s"          => { name => 'esx_hostname' },
                                    "filter"                  => { name => 'filter' },
                                    "scope-datacenter:s"      => { name => 'scope_datacenter' },
                                    "scope-cluster:s"         => { name => 'scope_cluster' },
                                    "vm-no"                   => { name => 'vm_no' },
                                  });
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub run {
      my ($self, %options) = @_;
  
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'getmap');
      
      foreach my $host_id (sort { $response->{data}->{$a}->{name} cmp $response->{data}->{$b}->{name} } keys %{$response->{data}}) {
          $self->{output}->output_add(long_msg => sprintf("  %s [v%s] %s", $response->{data}->{$host_id}->{name}, 
              $response->{data}->{$host_id}->{version}, 
              defined($self->{option_results}->{vm_no}) ? '' : ':'));
  
          foreach my $vm_id (sort { $response->{data}->{$host_id}->{vm}->{$a}->{name} cmp $response->{data}->{$host_id}->{vm}->{$b}->{name} } keys %{$response->{data}->{$host_id}->{vm}}) {
              $self->{output}->output_add(long_msg => sprintf("      %s [%s]", 
                                                              $response->{data}->{$host_id}->{vm}->{$vm_id}->{name}, $response->{data}->{$host_id}->{vm}->{$vm_id}->{power_state}));
          }
      }
  
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'List ESX host(s):');
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  List ESX hosts and Virtual machines.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to list.
  If not set, we list all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--vm-no>
  
  Don't list virtual machines.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_GETMAP

$fatpacked{"apps/vmware/connector/mode/healthhost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_HEALTHHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::healthhost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{status};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      return 0;
  }
  
  sub custom_summary_output {
      my ($self, %options) = @_;
  
      my $msg;
      if ($self->{result_values}->{type_absolute} ne '') {
          $msg = $self->{result_values}->{type_absolute} . " sensor " . $self->{result_values}->{name_absolute} . ": ". $self->{result_values}->{summary_absolute};
      } else {
          $msg = $self->{result_values}->{name_absolute} . ": ". $self->{result_values}->{summary_absolute};
      }
      return $msg;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
          { name => 'host', type => 3, cb_prefix_output => 'prefix_host_output', cb_long_output => 'host_long_output', indent_long_output => '    ', message_multiple => 'All ESX hosts are ok', 
              group => [
                  { name => 'global_host', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_problems', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_summary', type => 1 },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'total-problems', nlabel => 'host.health.problems.current.count', set => {
                  key_values => [ { name => 'total_problems' }, { name => 'total' } ],
                  output_template => '%s total health issue(s) found',
                  perfdatas => [
                      { label => 'total_problems', value => 'total_problems_absolute', template => '%s',
                        min => 0, max => 'total_absolute' },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{global_host} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{global_problems} = [
          { label => 'ok', threshold => 0, set => {
                  key_values => [ { name => 'ok' } ],
                  output_template => '%s health checks are green',
                  closure_custom_perfdata => sub { return 0; },
              }
          },
          { label => 'problems', nlabel => 'host.health.problems.current.count', set => {
                  key_values => [ { name => 'total_problems' }, { name => 'total' } ],
                  output_template => '%s total health issue(s) found',
                  perfdatas => [
                      { label => 'problems', value => 'total_problems_absolute', template => '%s',
                        min => 0, max => 'total_absolute', label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'problems-yellow', nlabel => 'host.health.yellow.current.count', set => {
                  key_values => [ { name => 'yellow' }, { name => 'total' } ],
                  output_template => '%s yellow health issue(s) found',
                  perfdatas => [
                      { label => 'problems_yellow', value => 'yellow_absolute', template => '%s',
                        min => 0, max => 'total_absolute', label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'problems-red', nlabel => 'host.health.red.current.count', set => {
                  key_values => [ { name => 'red' }, { name => 'total' } ],
                  output_template => '%s red health issue(s) found',
                  perfdatas => [
                      { label => 'problems_red', value => 'red_absolute', template => '%s',
                        min => 0, max => 'total_absolute', label_extra_instance => 1 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{global_summary} = [
          { label => 'global-summary', threshold => 0, set => {
                  key_values => [ { name => 'type' }, { name => 'name' }, { name => 'summary' } ],
                  closure_custom_output => $self->can('custom_summary_output'),
                  closure_custom_perfdata => sub { return 0; },
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub host_long_output {
      my ($self, %options) = @_;
  
      return "checking host '" . $options{instance_value}->{display} . "'";
  }
  
  sub prefix_global_cpu_output {
      my ($self, %options) = @_;
  
      return "cpu total average : ";
  }
  
  sub prefix_cpu_output {
      my ($self, %options) = @_;
  
      return "cpu '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "esx-hostname:s"        => { name => 'esx_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "storage-status"        => { name => 'storage_status' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{status} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{global} = { total_problems => 0, total => 0 };
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'healthhost');
  
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          $self->{host}->{$host_name} = { display => $host_name, 
              global_host => {
                  state => $response->{data}->{$host_id}->{state},    
              },
              global_summary => {},
              global_problems => {
                  ok => 0, total_problems => 0, red => 0, yellow => 0, total => 0,
              }, 
          };
          
          my $i = 0;
          foreach (('memory_info', 'cpu_info', 'sensor_info', 'storage_info')) {
              if (defined($response->{data}->{$host_id}->{$_})) {
                  foreach my $entry (@{$response->{data}->{$host_id}->{$_}}) {
                      my $status = 'ok';
                      $status = lc($1) if ($entry->{status} =~ /(yellow|red)/i);
                      $self->{host}->{$host_name}->{global_problems}->{$status}++;
                      $self->{host}->{$host_name}->{global_problems}->{total}++;
                      if ($status eq 'ok') {
                          $self->{host}->{$host_name}->{global_problems}->{total_problems}++ 
                      } else {
                          $self->{host}->{$host_name}->{global_summary}->{$i} = {
                              type => defined($entry->{type}) ? $entry->{type} : '',
                              name => $entry->{name},
                              summary => $entry->{summary},
                          };
                      }
                  }
  
                  $i++;
              }
          }
          
          $self->{global}->{total_problems} += $self->{host}->{$host_name}->{global_problems}->{red} + $self->{host}->{$host_name}->{global_problems}->{yellow};
          $self->{global}->{total} +=  $self->{host}->{$host_name}->{global_problems}->{total};
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check health of ESX hosts.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--storage-status>
  
  Check storage(s) status.
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-problems', 'problems', 'problems-yellow', 'problems-red'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-problems', 'problems', 'problems-yellow', 'problems-red'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_HEALTHHOST

$fatpacked{"apps/vmware/connector/mode/limitvm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_LIMITVM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::limitvm;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_limit_output {
      my ($self, %options) = @_;
      
      my $msg;
      if ($self->{result_values}->{limit} != -1) {
          $msg = sprintf("%s limit set", $self->{result_values}->{label});
      } else {
          $msg = sprintf("no %s limit set", $self->{result_values}->{label});
      }
  
      return $msg;
  }
  
  sub custom_limit_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{limit} = $options{new_datas}->{$self->{instance} . '_'. $options{extra_options}->{label_ref} . '_limit'};
      $self->{result_values}->{label} = $options{extra_options}->{label_ref};
      $self->{result_values}->{connection_state} = $options{new_datas}->{$self->{instance} . '_connection_state'};
      $self->{result_values}->{power_state} = $options{new_datas}->{$self->{instance} . '_power_state'};
      $self->{result_values}->{name} = $options{new_datas}->{$self->{instance} . '_name'};
      
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'cpu_alarms', type => 2, cb_long_output => 'cpu_long_output', message_multiple => '0 cpu limit problem(s) detected', format_output => '%s cpu limit problem(s) detected', display_counter_problem => { label => 'cpu_alerts', nlabel => 'vm.limit.cpu.alerts.count', min => 0 },
            group => [ { name => 'cpu_alarm', cb_prefix_output => 'prefix_vm_output', skipped_code => { -11 => 1 } } ] 
          },
          { name => 'memory_alarms', type => 2,cb_long_output => 'memory_long_output',  message_multiple => '0 memory limit problem(s) detected', format_output => '%s memory limit problem(s) detected', display_counter_problem => { label => 'memory_alerts', nlabel => 'vm.limit.memory.alerts.count', min => 0 },
            group => [ { name => 'memory_alarm', cb_prefix_output => 'prefix_vm_output', skipped_code => { -11 => 1 } } ] 
          },
          { name => 'disk_alarms', type => 2, cb_long_output => 'disk_long_output', message_multiple => '0 disk limit problem(s) detected', format_output => '%s disk limit problem(s) detected', display_counter_problem => { label => 'disk_alerts', nlabel => 'vm.limit.disk.alerts.count', min => 0 },
            group => [ { name => 'disk_alarm', cb_prefix_output => 'prefix_vm_output', skipped_code => { -11 => 1 } } ] 
          },
      ];
      
      $self->{maps_counters}->{cpu_alarm} = [
          { label => 'cpu-status', threshold => 0, set => {
                  key_values => [ { name => 'name' }, { name => 'connection_state' }, { name => 'power_state' }, { name => 'cpu_limit' } ],
                  closure_custom_calc => $self->can('custom_limit_calc'), closure_custom_calc_extra_options => { label_ref => 'cpu' },
                  closure_custom_output => $self->can('custom_limit_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      $self->{maps_counters}->{memory_alarm} = [
          { label => 'memory-status', threshold => 0, set => {
                  key_values => [ { name => 'name' }, { name => 'connection_state' }, { name => 'power_state' }, { name => 'memory_limit' } ],
                  closure_custom_calc => $self->can('custom_limit_calc'), closure_custom_calc_extra_options => { label_ref => 'memory' },
                  closure_custom_output => $self->can('custom_limit_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      $self->{maps_counters}->{disk_alarm} = [
          { label => 'disk-status', threshold => 0, set => {
                  key_values => [ { name => 'name' }, { name => 'connection_state' }, { name => 'power_state' }, { name => 'disk_limit' } ],
                  closure_custom_calc => $self->can('custom_limit_calc'), closure_custom_calc_extra_options => { label_ref => 'disk' },
                  closure_custom_output => $self->can('custom_limit_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
  }
  
  sub cpu_long_output {
      my ($self, %options) = @_;
  
      return "checking cpu limit";
  }
  
  sub memory_long_output {
      my ($self, %options) = @_;
  
      return "checking memory limit";
  }
  
  sub disk_long_output {
      my ($self, %options) = @_;
  
      return "checking disk limit";
  }
  
  sub prefix_vm_output {
      my ($self, %options) = @_;
  
      my $msg = "Virtual machine '" . $options{instance_value}->{name} . "'";
      if (defined($options{instance_value}->{config_annotation})) {
          $msg .= ' [annotation: ' . $options{instance_value}->{config_annotation} . ']';
      }
      $msg .= ' : ';
      
      return $msg;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "vm-hostname:s"         => { name => 'vm_hostname' },
          "filter"                => { name => 'filter' },
          "filter-description:s"  => { name => 'filter_description' },
          "filter-os:s"           => { name => 'filter_os' },
          "filter-uuid:s"         => { name => 'filter_uuid' },
          "display-description"   => { name => 'display_description' },
          "check-disk-limit"      => { name => 'check_disk_limit' },
          "warning-disk-status:s"     => { name => 'warning_disk_status', default => '' },
          "critical-disk-status:s"    => { name => 'critical_disk_status', default => '%{connection_state} !~ /^connected$/i || %{limit} != -1' },
          "warning-cpu-status:s"      => { name => 'warning_cpu_status', default => '' },
          "critical-cpu-status:s"     => { name => 'critical_cpu_status', default => '%{connection_state} !~ /^connected$/i || %{limit} != -1' },
          "warning-memory-status:s"   => { name => 'warning_memory_status', default => '' },
          "critical-memory-status:s"  => { name => 'critical_memory_status', default => '%{connection_state} !~ /^connected$/i || %{limit} != -1' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['warning_disk_status', 'critical_disk_status','warning_memory_status', 'critical_memory_status',
          'warning_cpu_status', 'critical_cpu_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'limitvm');
  
      my $i = 0;
      $self->{cpu_alarms}->{global} = { cpu_alarm => {} };
      $self->{memory_alarms}->{global} = { memory_alarm => {} };
      $self->{disk_alarms}->{global} = { disk_alarm => {} } if (defined($self->{option_results}->{check_disk_limit}));
      foreach my $vm_id (keys %{$response->{data}}) {
          my $vm_name = $response->{data}->{$vm_id}->{name};
          
          $self->{cpu_alarms}->{global}->{cpu_alarm}->{$i} = {
              name => $vm_name,
              config_annotation => defined($self->{option_results}->{display_description}) ? $options{custom}->strip_cr(value => $response->{data}->{$vm_id}->{'config.annotation'}) : undef,
              connection_state => $response->{data}->{$vm_id}->{connection_state},
              power_state => $response->{data}->{$vm_id}->{power_state},
              cpu_limit => $response->{data}->{$vm_id}->{'config.cpuAllocation.limit'},
          };
          $self->{memory_alarms}->{global}->{memory_alarm}->{$i} = {
              name => $vm_name,
              config_annotation => defined($self->{option_results}->{display_description}) ? $options{custom}->strip_cr(value => $response->{data}->{$vm_id}->{'config.annotation'}) : undef,
              connection_state => $response->{data}->{$vm_id}->{connection_state},
              power_state => $response->{data}->{$vm_id}->{power_state},
              memory_limit => $response->{data}->{$vm_id}->{'config.memoryAllocation.limit'}
          };
          
          if (defined($self->{option_results}->{check_disk_limit})) {
              $self->{disk_alarms}->{global}->{disk_alarm}->{$i} = {
                  name => $vm_name,
                  config_annotation => defined($self->{option_results}->{display_description}) ? $options{custom}->strip_cr(value => $response->{data}->{$vm_id}->{'config.annotation'}) : undef,
                  connection_state => $response->{data}->{$vm_id}->{connection_state},
                  power_state => $response->{data}->{$vm_id}->{power_state},
                  disk_limit => -1
              };
              
              foreach (@{$response->{data}->{$vm_id}->{'config.storageIOAllocation.limit'}}) {
                  if ($_->{limit} != -1) {
                      $self->{disk_alarms}->{global}->{disk_alarm}->{$i}->{disk_limit} = 1;
                  }
              }
          }
          
          $i++;
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check virtual machine limits.
  
  =over 8
  
  =item B<--vm-hostname>
  
  VM hostname to check.
  If not set, we check all VMs.
  
  =item B<--filter>
  
  VM hostname is a regexp.
  
  =item B<--filter-description>
  
  Filter also virtual machines description (can be a regexp).
  
  =item B<--filter-os>
  
  Filter also virtual machines OS name (can be a regexp).
  
  =item B<--display-description>
  
  Display virtual machine description.
  
  =item B<--check-disk-limit>
  
  Check disk limits (since vsphere 5.0).
  
  =item B<--warning-disk-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{connection_state}, %{power_state}, %{limit}
  
  =item B<--critical-disk-status>
  
  Set critical threshold for status (Default: '%{connection_state} !~ /^connected$/i || %{limit} != -1').
  Can used special variables like: %{connection_state}, %{power_state}, %{limit}
  
  =item B<--warning-cpu-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{connection_state}, %{power_state}, %{limit}
  
  =item B<--critical-cpu-status>
  
  Set critical threshold for status (Default: '%{connection_state} !~ /^connected$/i || %{limit} != -1').
  Can used special variables like: %{connection_state}, %{power_state}, %{limit}
  
  =item B<--warning-memory-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{connection_state}, %{power_state}, %{limit}
  
  =item B<--critical-memory-status>
  
  Set critical threshold for status (Default: '%{connection_state} !~ /^connected$/i || %{limit} != -1').
  Can used special variables like: %{connection_state}, %{power_state}, %{limit}
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_LIMITVM

$fatpacked{"apps/vmware/connector/mode/listclusters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_LISTCLUSTERS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::listclusters;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  { 
                                    "cluster:s"   => { name => 'cluster' },
                                    "filter"      => { name => 'filter' },
                                  });
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub run {
      my ($self, %options) = @_;
  
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'listclusters');
      foreach (keys %{$response->{data}}) {
          $self->{output}->output_add(long_msg => '  ' . $response->{data}->{$_}->{name});
      }
  
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'List cluster(s):');
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
      
      $self->{output}->add_disco_format(elements => ['name']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
      
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'listclusters');
      foreach (keys %{$response->{data}}) {
          $self->{output}->add_disco_entry(name => $response->{data}->{$_}->{name});
      }
  }
  
  1;
  
  
  =head1 MODE
  
  List clusters.
  
  =over 8
  
  =item B<--cluster>
  
  Cluster to check.
  If not set, we check all clusters.
  
  =item B<--filter>
  
  Cluster is a regexp.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_LISTCLUSTERS

$fatpacked{"apps/vmware/connector/mode/listdatacenters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_LISTDATACENTERS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::listdatacenters;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  { 
                                    "datacenter:s"            => { name => 'datacenter' },
                                    "filter"                  => { name => 'filter' },
                                  });
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  
  sub run {
      my ($self, %options) = @_;
  
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'listdatacenters');
      foreach (keys %{$response->{data}}) {
          $self->{output}->output_add(long_msg => '  ' . $response->{data}->{$_}->{name});
      }
  
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'List datacenter(s):');
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  
      $self->{connector} = $options{custom};
  }
  
  sub disco_format {
      my ($self, %options) = @_;
      
      $self->{output}->add_disco_format(elements => ['name']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
      
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'listdatacenters');
      foreach (keys %{$response->{data}}) {
          $self->{output}->add_disco_entry(name => $response->{data}->{$_}->{name});
      }
  }
  
  1;
  
  
  =head1 MODE
  
  List datacenters.
  
  =over 8
  
  =item B<--datacenter>
  
  Datacenter to check.
  If not set, we check all datacenters.
  
  =item B<--filter>
  
  Datacenter is a regexp.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_LISTDATACENTERS

$fatpacked{"apps/vmware/connector/mode/listdatastores.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_LISTDATASTORES';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::listdatastores;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  { 
                                    "datastore-name:s"        => { name => 'datastore_name' },
                                    "filter"                  => { name => 'filter' },
                                    "scope-datacenter:s"      => { name => 'scope_datacenter' },
                                  });
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  
  sub run {
      my ($self, %options) = @_;
  
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'listdatastores');
      foreach (keys %{$response->{data}}) {
          $self->{output}->output_add(long_msg => sprintf("  %s [%s] [%s]", 
                                                          $response->{data}->{$_}->{name}, 
                                                          $response->{data}->{$_}->{accessible},
                                                          $response->{data}->{$_}->{type}));
      }
  
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'List datastore(s):');
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
      
      $self->{output}->add_disco_format(elements => ['name', 'accessible', 'type']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
      
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'listdatastores');
      foreach (keys %{$response->{data}}) {
          $self->{output}->add_disco_entry(name => $response->{data}->{$_}->{name},
              accessible => $response->{data}->{$_}->{accessible}, type => $response->{data}->{$_}->{type}
          );
      }
  }
  
  1;
  
  
  =head1 MODE
  
  List datastores.
  
  =over 8
  
  =item B<--datastore-name>
  
  datastore name to list.
  
  =item B<--filter>
  
  Datastore name is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_LISTDATASTORES

$fatpacked{"apps/vmware/connector/mode/listnichost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_LISTNICHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::listnichost;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments =>
                                  {
                                    "esx-hostname:s"          => { name => 'esx_hostname' },
                                    "filter"                  => { name => 'filter' },
                                  });
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      if (!defined($self->{option_results}->{esx_hostname}) ||
          $self->{option_results}->{esx_hostname} eq '') {
          $self->{output}->add_option_msg(short_msg => "Please set option --esx-hostname.");
          $self->{output}->option_exit();
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'listnichost');
      foreach (sort keys %{$response->{data}}) {
          $self->{output}->output_add(long_msg => sprintf('%s [status: %s] [vswitch: %s]', 
                                                         $response->{data}->{$_}->{name}, $response->{data}->{$_}->{status}, $response->{data}->{$_}->{vswitch})
          );
      }
  
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'List nic host:');
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
      
      $self->{output}->add_disco_format(elements => ['name', 'status', 'vswitch']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'listnichost');
      foreach (sort keys %{$response->{data}}) {
          $self->{output}->add_disco_entry(name => $response->{data}->{$_}->{name},
              status => $response->{data}->{$_}->{status}, vswitch => $response->{data}->{$_}->{vswitch}
          );
      }
  }
  
  1;
  
  
  =head1 MODE
  
  List ESX interfaces.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check (required).
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_LISTNICHOST

$fatpacked{"apps/vmware/connector/mode/maintenancehost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_MAINTENANCEHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::maintenancehost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{status};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      return 0;
  }
  
  sub custom_maintenance_output {
      my ($self, %options) = @_;
  
      my $msg = 'maintenance mode is ' . $self->{result_values}->{maintenance};
      return $msg;
  }
  
  sub custom_maintenance_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{maintenance} = $options{new_datas}->{$self->{instance} . '_maintenance'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'host', type => 1, cb_prefix_output => 'prefix_host_output', message_multiple => 'All ESX Hosts are ok' },
      ];
      
      $self->{maps_counters}->{host} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'maintenance-status', threshold => 0, set => {
                  key_values => [ { name => 'maintenance' } ],
                  closure_custom_calc => $self->can('custom_maintenance_calc'),
                  closure_custom_output => $self->can('custom_maintenance_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "esx-hostname:s"        => { name => 'esx_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{status} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
          "warning-maintenance-status:s"  => { name => 'warning_maintenance_status', default => '' },
          "critical-maintenance-status:s" => { name => 'critical_maintenance_status', default => '%{maintenance} !~ /false/' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status',
          'warning_maintenance_status', 'critical_maintenance_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'maintenancehost');
  
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          $self->{host}->{$host_name} = {
              display => $host_name, 
              state => $response->{data}->{$host_id}->{state},
              maintenance => $response->{data}->{$host_id}->{inMaintenanceMode},
          };
      }    
  }
  
  1;
  
  
  =head1 MODE
  
  Check maintenance mode of ESX hosts.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--warning-maintenance-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{maintenance}
  
  =item B<--critical-maintenance-status>
  
  Set critical threshold for status (Default: '%{maintenance} !~ /false/').
  Can used special variables like: %{maintenance}
  
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_MAINTENANCEHOST

$fatpacked{"apps/vmware/connector/mode/memoryhost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_MEMORYHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::memoryhost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status : ' . $self->{result_values}->{status};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      return 0;
  }
  
  sub custom_usage_perfdata {
      my ($self, %options) = @_;
  
      my ($label, $nlabel) = ('used', $self->{nlabel});
      my $value_perf = $self->{result_values}->{used};
      if (defined($self->{instance_mode}->{option_results}->{free})) {
          ($label, $nlabel) = ('free', 'host.memory.free.bytes');
          $value_perf = $self->{result_values}->{free};
      }
  
      my %total_options = ();
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $total_options{total} = $self->{result_values}->{total};
          $total_options{cast_int} = 1;
      }
  
      $self->{output}->perfdata_add(
          label => $label, unit => 'B',
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
          nlabel => $nlabel,
          value => $value_perf,
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}, %total_options),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}, %total_options),
          min => 0, max => $self->{result_values}->{total}
      );
  }
  
  sub custom_usage_threshold {
      my ($self, %options) = @_;
  
      my ($exit, $threshold_value);
      $threshold_value = $self->{result_values}->{used};
      $threshold_value = $self->{result_values}->{free} if (defined($self->{instance_mode}->{option_results}->{free}));
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $threshold_value = $self->{result_values}->{prct_used};
          $threshold_value = $self->{result_values}->{prct_free} if (defined($self->{instance_mode}->{option_results}->{free}));
      }
      $exit = $self->{perfdata}->threshold_check(value => $threshold_value, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' } ]);
      return $exit;
  }
  
  sub custom_usage_output {
      my ($self, %options) = @_;
  
      my ($total_size_value, $total_size_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{total});
      my ($total_used_value, $total_used_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{used});
      my ($total_free_value, $total_free_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{free});
      my $msg = sprintf("Memory 'consumed' Usage Total: %s Used: %s (%.2f%%) Free: %s (%.2f%%)",
                     $total_size_value . " " . $total_size_unit,
                     $total_used_value . " " . $total_used_unit, $self->{result_values}->{prct_used},
                     $total_free_value . " " . $total_free_unit, $self->{result_values}->{prct_free});
      return $msg;
  }
  
  sub custom_usage_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_total'};
      
      if ($self->{result_values}->{total} <= 0) {
          $self->{error_msg} = 'size is 0';
          return -20;
      }
      
      $self->{result_values}->{used} = $options{new_datas}->{$self->{instance} . '_consumed'};
      $self->{result_values}->{free} = $self->{result_values}->{total} - $self->{result_values}->{used};
      $self->{result_values}->{prct_used} = $self->{result_values}->{used} * 100 / $self->{result_values}->{total};
      $self->{result_values}->{prct_free} = 100 - $self->{result_values}->{prct_used};
  
      return 0;
  }
  
  sub custom_overhead_output {
      my ($self, %options) = @_;
  
      my ($overhead_value, $overhead_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{overhead_absolute});
      my $msg = sprintf("Memory Overhead: %s",
                        $overhead_value . " " . $overhead_unit);
      return $msg;
  }
  
  sub custom_memstate_output {
      my ($self, %options) = @_;
  
      my $msg = 'Memory state is ' . $self->{result_values}->{mem_state_str_absolute};
      return $msg;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'host', type => 1, cb_prefix_output => 'prefix_host_output', message_multiple => 'All hosts are ok', skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{host} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' }, { name => 'display' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'consumed-memory', nlabel => 'host.memory.usage.bytes', set => {
                  key_values => [ { name => 'display' }, { name => 'consumed' }, { name => 'total' } ],
                  closure_custom_calc => $self->can('custom_usage_calc'),
                  closure_custom_output => $self->can('custom_usage_output'),
                  closure_custom_perfdata => $self->can('custom_usage_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_usage_threshold'),
              }
          },
          { label => 'overhead-memory', nlabel => 'host.memory.overhead.bytes', set => {
                  key_values => [ { name => 'overhead' }, { name => 'display' } ],
                  closure_custom_output => $self->can('custom_overhead_output'),
                  perfdatas => [
                      { label => 'overhead', value => 'overhead_absolute', template => '%s', unit => 'B', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'state-memory', nlabel => 'host.memory.state.count', set => {
                  key_values => [ { name => 'mem_state' }, { name => 'mem_state_str' }, { name => 'display' } ],
                  closure_custom_output => $self->can('custom_memstate_output'),
                  perfdatas => [
                      { label => 'state', value => 'mem_state_absolute', template => '%s', 
                        min => 0, max => 3, label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "esx-hostname:s"        => { name => 'esx_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "units:s"               => { name => 'units', default => '%' },
          "free"                  => { name => 'free' },
          "no-memory-state"       => { name => 'no_memory_state' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{status} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'memhost');
      
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          $self->{host}->{$host_name} = { 
              display => $host_name, 
              state => $response->{data}->{$host_id}->{state},
              consumed => $response->{data}->{$host_id}->{'mem.consumed.average'},
              overhead => $response->{data}->{$host_id}->{'mem.overhead.average'},
              mem_state => $response->{data}->{$host_id}->{mem_state},
              mem_state_str => $response->{data}->{$host_id}->{mem_state_str},
              total => $response->{data}->{$host_id}->{mem_size},
          };        
      }    
  }
  
  1;
  
  
  =head1 MODE
  
  Check ESX memory usage.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--units>
  
  Units of thresholds (Default: '%') ('%', 'B').
  
  =item B<--free>
  
  Thresholds are on free space left.
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--warning-consumed-memory>
  
  Threshold warning (can use unit option).
  
  =item B<--critical-consumed-memory>
  
  Threshold critical (can use unit option).
  
  =item B<--warning-overhead-memory>
  
  Threshold overhead.
  
  =item B<--critical-overhead-memory>
  
  Threshold critical.
  
  =item B<--warning-state-memory>
  
  Threshold warning. For state != 'high': --warning-state=0
  
  =item B<--critical-state-memory>
  
  Threshold critical. For state != 'high': --warning-state=0
  
  =item B<--no-memory-state>
  
  Don't check memory state.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_MEMORYHOST

$fatpacked{"apps/vmware/connector/mode/memoryvm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_MEMORYVM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::memoryvm;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = '[connection state ' . $self->{result_values}->{connection_state} . '][power state ' . $self->{result_values}->{power_state} . ']';
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{connection_state} = $options{new_datas}->{$self->{instance} . '_connection_state'};
      $self->{result_values}->{power_state} = $options{new_datas}->{$self->{instance} . '_power_state'};
      return 0;
  }
  
  sub custom_usage_perfdata {
      my ($self, %options) = @_;
  
      my ($label, $nlabel) = ('used', $self->{nlabel});
      my $value_perf = $self->{result_values}->{used};
      if (defined($self->{instance_mode}->{option_results}->{free})) {
          ($label, $nlabel) = ('free', 'vm.memory.free.bytes');
          $value_perf = $self->{result_values}->{free};
      }
  
      my %total_options = ();
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $total_options{total} = $self->{result_values}->{total};
          $total_options{cast_int} = 1;
      }
  
      $self->{output}->perfdata_add(
          label => $label, unit => 'B',
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
          nlabel => $nlabel,
          value => $value_perf,
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}, %total_options),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}, %total_options),
          min => 0, max => $self->{result_values}->{total}
      );
  }
  
  sub custom_usage_threshold {
      my ($self, %options) = @_;
  
      my ($exit, $threshold_value);
      $threshold_value = $self->{result_values}->{used};
      $threshold_value = $self->{result_values}->{free} if (defined($self->{instance_mode}->{option_results}->{free}));
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $threshold_value = $self->{result_values}->{prct_used};
          $threshold_value = $self->{result_values}->{prct_free} if (defined($self->{instance_mode}->{option_results}->{free}));
      }
      $exit = $self->{perfdata}->threshold_check(value => $threshold_value, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' } ]);
      return $exit;
  }
  
  sub custom_usage_output {
      my ($self, %options) = @_;
  
      my ($total_size_value, $total_size_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{total});
      my ($total_used_value, $total_used_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{used});
      my ($total_free_value, $total_free_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{free});
      my $msg = sprintf("Memory %s Usage Total: %s Used: %s (%.2f%%) Free: %s (%.2f%%)",
                     $self->{result_values}->{label_ref},
                     $total_size_value . " " . $total_size_unit,
                     $total_used_value . " " . $total_used_unit, $self->{result_values}->{prct_used},
                     $total_free_value . " " . $total_free_unit, $self->{result_values}->{prct_free});
      return $msg;
  }
  
  sub custom_usage_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_total'};
      $self->{result_values}->{label_ref} = $options{extra_options}->{label_ref};
      
      if ($self->{result_values}->{total} <= 0) {
          $self->{error_msg} = 'size is 0';
          return -20;
      }
      
      $self->{result_values}->{used} = $options{new_datas}->{$self->{instance} . '_' . $self->{result_values}->{label_ref}};
      $self->{result_values}->{free} = $self->{result_values}->{total} - $self->{result_values}->{used};
      $self->{result_values}->{prct_used} = $self->{result_values}->{used} * 100 / $self->{result_values}->{total};
      $self->{result_values}->{prct_free} = 100 - $self->{result_values}->{prct_used};
  
      return 0;
  }
  
  sub custom_overhead_output {
      my ($self, %options) = @_;
  
      my ($value, $unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{overhead_absolute});
      my $msg = sprintf("Memory overhead: %s %s", $value, $unit);
      return $msg;
  }
  
  sub custom_ballooning_output {
      my ($self, %options) = @_;
  
      my ($value, $unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{vmmemctl_absolute});
      my $msg = sprintf("Memory ballooning: %s %s", $value, $unit);
      return $msg;
  }
  
  sub custom_shared_output {
      my ($self, %options) = @_;
  
      my ($value, $unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{shared_absolute});
      my $msg = sprintf("Memory shared: %s %s", $value, $unit);
      return $msg;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'vm', type => 3, cb_prefix_output => 'prefix_vm_output', cb_long_output => 'vm_long_output', indent_long_output => '    ', message_multiple => 'All virtual machines are ok', 
              group => [
                  { name => 'global', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_consumed', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_active', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_overhead', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_vmmemctl', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_shared', type => 0, skipped_code => { -10 => 1 } },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'connection_state' }, { name => 'power_state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{global_consumed} = [
          { label => 'consumed', nlabel => 'vm.memory.usage.bytes', set => {
                  key_values => [ { name => 'consumed' }, { name => 'total' } ],
                  closure_custom_calc => $self->can('custom_usage_calc'), closure_custom_calc_extra_options => { label_ref => 'consumed' },
                  closure_custom_output => $self->can('custom_usage_output'),
                  closure_custom_perfdata => $self->can('custom_usage_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_usage_threshold'),
              }
          },
      ];
      $self->{maps_counters}->{global_active} = [
          { label => 'active', nlabel => 'vm.memory.active.bytes', set => {
                  key_values => [ { name => 'active' }, { name => 'total' } ],
                  closure_custom_calc => $self->can('custom_usage_calc'), closure_custom_calc_extra_options => { label_ref => 'active' },
                  closure_custom_output => $self->can('custom_usage_output'),
                  closure_custom_perfdata => $self->can('custom_usage_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_usage_threshold'),
              }
          },
      ];
      $self->{maps_counters}->{global_overhead} = [
          { label => 'overhead', nlabel => 'vm.memory.overhead.bytes', set => {
                  key_values => [ { name => 'overhead' } ],
                  closure_custom_output => $self->can('custom_overhead_output'),
                  perfdatas => [
                      { label => 'overhead', value => 'overhead_absolute', template => '%s', unit => 'B', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
      $self->{maps_counters}->{global_vmmemctl} = [
          { label => 'ballooning', nlabel => 'vm.memory.ballooning.bytes', set => {
                  key_values => [ { name => 'vmmemctl' } ],
                  closure_custom_output => $self->can('custom_ballooning_output'),
                  perfdatas => [
                      { label => 'ballooning', value => 'vmmemctl_absolute', template => '%s', unit => 'B', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
      $self->{maps_counters}->{global_shared} = [
          { label => 'shared', nlabel => 'vm.memory.shared.bytes', set => {
                  key_values => [ { name => 'shared' } ],
                  closure_custom_output => $self->can('custom_shared_output'),
                  perfdatas => [
                      { label => 'shared', value => 'shared_absolute', template => '%s', unit => 'B', 
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_vm_output {
      my ($self, %options) = @_;
  
      my $msg = "Virtual machine '" . $options{instance_value}->{display} . "'";
      if (defined($options{instance_value}->{config_annotation})) {
          $msg .= ' [annotation: ' . $options{instance_value}->{config_annotation} . ']';
      }
      $msg .= ' : ';
      
      return $msg;
  }
  
  sub vm_long_output {
      my ($self, %options) = @_;
  
      my $msg = "checking virtual machine '" . $options{instance_value}->{display} . "'";
      if (defined($options{instance_value}->{config_annotation})) {
          $msg .= ' [annotation: ' . $options{instance_value}->{config_annotation} . ']';
      }
      
      return $msg;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "vm-hostname:s"         => { name => 'vm_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "scope-host:s"          => { name => 'scope_host' },
          "filter-description:s"  => { name => 'filter_description' },
          "filter-os:s"           => { name => 'filter_os' },
          "filter-uuid:s"         => { name => 'filter_uuid' },
          "display-description"   => { name => 'display_description' },
          "units:s"               => { name => 'units', default => '%' },
          "free"                  => { name => 'free' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{connection_state} !~ /^connected$/i or %{power_state}  !~ /^poweredOn$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{vm} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'memvm');
  
      foreach my $vm_id (keys %{$response->{data}}) {
          my $vm_name = $response->{data}->{$vm_id}->{name};
          
          $self->{vm}->{$vm_name} = { display => $vm_name, 
              global => {
                  connection_state => $response->{data}->{$vm_id}->{connection_state},
                  power_state => $response->{data}->{$vm_id}->{power_state},
              },
          };
          
          foreach (('consumed', 'active', 'overhead', 'vmmemctl', 'shared')) {
              next if (!defined($response->{data}->{$vm_id}->{'mem.' . $_ . '.average'}));
              $self->{vm}->{$vm_name}->{'global_' . $_} = {
                  $_ => $response->{data}->{$vm_id}->{'mem.' . $_ . '.average'},
                  total => $response->{data}->{$vm_id}->{memory_size}
              };
          }
          
          if (defined($self->{option_results}->{display_description})) {
              $self->{vm}->{$vm_name}->{config_annotation} = $options{custom}->strip_cr(value => $response->{data}->{$vm_id}->{'config.annotation'});
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check virtual machine memory.
  
  =over 8
  
  =item B<--vm-hostname>
  
  VM hostname to check.
  If not set, we check all VMs.
  
  =item B<--filter>
  
  VM hostname is a regexp.
  
  =item B<--filter-description>
  
  Filter also virtual machines description (can be a regexp).
  
  =item B<--filter-os>
  
  Filter also virtual machines OS name (can be a regexp).
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--scope-host>
  
  Search in following host(s) (can be a regexp).
  
  =item B<--display-description>
  
  Display virtual machine description.
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{connection_state} !~ /^connected$/i or %{power_state}  !~ /^poweredOn$/i').
  Can used special variables like: %{connection_state}, %{power_state}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{connection_state}, %{power_state}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{connection_state}, %{power_state}
  
  =item B<--units>
  
  Units of thresholds (Default: '%') ('%', 'B').
  
  =item B<--free>
  
  Thresholds are on free space left.
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'consumed', 'active', 'overhead', 'ballooning', 'shared'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'consumed', 'active', 'overhead', 'ballooning', 'shared'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_MEMORYVM

$fatpacked{"apps/vmware/connector/mode/nethost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_NETHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::nethost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{status};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      return 0;
  }
  
  sub custom_linkstatus_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{link_status};
      return $msg;
  }
  
  sub custom_linkstatus_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{link_status} = $options{new_datas}->{$self->{instance} . '_status'};
      return 0;
  }
  
  sub custom_traffic_output {
      my ($self, %options) = @_;
  
      my ($value, $unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{traffic}, network => 1);
      my $msg = sprintf("traffic %s : %s/s (%.2f %%)",
                        $self->{result_values}->{label_ref}, $value . $unit, $self->{result_values}->{traffic_prct});
      return $msg;
  }
  
  sub custom_traffic_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{speed} = $options{new_datas}->{$self->{instance} . '_speed'};
      $self->{result_values}->{traffic} = $options{new_datas}->{$self->{instance} . '_traffic_' . $options{extra_options}->{label_ref}};
      $self->{result_values}->{label_ref} = $options{extra_options}->{label_ref};
      $self->{result_values}->{traffic_prct} = $self->{result_values}->{traffic} * 100 / $self->{result_values}->{speed};
  
      return 0;
  }
  
  sub custom_dropped_output {
      my ($self, %options) = @_;
  
      my $msg = sprintf("packets %s dropped : %.2f %% (%d/%d packets)",
                        $self->{result_values}->{label_ref}, 
                        $self->{result_values}->{dropped_prct},
                        $self->{result_values}->{dropped}, $self->{result_values}->{packets});
      return $msg;
  }
  
  sub custom_dropped_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{dropped} = $options{new_datas}->{$self->{instance} . '_dropped_' . $options{extra_options}->{label_ref}};
      $self->{result_values}->{packets} = $options{new_datas}->{$self->{instance} . '_packets_' . $options{extra_options}->{label_ref}};
      $self->{result_values}->{label_ref} = $options{extra_options}->{label_ref};
      $self->{result_values}->{dropped_prct} = 0;
      if ($self->{result_values}->{packets} > 0) {
          $self->{result_values}->{dropped_prct} = $self->{result_values}->{dropped} * 100 / $self->{result_values}->{packets};
      }
      
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'host', type => 3, cb_prefix_output => 'prefix_host_output', cb_long_output => 'host_long_output', indent_long_output => '    ', message_multiple => 'All ESX hosts are ok', 
              group => [
                  { name => 'global', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'global_host', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'pnic', cb_prefix_output => 'prefix_pnic_output',  message_multiple => 'All physical interfaces are ok', type => 1, skipped_code => { -10 => 1 } },
                  { name => 'vswitch', cb_prefix_output => 'prefix_vswitch_output',  message_multiple => 'All vswitchs are ok', type => 1, skipped_code => { -10 => 1 } },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{global_host} = [
          { label => 'host-traffic-in', nlabel => 'host.traffic.in.bitsperseconds', set => {
                  key_values => [ { name => 'traffic_in' } ],
                  output_template => 'host traffic in : %s %s/s',
                  output_change_bytes => 2,
                  perfdatas => [
                      { label => 'host_traffic_in', value => 'traffic_in_absolute', template => '%s',
                        unit => 'b/s', min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'host-traffic-out', nlabel => 'host.traffic.out.bitsperseconds', set => {
                  key_values => [ { name => 'traffic_out' } ],
                  output_template => 'host traffic out : %s %s/s',
                  output_change_bytes => 2,
                  perfdatas => [
                      { label => 'host_traffic_out', value => 'traffic_out_absolute', template => '%s',
                        unit => 'b/s', min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{vswitch} = [
          { label => 'vswitch-traffic-in', nlabel => 'host.vswitch.traffic.in.bitsperseconds', set => {
                  key_values => [ { name => 'traffic_in' } ],
                  output_template => 'traffic in : %s %s/s',
                  output_change_bytes => 2,
                  perfdatas => [
                      { label => 'vswitch_traffic_in', value => 'traffic_in_absolute', template => '%s',
                        unit => 'b/s', min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'vswitch-traffic-out', nlabel => 'host.vswitch.traffic.out.bitsperseconds', set => {
                  key_values => [ { name => 'traffic_out' } ],
                  output_template => 'traffic out : %s %s/s',
                  output_change_bytes => 2,
                  perfdatas => [
                      { label => 'vswitch_traffic_out', value => 'traffic_out_absolute', template => '%s',
                        unit => 'b/s', min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{pnic} = [
          { label => 'link-status', threshold => 0, set => {
                  key_values => [ { name => 'status' } ],
                  closure_custom_calc => $self->can('custom_linkstatus_calc'),
                  closure_custom_output => $self->can('custom_linkstatus_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'link-traffic-in', nlabel => 'host.traffic.in.bitsperseconds', set => {
                  key_values => [ { name => 'display' }, { name => 'traffic_in' }, { name => 'speed' } ],
                  closure_custom_calc => $self->can('custom_traffic_calc'), closure_custom_calc_extra_options => { label_ref => 'in' },
                  closure_custom_output => $self->can('custom_traffic_output'),
                  threshold_use => 'traffic_prct',
                  perfdatas => [
                      { label => 'traffic_in', value => 'traffic', template => '%s', unit => 'b/s', 
                        min => 0, max => 'speed', threshold_total => 'speed', cast_int => 1, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'link-traffic-out', nlabel => 'host.traffic.out.bitsperseconds', set => {
                  key_values => [ { name => 'display' }, { name => 'traffic_out' }, { name => 'speed' } ],
                  closure_custom_calc => $self->can('custom_traffic_calc'), closure_custom_calc_extra_options => { label_ref => 'out' },
                  closure_custom_output => $self->can('custom_traffic_output'),
                  threshold_use => 'traffic_prct',
                  perfdatas => [
                      { label => 'traffic_out', value => 'traffic', template => '%s', unit => 'b/s', 
                        min => 0, max => 'speed', threshold_total => 'speed', cast_int => 1, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'link-dropped-in', nlabel => 'host.packets.in.dropped.percentage', set => {
                  key_values => [ { name => 'display' }, { name => 'packets_in' }, { name => 'dropped_in' } ],
                  closure_custom_calc => $self->can('custom_dropped_calc'), closure_custom_calc_extra_options => { label_ref => 'in' },
                  closure_custom_output => $self->can('custom_dropped_output'),
                  threshold_use => 'dropped_prct',
                  perfdatas => [
                      { label => 'packets_dropped_in', value => 'dropped_prct', template => '%s', unit => '%', 
                        min => 0, max => 100, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'link-dropped-out', nlabel => 'host.packets.out.dropped.percentage', set => {
                  key_values => [ { name => 'display' }, { name => 'packets_out' }, { name => 'dropped_out' } ],
                  closure_custom_calc => $self->can('custom_dropped_calc'), closure_custom_calc_extra_options => { label_ref => 'out' },
                  closure_custom_output => $self->can('custom_dropped_output'),
                  threshold_use => 'dropped_prct',
                  perfdatas => [
                      { label => 'packets_dropped_out', value => 'dropped_prct', template => '%s', unit => '%', 
                        min => 0, max => 100, label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub host_long_output {
      my ($self, %options) = @_;
  
      return "checking host '" . $options{instance_value}->{display} . "'";
  }
  
  sub prefix_pnic_output {
      my ($self, %options) = @_;
  
      return "physical interface '" . $options{instance_value}->{display} . "' ";
  }
  
  sub prefix_vswitch_output {
      my ($self, %options) = @_;
  
      return "vswitch '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "esx-hostname:s"        => { name => 'esx_hostname' },
          "nic-name:s"            => { name => 'nic_name' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "no-proxyswitch"        => { name => 'no_proxyswitch' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{status} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
          "unknown-link-status:s"     => { name => 'unknown_link_status', default => '' },
          "warning-link-status:s"     => { name => 'warning_link_status', default => '' },
          "critical-link-status:s"    => { name => 'critical_link_status', default => '%{link_status} !~ /up/' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status',
          'unknown_link_status', 'warning_link_status', 'critical_link_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'nethost');
  
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          $self->{host}->{$host_name} = { display => $host_name, 
              cpu => {},
              global => {
                  state => $response->{data}->{$host_id}->{state},    
              },
              global_host => {
                  traffic_in => 0,
                  traffic_out => 0,
              },
          };
          
          foreach my $pnic_name (sort keys %{$response->{data}->{$host_id}->{pnic}}) {
              $self->{host}->{$host_name}->{pnic} = {} if (!defined($self->{host}->{$host_name}->{pnic}));
              next if (defined($self->{option_results}->{nic_name}) && $self->{option_results}->{nic_name} ne '' &&
                  $pnic_name !~ /$self->{option_results}->{nic_name}/);
              
              $self->{host}->{$host_name}->{pnic}->{$pnic_name} = { 
                  display     => $pnic_name, 
                  status      => $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{status} ,
                  traffic_in  => $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.received.average'},
                  traffic_out => $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.transmitted.average'},
                  speed       => defined($response->{data}->{$host_id}->{pnic}->{$pnic_name}->{speed}) ? $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{speed} * 1024 * 1024 : undef, ,
                  packets_in  => $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.packetsRx.summation'},
                  packets_out => $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.packetsTx.summation'},
                  dropped_in  => $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.droppedRx.summation'},
                  dropped_out => $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.droppedTx.summation'},
              };
              
              next if (!defined($response->{data}->{$host_id}->{pnic}->{$pnic_name}->{speed}));
              
              foreach my $vswitch_name (keys %{$response->{data}->{$host_id}->{vswitch}}) {
                  next if (!defined($response->{data}->{$host_id}->{vswitch}->{$vswitch_name}->{pnic}));
                  foreach (@{$response->{data}->{$host_id}->{vswitch}->{$vswitch_name}->{pnic}}) {
                      if ($_ eq $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{key}) {
                          $self->{host}->{$host_name}->{vswitch} = {} 
                              if (!defined($self->{host}->{$host_name}->{vswitch}));
                          $self->{host}->{$host_name}->{vswitch}->{$vswitch_name} = { display => $vswitch_name, traffic_in => 0, traffic_out => 0 }
                              if (!defined($self->{host}->{$host_name}->{vswitch}->{$vswitch_name}));
                          $self->{host}->{$host_name}->{vswitch}->{$vswitch_name}->{traffic_in} += $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.received.average'};
                          $self->{host}->{$host_name}->{vswitch}->{$vswitch_name}->{traffic_out} += $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.transmitted.average'};
                      }
                  }
              }
              
              $self->{host}->{$host_name}->{global_host}->{traffic_in} += $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.received.average'}
                  if (defined($response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.received.average'}));
              $self->{host}->{$host_name}->{global_host}->{traffic_out} += $response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.transmitted.average'}
                  if (defined($response->{data}->{$host_id}->{pnic}->{$pnic_name}->{'net.transmitted.average'}));
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check ESX net usage.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--nic-name>
  
  ESX nic to check.
  If not set, we check all nics.
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--unknown-link-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{link_status}
  
  =item B<--warning-link-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{link_status}
  
  =item B<--critical-link-status>
  
  Set critical threshold for status (Default: '%{link_status} !~ /up/').
  Can used special variables like: %{link_status}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'host-traffic-in', 'host-traffic-out', 'vswitch-traffic-in', 'vswitch-traffic-out',
  'link-traffic-in', 'link-traffic-out', 'link-dropped-in', 'link-dropped-out'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'host-traffic-in', 'host-traffic-out', 'vswitch-traffic-in', 'vswitch-traffic-out',
  'link-traffic-in', 'link-traffic-out', 'link-dropped-in', 'link-dropped-out'.
  
  =item B<--no-proxyswitch>
  
  Use the following option if you are checking an ESX 3.x version (it's mandatory).
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_NETHOST

$fatpacked{"apps/vmware/connector/mode/servicehost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_SERVICEHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::servicehost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{status} . ', maintenance mode is ' . $self->{result_values}->{maintenance};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      $self->{result_values}->{maintenance} = $options{new_datas}->{$self->{instance} . '_maintenance'};
      return 0;
  }
  
  sub custom_service_output {
      my ($self, %options) = @_;
  
      my $msg = '[policy ' . $self->{result_values}->{policy} . '][running ' . $self->{result_values}->{running} . ']';
      return $msg;
  }
  
  sub custom_service_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{policy} = $options{new_datas}->{$self->{instance} . '_policy'};
      $self->{result_values}->{running} = $options{new_datas}->{$self->{instance} . '_running'};
      $self->{result_values}->{key} = $options{new_datas}->{$self->{instance} . '_key'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'host', type => 3, cb_prefix_output => 'prefix_host_output', cb_long_output => 'host_long_output', indent_long_output => '    ', message_multiple => 'All ESX hosts are ok', 
              group => [
                  { name => 'global', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'service', cb_prefix_output => 'prefix_service_output',  message_multiple => 'All services are ok', type => 1, skipped_code => { -10 => 1 } },
              ]
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' }, { name => 'maintenance' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
      
      $self->{maps_counters}->{service} = [
          { label => 'service-status', threshold => 0, set => {
                  key_values => [ { name => 'display' }, { name => 'policy' }, { name => 'running' }, { name => 'key' } ],
                  closure_custom_calc => $self->can('custom_service_calc'),
                  closure_custom_output => $self->can('custom_service_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub host_long_output {
      my ($self, %options) = @_;
  
      return "checking host '" . $options{instance_value}->{display} . "'";
  }
  
  sub prefix_service_output {
      my ($self, %options) = @_;
  
      return "service '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "esx-hostname:s"            => { name => 'esx_hostname' },
          "filter"                    => { name => 'filter' },
          "scope-datacenter:s"        => { name => 'scope_datacenter' },
          "scope-cluster:s"           => { name => 'scope_cluster' },
          "filter-services:s"         => { name => 'filter_services' },
          "unknown-status:s"          => { name => 'unknown_status', default => '%{status} !~ /^connected$/i && %{maintenance} =~ /false/i' },
          "warning-status:s"          => { name => 'warning_status', default => '' },
          "critical-status:s"         => { name => 'critical_status', default => '' },
          "warning-service-status:s"  => { name => 'warning_service_status', default => '' },
          "critical-service-status:s" => { name => 'critical_service_status', default => '%{policy} =~ /^on|automatic/i && !%{running}' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status',
          'warning_service_status', 'critical_service_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'servicehost');
          
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          $self->{host}->{$host_name} = { display => $host_name, 
              global => {
                  state => $response->{data}->{$host_id}->{state},
                  maintenance => $response->{data}->{$host_id}->{inMaintenanceMode},
              },
          };
          
          foreach (@{$response->{data}->{$host_id}->{services}}) {
              next if (defined($self->{option_results}->{filter_services}) && $self->{option_results}->{filter_services} ne '' &&
                       $_->{key} !~ /$self->{option_results}->{filter_services}/);
              
              $self->{host}->{$host_name}->{service} = {} if (!defined($self->{host}->{$host_name}->{service}));
              $self->{host}->{$host_name}->{service}->{$_->{label}} = { display => $_->{label}, policy => $_->{policy}, running => $_->{running}, key => $_->{key} };
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check ESX services.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--filter-services>
  
  Filter services you want to check (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i && %{maintenance} =~ /false/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--warning-service-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{running}, %{label}, %{policy}
  
  =item B<--critical-service-status>
  
  Set critical threshold for status (Default: '%{policy} =~ /^on|automatic/i && !%{running}').
  Can used special variables like: %{running}, %{label}, %{policy}
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_SERVICEHOST

$fatpacked{"apps/vmware/connector/mode/snapshotvm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_SNAPSHOTVM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::snapshotvm;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  use Date::Parse;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "vm-hostname:s"         => { name => 'vm_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "scope-host:s"          => { name => 'scope_host' },
          "filter-description:s"  => { name => 'filter_description' },
          "filter-os:s"           => { name => 'filter_os' },
          "filter-uuid:s"         => { name => 'filter_uuid' },
          "display-description"   => { name => 'display_description' },
          "check-consolidation"   => { name => 'check_consolidation' },
          "nopoweredon-skip"      => { name => 'nopoweredon_skip' },
          "warning:s"             => { name => 'warning' },
          "critical:s"            => { name => 'critical' },
          "disconnect-status:s"   => { name => 'disconnect_status', default => 'unknown' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      foreach my $label (('warning', 'critical')) {
          if (($self->{perfdata}->threshold_validate(label => $label, value => $self->{option_results}->{$label})) == 0) {
              my ($label_opt) = $label;
              $label_opt =~ tr/_/-/;
              $self->{output}->add_option_msg(short_msg => "Wrong " . $label_opt . " threshold '" . $self->{option_results}->{$label} . "'.");
              $self->{output}->option_exit();
          }
      }
  
      if ($self->{output}->is_litteral_status(status => $self->{option_results}->{disconnect_status}) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong disconnect-status option '" . $self->{option_results}->{disconnect_status} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub run {
      my ($self, %options) = @_;
  
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'snapshotvm');
      
      my $multiple = 0;
      my %vm_consolidate = ();
      my %vm_errors = (warning => {}, critical => {}); 
      if (scalar(keys %{$response->{data}}) > 1) {
          $multiple = 1;
      }
      if ($multiple == 1) {
          $self->{output}->output_add(severity => 'OK',
                                                 short_msg => sprintf("All snapshots are ok"));
      } else {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => sprintf("Snapshot(s) OK"));
      }
      foreach my $vm_id (sort keys %{$response->{data}}) {
          my $vm_name = $response->{data}->{$vm_id}->{name};
          
          if ($options{custom}->entity_is_connected(state => $response->{data}->{$vm_id}->{connection_state}) == 0) {
              my $output = "VM '" . $vm_name . "' not connected. Current Connection State: '$response->{data}->{$vm_id}->{connection_state}'.";
              if ($multiple == 0 ||  
                  !$self->{output}->is_status(value => $self->{option_results}->{disconnect_status}, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $self->{option_results}->{disconnect_status},
                                              short_msg => $output);
              }
              next;
          }
      
          next if (defined($self->{option_results}->{nopoweredon_skip}) && 
                   $options{custom}->vm_is_running(power => $response->{data}->{$vm_id}->{power_state}) == 0);
      
          if (defined($self->{check_consolidation}) && defined($response->{data}->{$vm_id}->{consolidation_needed}) && $response->{data}->{$vm_id}->{consolidation_needed} == 1) {
              $vm_consolidate{$response->{data}->{$vm_id}->{name}} = 1;
          }
  
          foreach (@{$response->{data}->{$vm_id}->{snapshosts}}) {
              my $create_time = Date::Parse::str2time($_->{create_time});
              if (!defined($create_time)) {
                  $self->{output}->output_add(severity => 'UNKNOWN',
                                              short_msg => "Can't Parse date '" . $_->{create_time} . "' for vm '" . $vm_name . "'");
                  next;
              }
              
              my $diff_time = time() - $create_time;
              my $days = int($diff_time / 60 / 60 / 24);
              my $exit = $self->{perfdata}->threshold_check(value => $diff_time, threshold => [ { label => 'critical', exit_litteral => 'critical' }, { label => 'warning', exit_litteral => 'warning' } ]);
              
              my $prefix_msg = "'$vm_name'";
              if (defined($self->{display_description}) && defined($response->{data}->{$vm_id}->{'config.annotation'}) &&
                  $response->{data}->{$vm_id}->{'config.annotation'} ne '') {
                  $prefix_msg .= ' [' . $options{custom}->strip_cr(value => $response->{data}->{$vm_id}->{'config.annotation'}) . ']';
              }
              my $suffix_msg = '';
              if (defined($_->{description}) && $_->{description} ne '') {
                  $suffix_msg = ' [' . $options{custom}->strip_cr(value => $_->{description}) . ']';
              }
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $vm_errors{$exit}->{$vm_name} = 1;
                  $self->{output}->output_add(long_msg => "$prefix_msg snapshot create time: " . $_->{create_time} . $suffix_msg);
              }
          }
      }
  
      $self->{output}->perfdata_add(
          label => 'num_warning',
          nlabel => 'vm.snapshots.warning.current.count',
          value => scalar(keys %{$vm_errors{warning}}),
          min => 0
      );
      $self->{output}->perfdata_add(
          label => 'num_critical',
          nlabel => 'vm.snapshots.critical.current.count',
          value => scalar(keys %{$vm_errors{critical}}),
          min => 0
      );
      if (scalar(keys %{$vm_errors{warning}}) > 0) {
          $self->{output}->output_add(severity => 'WARNING',
                                      short_msg => sprintf('Snapshots for VM older than %d days: [%s]', ($self->{option_results}->{warning} / 86400), 
                                                           join('] [', sort keys %{$vm_errors{warning}})));
      }
      if (scalar(keys %{$vm_errors{critical}}) > 0) {
          $self->{output}->output_add(severity => 'CRITICAL',
                                      short_msg => sprintf('Snapshots for VM older than %d days: [%s]', ($self->{option_results}->{critical} / 86400), 
                                                           join('] [', sort keys %{$vm_errors{critical}})));
      }
      if (scalar(keys %vm_consolidate) > 0) {
           $self->{output}->output_add(severity => 'CRITICAL',
                                       short_msg => sprintf('VMs need consolidation: [%s]',
                                                            join('] [', sort keys %vm_consolidate)));
      }
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check virtual machine snapshots.
  
  =over 8
  
  =item B<--vm-hostname>
  
  VM hostname to check.
  If not set, we check all VMs.
  
  =item B<--filter>
  
  VM hostname is a regexp.
  
  =item B<--filter-description>
  
  Filter also virtual machines description (can be a regexp).
  
  =item B<--filter-os>
  
  Filter also virtual machines OS name (can be a regexp).
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--scope-host>
  
  Search in following host(s) (can be a regexp).
  
  =item B<--display-description>
  
  Display virtual machine description.
  
  =item B<--check-consolidation>
  
  Check if VM needs consolidation (since vsphere 5.0).
  
  =item B<--disconnect-status>
  
  Status if VM disconnected (default: 'unknown').
  
  =item B<--nopoweredon-skip>
  
  Skip check if VM is not poweredOn.
  
  =item B<--warning>
  
  Threshold warning in seconds.
  
  =item B<--critical>
  
  Threshold critical in seconds.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_SNAPSHOTVM

$fatpacked{"apps/vmware/connector/mode/statconnectors.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_STATCONNECTORS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::statconnectors;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
          { name => 'container', type => 1, cb_prefix_output => 'prefix_container_output', message_multiple => 'All containers are ok' },
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'total-requests', nlabel => 'connector.requests.total.count', set => {
                  key_values => [ { name => 'requests', diff => 1  } ],
                  output_template => 'Total %s requests',
                  perfdatas => [
                      { label => 'requests', value => 'requests_absolute', template => '%s',
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
      
      $self->{maps_counters}->{container} = [
          { label => 'requests', nlabel => 'connector.requests.total.count', set => {
                  key_values => [ { name => 'requests', diff => 1  } ],
                  output_template => '%s requests',
                  perfdatas => [
                      { label => 'requests', value => 'requests_absolute', template => '%s',
                        min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_container_output {
      my ($self, %options) = @_;
  
      return "Container '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
      });
  
      return $self;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{global} = { requests => 0 };
      $self->{container} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'stats');
  
      foreach my $container_name (keys %{$response->{data}}) {
          $self->{container}->{$container_name} = {
              display => $container_name,
              requests => $response->{data}->{$container_name}->{requests}
          };
          $self->{global}->{requests} += $response->{data}->{$container_name}->{requests};
      }
      
      $self->{cache_name} = "cache_vmware_" . $options{custom}->get_id() . '_' . $self->{mode} . '_' .
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Get number of requests for each connectors (information from daemon. Not VMWare).
  
  =over 8
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'total-requests', 'requests'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'total-requests', 'requests'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_STATCONNECTORS

$fatpacked{"apps/vmware/connector/mode/statushost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_STATUSHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::statushost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{status};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      return 0;
  }
  
  sub custom_overall_output {
      my ($self, %options) = @_;
  
      my $msg = 'overall status is ' . $self->{result_values}->{overall_status};
      return $msg;
  }
  
  sub custom_overall_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{overall_status} = $options{new_datas}->{$self->{instance} . '_overall_status'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'host', type => 1, cb_prefix_output => 'prefix_host_output', message_multiple => 'All ESX Hosts are ok' },
      ];
      
      $self->{maps_counters}->{host} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'overall-status', threshold => 0, set => {
                  key_values => [ { name => 'overall_status' } ],
                  closure_custom_calc => $self->can('custom_overall_calc'),
                  closure_custom_output => $self->can('custom_overall_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "esx-hostname:s"        => { name => 'esx_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{status} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
          "unknown-overall-status:s"  => { name => 'unknown_overall_status', default => '%{overall_status} =~ /gray/i' },
          "warning-overall-status:s"  => { name => 'warning_overall_status', default => '%{overall_status} =~ /yellow/i' },
          "critical-overall-status:s" => { name => 'critical_overall_status', default => '%{overall_status} =~ /red/i' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status',
          'unknown_overall_status', 'warning_overall_status', 'critical_overall_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'statushost');
  
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          $self->{host}->{$host_name} = {
              display => $host_name, 
              state => $response->{data}->{$host_id}->{state},
              overall_status => $response->{data}->{$host_id}->{overall_status},
          };
      }    
  }
  
  1;
  
  
  =head1 MODE
  
  Check ESX global status.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--unknown-overall-status>
  
  Set warning threshold for status (Default: '%{overall_status} =~ /gray/i').
  Can used special variables like: %{overall_status}
  
  =item B<--warning-overall-status>
  
  Set warning threshold for status (Default: '%{overall_status} =~ /yellow/i').
  Can used special variables like: %{overall_status}
  
  =item B<--critical-overall-status>
  
  Set critical threshold for status (Default: '%{overall_status} =~ /red/i').
  Can used special variables like: %{overall_status}
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_STATUSHOST

$fatpacked{"apps/vmware/connector/mode/statusvm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_STATUSVM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::statusvm;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{connection_state};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{connection_state} = $options{new_datas}->{$self->{instance} . '_connection_state'};
      return 0;
  }
  
  sub custom_overall_output {
      my ($self, %options) = @_;
  
      my $msg = 'overall status is ' . $self->{result_values}->{overall_status};
      return $msg;
  }
  
  sub custom_overall_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{overall_status} = $options{new_datas}->{$self->{instance} . '_overall_status'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'vm', type => 1, cb_prefix_output => 'prefix_vm_output', message_multiple => 'All virtual machines are ok' },
      ];
      
      $self->{maps_counters}->{vm} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'connection_state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'overall-status', threshold => 0, set => {
                  key_values => [ { name => 'overall_status' } ],
                  closure_custom_calc => $self->can('custom_overall_calc'),
                  closure_custom_output => $self->can('custom_overall_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
  }
  
  sub prefix_vm_output {
      my ($self, %options) = @_;
  
      my $msg = "Virtual machine '" . $options{instance_value}->{display} . "'";
      if (defined($options{instance_value}->{config_annotation})) {
          $msg .= ' [annotation: ' . $options{instance_value}->{config_annotation} . ']';
      }
      $msg .= ' : ';
      
      return $msg;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "vm-hostname:s"         => { name => 'vm_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "scope-host:s"          => { name => 'scope_host' },
          "filter-description:s"  => { name => 'filter_description' },
          "filter-os:s"           => { name => 'filter_os' },
          "filter-uuid:s"         => { name => 'filter_uuid' },
          "display-description"   => { name => 'display_description' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{connection_state} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
          "unknown-overall-status:s"  => { name => 'unknown_overall_status', default => '%{overall_status} =~ /gray/i' },
          "warning-overall-status:s"  => { name => 'warning_overall_status', default => '%{overall_status} =~ /yellow/i' },
          "critical-overall-status:s" => { name => 'critical_overall_status', default => '%{overall_status} =~ /red/i' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status',
          'unknown_overall_status', 'warning_overall_status', 'critical_overall_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{vm} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'statusvm');
  
      foreach my $vm_id (keys %{$response->{data}}) {
          my $vm_name = $response->{data}->{$vm_id}->{name};
          $self->{vm}->{$vm_name} = {
              display => $vm_name, 
              connection_state => $response->{data}->{$vm_id}->{connection_state},
              overall_status => $response->{data}->{$vm_id}->{overall_status},
          };
          
           if (defined($self->{option_results}->{display_description})) {
              $self->{vm}->{$vm_name}->{config_annotation} = $options{custom}->strip_cr(value => $response->{data}->{$vm_id}->{'config.annotation'});
          }
      }    
  }
  
  1;
  
  
  =head1 MODE
  
  Check virtual machine global status.
  
  =over 8
  
  =item B<--vm-hostname>
  
  VM hostname to check.
  If not set, we check all VMs.
  
  =item B<--filter>
  
  VM hostname is a regexp.
  
  =item B<--filter-description>
  
  Filter also virtual machines description (can be a regexp).
  
  =item B<--filter-os>
  
  Filter also virtual machines OS name (can be a regexp).
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--scope-host>
  
  Search in following host(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{connection_state} !~ /^connected$/i').
  Can used special variables like: %{connection_state}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{connection_state}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{connection_state}
  
  =item B<--unknown-overall-status>
  
  Set warning threshold for status (Default: '%{overall_status} =~ /gray/i').
  Can used special variables like: %{overall_status}
  
  =item B<--warning-overall-status>
  
  Set warning threshold for status (Default: '%{overall_status} =~ /yellow/i').
  Can used special variables like: %{overall_status}
  
  =item B<--critical-overall-status>
  
  Set critical threshold for status (Default: '%{overall_status} =~ /red/i').
  Can used special variables like: %{overall_status}
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_STATUSVM

$fatpacked{"apps/vmware/connector/mode/swaphost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_SWAPHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::swaphost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status : ' . $self->{result_values}->{status};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'host', type => 1, cb_prefix_output => 'prefix_host_output', message_multiple => 'All hosts are ok', skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{host} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' }, { name => 'display' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'swap-in', nlabel => 'host.swap.in.usage.bytespersecond', set => {
                  key_values => [ { name => 'swap_in' }, { name => 'display' } ],
                  output_template => 'Swap In: %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'swap_in', value => 'swap_in_absolute', template => '%s',
                        unit => 'B/s', min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'swap-out', nlabel => 'host.swap.out.usage.bytespersecond', set => {
                  key_values => [ { name => 'swap_out' }, { name => 'display' } ],
                  output_template => 'Swap Out: %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'swap_out', value => 'swap_out_absolute', template => '%s',
                        unit => 'B/s', min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "esx-hostname:s"        => { name => 'esx_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{status} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'swaphost');
      
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          $self->{host}->{$host_name} = { 
              display => $host_name, 
              state => $response->{data}->{$host_id}->{state},
              swap_in => $response->{data}->{$host_id}->{'mem.swapinRate.average'},
              swap_out => $response->{data}->{$host_id}->{'mem.swapoutRate.average'},
          };        
      }    
  }
  
  1;
  
  
  =head1 MODE
  
  Check ESX swap rate usage.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'swap-in', 'swap-out'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'swap-in', 'swap-out'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_SWAPHOST

$fatpacked{"apps/vmware/connector/mode/swapvm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_SWAPVM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::swapvm;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = '[connection state ' . $self->{result_values}->{connection_state} . '][power state ' . $self->{result_values}->{power_state} . ']';
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{connection_state} = $options{new_datas}->{$self->{instance} . '_connection_state'};
      $self->{result_values}->{power_state} = $options{new_datas}->{$self->{instance} . '_power_state'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
           { name => 'vm', type => 1, cb_prefix_output => 'prefix_vm_output', message_multiple => 'All virtual machines are ok', skipped_code => { -10 => 1 } }
      ];
      
      $self->{maps_counters}->{vm} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'connection_state' }, { name => 'power_state' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'swap-in', nlabel => 'vm.swap.in.usage.bytespersecond', set => {
                  key_values => [ { name => 'swap_in' }, { name => 'display' } ],
                  output_template => 'Swap In: %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'swap_in', value => 'swap_in_absolute', template => '%s',
                        unit => 'B/s', min => 0, label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'swap-out', nlabel => 'vm.swap.out.usage.bytespersecond', set => {
                  key_values => [ { name => 'swap_out' }, { name => 'display' } ],
                  output_template => 'Swap Out: %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'swap_out', value => 'swap_out_absolute', template => '%s',
                        unit => 'B/s', min => 0, label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_vm_output {
      my ($self, %options) = @_;
  
      my $msg = "Virtual machine '" . $options{instance_value}->{display} . "'";
      if (defined($options{instance_value}->{config_annotation})) {
          $msg .= ' [annotation: ' . $options{instance_value}->{config_annotation} . ']';
      }
      $msg .= ' : ';
      
      return $msg;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "vm-hostname:s"         => { name => 'vm_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "scope-host:s"          => { name => 'scope_host' },
          "filter-description:s"  => { name => 'filter_description' },
          "filter-os:s"           => { name => 'filter_os' },
          "filter-uuid:s"         => { name => 'filter_uuid' },
          "display-description"   => { name => 'display_description' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{connection_state} !~ /^connected$/i or %{power_state}  !~ /^poweredOn$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{vm} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'swapvm');
  
      foreach my $vm_id (keys %{$response->{data}}) {
          my $vm_name = $response->{data}->{$vm_id}->{name};
          
          $self->{vm}->{$vm_name} = {
              display => $vm_name, 
              connection_state => $response->{data}->{$vm_id}->{connection_state},
              power_state => $response->{data}->{$vm_id}->{power_state},
              swap_in => $response->{data}->{$vm_id}->{'mem.swapinRate.average'},
              swap_out => $response->{data}->{$vm_id}->{'mem.swapoutRate.average'},
          };
          
          if (defined($self->{option_results}->{display_description})) {
              $self->{vm}->{$vm_name}->{config_annotation} = $options{custom}->strip_cr(value => $response->{data}->{$vm_id}->{'config.annotation'});
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check virtual machine swap rate usage.
  
  =over 8
  
  =item B<--vm-hostname>
  
  VM hostname to check.
  If not set, we check all VMs.
  
  =item B<--filter>
  
  VM hostname is a regexp.
  
  =item B<--filter-description>
  
  Filter also virtual machines description (can be a regexp).
  
  =item B<--filter-os>
  
  Filter also virtual machines OS name (can be a regexp).
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--scope-host>
  
  Search in following host(s) (can be a regexp).
  
  =item B<--display-description>
  
  Display virtual machine description.
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{connection_state} !~ /^connected$/i or %{power_state}  !~ /^poweredOn$/i').
  Can used special variables like: %{connection_state}, %{power_state}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{connection_state}, %{power_state}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{connection_state}, %{power_state}
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'swap-in', 'swap-out'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'swap-in', 'swap-out'.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_SWAPVM

$fatpacked{"apps/vmware/connector/mode/thinprovisioningvm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_THINPROVISIONINGVM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::thinprovisioningvm;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          "vm-hostname:s"           => { name => 'vm_hostname' },
          "filter"                  => { name => 'filter' },
          "scope-datacenter:s"      => { name => 'scope_datacenter' },
          "scope-cluster:s"         => { name => 'scope_cluster' },
          "scope-host:s"            => { name => 'scope_host' },
          "filter-description:s"    => { name => 'filter_description' },
          "filter-os:s"             => { name => 'filter_os' },
          "filter-uuid:s"           => { name => 'filter_uuid' },
          "disconnect-status:s"     => { name => 'disconnect_status', default => 'unknown' },
          "nopoweredon-skip"        => { name => 'nopoweredon_skip' },
          "display-description"     => { name => 'display_description' },
          "thinprovisioning-status:s"   => { name => 'thinprovisioning_status' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      if ($self->{output}->is_litteral_status(status => $self->{option_results}->{disconnect_status}) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong disconnect-status option '" . $self->{option_results}->{disconnect_status} . "'.");
          $self->{output}->option_exit();
      }
      if (defined($self->{option_results}->{thinprovisioning_status}) && $self->{option_results}->{thinprovisioning_status} ne '') {
          ($self->{thin_entry}, $self->{thin_status}) = split /,/, $self->{option_results}->{thinprovisioning_status};
          if ($self->{thin_entry} !~ /^(notactive|active)$/) {
              $self->{output}->add_option_msg(short_msg => "Wrong thinprovisioning-status option. Can only be 'active' or 'noactive'. Not: '" . $self->{thin_entry} . "'.");
              $self->{output}->option_exit();
          }
          if ($self->{output}->is_litteral_status(status => $self->{thin_status}) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong thinprovisioning-status option. Not a good status: '" . $self->{thin_status} . "'.");
              $self->{output}->option_exit();
          }
      }
  }
  
  sub display_verbose {
      my ($self, %options) = @_;
      
      foreach my $vm (sort keys %{$options{vms}}) {
          my $prefix = $vm;
          if (defined($options{vms}->{$vm}->{description}) && $options{vms}->{$vm}->{description} ne '') {
              $prefix .= ' [' . $options{vms}->{$vm}->{description} . ']';
          }
          $self->{output}->output_add(long_msg => $prefix);
          foreach my $disk (sort keys %{$options{vms}->{$vm}->{disks}}) {
              $self->{output}->output_add(long_msg => '    ' . $disk);
          }
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'thinprovisioningvm');
  
      my $multiple = 0;
      if (scalar(keys %{$response->{data}}) > 1) {
          $multiple = 1;
      }
      if ($multiple == 1) {
          $self->{output}->output_add(severity => 'OK',
                                                 short_msg => 'All thinprovisoning virtualdisks are ok.');
      } else {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'Thinprovisoning virtualdisks are ok.');
      }
      
      my $disks_vm = {};
      my %maps_match = ('active' => { regexp => '^1$', output => 'VirtualDisks thinprovisioning actived' },
                        'notactive' => { regexp => '^(?!(1)$)', output => 'VirtualDisks thinprovisioning not actived' });
      my $num = 0;    
      foreach my $vm_id (sort keys %{$response->{data}}) {
          my $vm_name = $response->{data}->{$vm_id}->{name};
          
          if ($options{custom}->entity_is_connected(state => $response->{data}->{$vm_id}->{connection_state}) == 0) {
              my $output = "VM '" . $vm_name . "' not connected. Current Connection State: '$response->{data}->{$vm_id}->{connection_state}'.";
              if ($multiple == 0 ||  
                  !$self->{output}->is_status(value => $self->{option_results}->{disconnect_status}, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $self->{option_results}->{disconnect_status},
                                              short_msg => $output);
              }
              next;
          }
      
          next if (defined($self->{option_results}->{nopoweredon_skip}) && 
                   $options{custom}->vm_is_running(power => $response->{data}->{$vm_id}->{power_state}) == 0);
          
          foreach (@{$response->{data}->{$vm_id}->{disks}}) {
              if (defined($self->{thin_entry}) && $_->{thin_provisioned} =~ /$maps_match{$self->{thin_entry}}->{regexp}/) {
                  $num++;
                  if (!defined($disks_vm->{$vm_name})) {
                      $disks_vm->{$vm_name} = { disks => {}, description => (defined($self->{option_results}->{display_description}) ? $options{custom}->strip_cr(value => $response->{data}->{$vm_id}->{'config.annotation'}) : undef) };
                  }
                  $disks_vm->{$vm_name}->{disks}->{$_->{name}} = 1;
              }
          }
      }
      
      if ($num > 0) {
          $self->{output}->output_add(severity => $self->{thin_status},
                                      short_msg => sprintf('%d %s', $num, $maps_match{$self->{thin_entry}}->{output}));
          $self->display_verbose(vms => $disks_vm);
      }
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check virtual machine thin provisioning option.
  
  =over 8
  
  =item B<--vm-hostname>
  
  VM hostname to check.
  If not set, we check all VMs.
  
  =item B<--filter>
  
  VM hostname is a regexp.
  
  =item B<--filter-description>
  
  Filter also virtual machines description (can be a regexp).
  
  =item B<--filter-os>
  
  Filter also virtual machines OS name (can be a regexp).
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--scope-host>
  
  Search in following host(s) (can be a regexp).
  
  =item B<--disconnect-status>
  
  Status if VM disconnected (default: 'unknown').
  
  =item B<--nopoweredon-skip>
  
  Skip check if VM is not poweredOn.
  
  =item B<--display-description>
  
  Display virtual machine description.
  
  =item B<--thinprovisioning-status>
  
  Thinprovisioning status (default: none)
  Example: 'active,CRITICAL' or 'notactive,WARNING'
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_THINPROVISIONINGVM

$fatpacked{"apps/vmware/connector/mode/timehost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_TIMEHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::timehost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Date::Parse;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{status};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      return 0;
  }
  
  sub custom_time_output {
      my ($self, %options) = @_;
  
      my $msg = sprintf("time offset %d second(s) : %s",
                        $self->{result_values}->{offset_absolute}, $self->{result_values}->{date_absolute});
      return $msg;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'host', type => 1, cb_prefix_output => 'prefix_host_output', message_multiple => 'All hosts are ok', skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{host} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' }, { name => 'display' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'time', nlabel => 'host.time.offset.seconds', set => {
                  key_values => [ { name => 'offset' }, { name => 'date' }, { name => 'display' } ],
                  closure_custom_output => $self->can('custom_time_output'),
                  perfdatas => [
                      { label => 'offset', value => 'offset_absolute', template => '%.2f',
                        unit => 's', label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "esx-hostname:s"        => { name => 'esx_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{status} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'timehost');
      
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          
          my $offset;
          if (defined($response->{data}->{$host_id}->{current_time})) {
              my $timestamp = Date::Parse::str2time($response->{data}->{$host_id}->{current_time});
              $offset = time() - $timestamp;
          }
          
          $self->{host}->{$host_name} = { 
              display => $host_name, 
              state => $response->{data}->{$host_id}->{state},
              offset => $offset,
              date => $response->{data}->{$host_id}->{current_time},
          };
      }    
  }
  
  1;
  
  
  =head1 MODE
  
  Check ESX time.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--warning-time>
  
  Threshold warning in seconds.
  
  =item B<--critical-time>
  
  Threshold critical in seconds.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_TIMEHOST

$fatpacked{"apps/vmware/connector/mode/toolsvm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_TOOLSVM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::toolsvm;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "vm-hostname:s"           => { name => 'vm_hostname' },
          "filter"                  => { name => 'filter' },
          "scope-datacenter:s"      => { name => 'scope_datacenter' },
          "scope-cluster:s"         => { name => 'scope_cluster' },
          "scope-host:s"            => { name => 'scope_host' },
          "filter-description:s"    => { name => 'filter_description' },
          "filter-os:s"             => { name => 'filter_os' },
          "filter-uuid:s"           => { name => 'filter_uuid' },
          "display-description"     => { name => 'display_description' },
          "disconnect-status:s"     => { name => 'disconnect_status', default => 'unknown' },
          "tools-notinstalled-status:s"   => { name => 'tools_notinstalled_status', default => 'critical' },
          "tools-notrunning-status:s"     => { name => 'tools_notrunning_status', default => 'critical' },
          "tools-notup2date-status:s"     => { name => 'tools_notupd2date_status', default => 'warning' },
          "nopoweredon-skip"              => { name => 'nopoweredon_skip' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      if ($self->{output}->is_litteral_status(status => $self->{option_results}->{disconnect_status}) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong disconnect-status option '" . $self->{option_results}->{disconnect_status} . "'.");
          $self->{output}->option_exit();
      }
      if ($self->{output}->is_litteral_status(status => $self->{option_results}->{tools_notinstalled_status}) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong tools-notinstalled-status option '" . $self->{option_results}->{tools_notinstalled_status} . "'.");
          $self->{output}->option_exit();
      }
      if ($self->{output}->is_litteral_status(status => $self->{option_results}->{tools_notrunning_status}) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong tools-notrunning-status option '" . $self->{option_results}->{tools_notrunning_status} . "'.");
          $self->{output}->option_exit();
      }
      if ($self->{output}->is_litteral_status(status => $self->{option_results}->{tools_notupd2date_status}) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong tools-notupd2date-status option '" . $self->{option_results}->{tools_notupd2date_status} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub display_verbose {
      my ($self, %options) = @_;
      
      $self->{output}->output_add(long_msg => $options{label});
      foreach my $vm (sort keys %{$options{vms}}) {
          my $prefix = $vm;
          if ($options{vms}->{$vm} ne '') {
              $prefix .= ' [' . $options{custom}->strip_cr(value => $options{vms}->{$vm}) . ']';
          }
          $self->{output}->output_add(long_msg => '    ' . $prefix);
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'toolsvm');
  
      my $multiple = 0;
      if (scalar(keys %{$response->{data}}) > 1) {
          $multiple = 1;
      }
      if ($multiple == 1) {
          $self->{output}->output_add(severity => 'OK',
                                                 short_msg => 'All VMTools are OK');
      } else {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'VMTools are OK');
      }
      
      my %not_installed = ();
      my %not_running = ();
      my %not_up2date = ();
      foreach my $vm_id (sort keys %{$response->{data}}) {
          my $vm_name = $response->{data}->{$vm_id}->{name};
          
          if ($options{custom}->entity_is_connected(state => $response->{data}->{$vm_id}->{connection_state}) == 0) {
              my $output = "VM '" . $vm_name . "' not connected. Current Connection State: '$response->{data}->{$vm_id}->{connection_state}'.";
              if ($multiple == 0 ||  
                  !$self->{output}->is_status(value => $self->{option_results}->{disconnect_status}, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $self->{option_results}->{disconnect_status},
                                              short_msg => $output);
              }
              next;
          }
      
          next if (defined($self->{option_results}->{nopoweredon_skip}) && 
                   $options{custom}->vm_is_running(power => $response->{data}->{$vm_id}->{power_state}) == 0);
          
          next if (!defined($response->{data}->{$vm_id}->{tools_status}));
          
          my $tools_status = lc($response->{data}->{$vm_id}->{tools_status});
          if ($tools_status eq 'toolsnotinstalled') {
              $not_installed{$vm_name} = defined($response->{data}->{$vm_id}->{'config.annotation'}) ? $response->{data}->{$vm_id}->{'config.annotation'} : '';
          } elsif ($tools_status eq 'toolsnotrunning') {
              $not_running{$vm_name} = defined($response->{data}->{$vm_id}->{'config.annotation'}) ? $response->{data}->{$vm_id}->{'config.annotation'} : '';
          } elsif ($tools_status eq 'toolsold') {
              $not_up2date{$vm_name} = defined($response->{data}->{$vm_id}->{'config.annotation'}) ? $response->{data}->{$vm_id}->{'config.annotation'} : '';
          }
      }
      
      if (scalar(keys %not_up2date) > 0 && 
          !$self->{output}->is_status(value => $self->{option_results}->{tools_notupd2date_status}, compare => 'ok', litteral => 1)) {
          $self->{output}->output_add(severity => $self->{option_results}->{tools_notupd2date_status},
                                                 short_msg => sprintf('%d VM with VMTools not up-to-date', scalar(keys %not_up2date)));
          $self->display_verbose(label => 'vmtools not up-to-date:', vms => \%not_up2date, custom => $options{custom});
      }
      if (scalar(keys %not_running) > 0 &&
          !$self->{output}->is_status(value => $self->{option_results}->{tools_notrunning_status}, compare => 'ok', litteral => 1)) {
          $self->{output}->output_add(severity => $self->{option_results}->{tools_notrunning_status},
                                                 short_msg => sprintf('%d VM with VMTools not running', scalar(keys %not_running)));
          $self->display_verbose(label => 'vmtools not running:', vms => \%not_running, custom => $options{custom});
      }
      if (scalar(keys %not_installed) > 0 &&
          !$self->{output}->is_status(value => $self->{option_results}->{tools_notinstalled_status}, compare => 'ok', litteral => 1)) {
          $self->{output}->output_add(severity => $self->{option_results}->{tools_notinstalled_status},
                                                 short_msg => sprintf('%d VM with VMTools not installed', scalar(keys %not_installed)));
          $self->display_verbose(label => 'vmtools not installed:', vms => \%not_installed, custom => $options{custom});
      }
      
      if ($multiple == 1) {
          my $total = scalar(keys %not_up2date) + scalar(keys %not_running) + scalar(keys %not_installed);
          $self->{output}->perfdata_add(
              label => 'not_updated',
              nlabel => 'vm.tools.notupdated.current.count',
              value => scalar(keys %not_up2date),
              min => 0, max => $total
          );
          $self->{output}->perfdata_add(
              label => 'not_running',
              nlabel => 'vm.tools.notrunning.current.count',
              value => scalar(keys %not_running),
              min => 0, max => $total
          );
          $self->{output}->perfdata_add(
              label => 'not_installed',
              nlabel => 'vm.tools.notinstalled.current.count',
              value => scalar(keys %not_installed),
              min => 0, max => $total
          );
      }
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check virtual machine tools.
  
  =over 8
  
  =item B<--vm-hostname>
  
  VM hostname to check.
  If not set, we check all VMs.
  
  =item B<--filter>
  
  VM hostname is a regexp.
  
  =item B<--filter-description>
  
  Filter also virtual machines description (can be a regexp).
  
  =item B<--filter-os>
  
  Filter also virtual machines OS name (can be a regexp).
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--scope-host>
  
  Search in following host(s) (can be a regexp).
  
  =item B<--disconnect-status>
  
  Status if VM disconnected (default: 'unknown').
  
  =item B<--nopoweredon-skip>
  
  Skip check if VM is not poweredOn.
  
  =item B<--display-description>
  
  Display virtual machine description.
  
  =item B<--tools-notinstalled-status>
  
  Status if vmtools is not installed (default: critical).
  
  =item B<--tools-notrunning-status>
  
  Status if vmtools is not running (default: critical).
  
  =item B<--tools-notup2date-status>
  
  Status if vmtools is not upd2date (default: warning).
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_TOOLSVM

$fatpacked{"apps/vmware/connector/mode/uptimehost.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_UPTIMEHOST';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::uptimehost;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Date::Parse;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'status ' . $self->{result_values}->{status};
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_state'};
      return 0;
  }
  
  sub custom_time_output {
      my ($self, %options) = @_;
  
      my $msg = sprintf("Uptime: %s day(s)",
                        int($self->{result_values}->{offset_absolute} / 60 / 60 / 24));
      return $msg;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'host', type => 1, cb_prefix_output => 'prefix_host_output', message_multiple => 'All hosts are ok', skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{host} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' }, { name => 'display' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'time', nlabel => 'host.uptime.offset.seconds', set => {
                  key_values => [ { name => 'offset' }, { name => 'date' }, { name => 'display' } ],
                  closure_custom_output => $self->can('custom_time_output'),
                  perfdatas => [
                      { label => 'uptime', value => 'offset_absolute', template => '%.2f',
                        unit => 's', label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_host_output {
      my ($self, %options) = @_;
  
      return "Host '" . $options{instance_value}->{display} . "' : ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "esx-hostname:s"        => { name => 'esx_hostname' },
          "filter"                => { name => 'filter' },
          "scope-datacenter:s"    => { name => 'scope_datacenter' },
          "scope-cluster:s"       => { name => 'scope_cluster' },
          "unknown-status:s"      => { name => 'unknown_status', default => '%{status} !~ /^connected$/i' },
          "warning-status:s"      => { name => 'warning_status', default => '' },
          "critical-status:s"     => { name => 'critical_status', default => '' },
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
      
      $self->change_macros(macros => ['unknown_status', 'warning_status', 'critical_status']);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{host} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'uptimehost');
      
      foreach my $host_id (keys %{$response->{data}}) {
          my $host_name = $response->{data}->{$host_id}->{name};
          
          my $offset;
          if (defined($response->{data}->{$host_id}->{boot_time})) {
              my $timestamp = Date::Parse::str2time($response->{data}->{$host_id}->{boot_time});
              $offset = time() - $timestamp;
          }
          
          $self->{host}->{$host_name} = { 
              display => $host_name, 
              state => $response->{data}->{$host_id}->{state},
              offset => $offset,
              date => $response->{data}->{$host_id}->{boot_time},
          };
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check ESX uptime.
  
  =over 8
  
  =item B<--esx-hostname>
  
  ESX hostname to check.
  If not set, we check all ESX.
  
  =item B<--filter>
  
  ESX hostname is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--scope-cluster>
  
  Search in following cluster(s) (can be a regexp).
  
  =item B<--unknown-status>
  
  Set warning threshold for status (Default: '%{status} !~ /^connected$/i').
  Can used special variables like: %{status}
  
  =item B<--warning-status>
  
  Set warning threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--critical-status>
  
  Set critical threshold for status (Default: '').
  Can used special variables like: %{status}
  
  =item B<--warning-time>
  
  Threshold warning in seconds.
  
  =item B<--critical-time>
  
  Threshold critical in seconds.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_UPTIMEHOST

$fatpacked{"apps/vmware/connector/mode/vmoperationcluster.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_MODE_VMOPERATIONCLUSTER';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::mode::vmoperationcluster;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'cluster', type => 1, cb_prefix_output => 'prefix_cluster_output', message_multiple => 'All virtual machine operations are ok', skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{cluster} = [
          { label => 'svmotion', nlabel => 'cluster.operations.svmotion.current.count', set => {
                  key_values => [ { name => 'numSVMotion', diff => 1  }, { name => 'display' } ],
                  output_template => 'SVMotion %s',
                  perfdatas => [
                      { label => 'svmotion', value => 'numSVMotion_absolute', template => '%s',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'vmotion', nlabel => 'cluster.operations.vmotion.current.count', set => {
                  key_values => [ { name => 'numVMotion', diff => 1  }, { name => 'display' } ],
                  output_template => 'VMotion %s',
                  perfdatas => [
                      { label => 'vmotion', value => 'numVMotion_absolute', template => '%s',
                        label_extra_instance => 1 },
                  ],
              }
          },
          { label => 'clone', nlabel => 'cluster.operations.clone.current.count', set => {
                  key_values => [ { name => 'numClone', diff => 1  }, { name => 'display' } ],
                  output_template => 'Clone %s',
                  perfdatas => [
                      { label => 'clone', value => 'numClone_absolute', template => '%s',
                        label_extra_instance => 1 },
                  ],
              }
          },
      ];
  }
  
  sub prefix_cluster_output {
      my ($self, %options) = @_;
  
      return "Cluster '" . $options{instance_value}->{display} . "' vm operations: ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          "cluster:s"               => { name => 'cluster' },
          "filter"                  => { name => 'filter' },
          "scope-datacenter:s"      => { name => 'scope_datacenter' },
      });
      
      return $self;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{cluster} = {};
      my $response = $options{custom}->execute(params => $self->{option_results},
          command => 'vmoperationcluster');
      
      foreach my $cluster_id (keys %{$response->{data}}) {
          my $cluster_name = $response->{data}->{$cluster_id}->{name};        
          $self->{cluster}->{$cluster_name} = { 
              display => $cluster_name, 
              numVMotion => $response->{data}->{$cluster_id}->{'vmop.numVMotion.latest'},
              numClone => $response->{data}->{$cluster_id}->{'vmop.numClone.latest'},
              numSVMotion => $response->{data}->{$cluster_id}->{'vmop.numSVMotion.latest'},
          };
      }
      
      $self->{cache_name} = "cache_vmware_" . $options{custom}->get_id() . '_' . $self->{mode} . '_' .
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all')) . '_' .
          (defined($self->{option_results}->{cluster}) ? md5_hex($self->{option_results}->{cluster}) : md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Check virtual machines operations on cluster(s).
  
  =over 8
  
  =item B<--cluster>
  
  Cluster to check.
  If not set, we check all clusters.
  
  =item B<--filter>
  
  Cluster is a regexp.
  
  =item B<--scope-datacenter>
  
  Search in following datacenter(s) (can be a regexp).
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: svmotion, vmotion, clone.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: svmotion, vmotion, clone.
  
  =back
  
  =cut
APPS_VMWARE_CONNECTOR_MODE_VMOPERATIONCLUSTER

$fatpacked{"apps/vmware/connector/plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPS_VMWARE_CONNECTOR_PLUGIN';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package apps::vmware::connector::plugin;
  
  use strict;
  use warnings;
  use base qw(centreon::plugins::script_custom);
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $self->{version} = '0.1';
      %{$self->{modes}} = (
          'alarm-datacenter'     => 'apps::vmware::connector::mode::alarmdatacenter',
          'alarm-host'           => 'apps::vmware::connector::mode::alarmhost',
          'countvm-host'         => 'apps::vmware::connector::mode::countvmhost', 
          'cpu-host'             => 'apps::vmware::connector::mode::cpuhost', 
          'cpu-vm'               => 'apps::vmware::connector::mode::cpuvm',
          'datastore-countvm'    => 'apps::vmware::connector::mode::datastorecountvm',
          'datastore-host'       => 'apps::vmware::connector::mode::datastorehost',
          'datastore-io'         => 'apps::vmware::connector::mode::datastoreio',
          'datastore-iops'       => 'apps::vmware::connector::mode::datastoreiops',
          'datastore-snapshot'   => 'apps::vmware::connector::mode::datastoresnapshot',
          'datastore-usage'      => 'apps::vmware::connector::mode::datastoreusage',
          'datastore-vm'         => 'apps::vmware::connector::mode::datastorevm',
          'device-vm'            => 'apps::vmware::connector::mode::devicevm', 
          'discovery'            => 'apps::vmware::connector::mode::discovery', 
          'getmap'               => 'apps::vmware::connector::mode::getmap',
          'health-host'          => 'apps::vmware::connector::mode::healthhost',
          'limit-vm'             => 'apps::vmware::connector::mode::limitvm',
          'list-clusters'        => 'apps::vmware::connector::mode::listclusters',
          'list-datacenters'     => 'apps::vmware::connector::mode::listdatacenters',
          'list-datastores'      => 'apps::vmware::connector::mode::listdatastores',
          'list-nichost'         => 'apps::vmware::connector::mode::listnichost',
          'maintenance-host'     => 'apps::vmware::connector::mode::maintenancehost',
          'memory-host'          => 'apps::vmware::connector::mode::memoryhost',
          'memory-vm'            => 'apps::vmware::connector::mode::memoryvm',
          'net-host'             => 'apps::vmware::connector::mode::nethost',
          'service-host'         => 'apps::vmware::connector::mode::servicehost',
          'snapshot-vm'          => 'apps::vmware::connector::mode::snapshotvm',
          'stat-connectors'      => 'apps::vmware::connector::mode::statconnectors',
          'status-host'          => 'apps::vmware::connector::mode::statushost',
          'status-vm'            => 'apps::vmware::connector::mode::statusvm',
          'swap-host'            => 'apps::vmware::connector::mode::swaphost',
          'swap-vm'              => 'apps::vmware::connector::mode::swapvm',
          'thinprovisioning-vm'  => 'apps::vmware::connector::mode::thinprovisioningvm',
          'time-host'            => 'apps::vmware::connector::mode::timehost',
          'tools-vm'             => 'apps::vmware::connector::mode::toolsvm',
          'uptime-host'          => 'apps::vmware::connector::mode::uptimehost',
          'vmoperation-cluster'  => 'apps::vmware::connector::mode::vmoperationcluster',
      );
  
      $self->{custom_modes}{connector} = 'apps::vmware::connector::custom::connector';
      return $self;
  }
  
  1;
  
  
  =head1 PLUGIN DESCRIPTION
  
  Check VMWare with centreon-vmware connector.
  
  =cut
APPS_VMWARE_CONNECTOR_PLUGIN

$fatpacked{"centreon/plugins/alternative/FatPackerOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_ALTERNATIVE_FATPACKEROPTIONS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::alternative::FatPackerOptions;
  
  use base qw(centreon::plugins::options);
  
  use strict;
  use warnings;
  use Pod::Usage;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      return $self;
  }
  
  sub display_help {
      my ($self, %options) = @_;
      
      my $stdout;
      foreach (@{$self->{pod_package}}) {
          
          {
              my $pp = $_->{package} . ".pm";
              $pp =~ s{::}{/}g;
              my $content_class = $INC{$pp}->{$pp};
              open my $str_fh, '<', \$content_class;
              
              local *STDOUT;
              open STDOUT, '>', \$stdout;
              pod2usage(-exitval => 'NOEXIT', -input => $str_fh,
                        -verbose => 99, 
                        -sections => $_->{sections});
              
              close $str_fh;
          }
          
          $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
      }
  }
  
  1;
  
CENTREON_PLUGINS_ALTERNATIVE_FATPACKEROPTIONS

$fatpacked{"centreon/plugins/alternative/Getopt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_ALTERNATIVE_GETOPT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::alternative::Getopt;
  
  use strict;
  use warnings;
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  BEGIN {
      @EXPORT    = qw(&GetOptions);
      @EXPORT_OK = qw();
  }
  
  use vars @EXPORT, @EXPORT_OK;
  
  our $warn_message = 0;
  
  sub get_assigned_value {
      my (%options) = @_;
      
      if (!defined($options{val}) || $options{val} eq '') {
          # Add defined also. Hardened code: already see: $ARGV[6] = undef for example
          if ($options{pos} + 1 < $options{num_args} && defined($ARGV[$options{pos} + 1]) && $ARGV[$options{pos} + 1] !~ /^--/) {
              my $val = $ARGV[$options{pos} + 1];
              splice @ARGV, $options{pos} + 1, 1;
              return ($options{num_args} - 1, $val);
          } else {
              return ($options{num_args}, '');
          }
      }
      
      return ($options{num_args}, $options{val});
  }
  
  sub GetOptions {
      my (%opts) = @_;
      
      my $search_str = ',' . join(',', keys %opts) . ',';
      my $num_args = scalar(@ARGV);
      for (my $i = 0; $i < $num_args;) {
          if (defined($ARGV[$i]) && $ARGV[$i] =~ /^--(.*?)(?:=|$)(.*)/) {
              my ($option, $value) = ($1, $2);
              
              # find type of option
              if ($search_str !~ /,((?:[^,]*?\|){0,}$option(?:\|.*?){0,}(:.*?){0,1}),/) {
                  warn "Unknown option: $option" if ($warn_message == 1);
                  $i++;
                  next;
              }
              
              my ($option_selected, $type_opt) = ($1, $2);
              if (!defined($type_opt)) {
                  ${$opts{$option_selected}} = 1;
              } elsif ($type_opt =~ /:s$/) {
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  ${$opts{$option_selected}} = $assigned;
              } elsif ($type_opt =~ /:s\@$/) {
                  ${$opts{$option . $type_opt}} = [] if (!defined(${$opts{$option . $type_opt}}));
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  push @{${$opts{$option_selected}}}, $assigned;
              } elsif ($type_opt =~ /:s\%$/) {
                  ${$opts{$option . $type_opt}} = {} if (!defined(${$opts{$option . $type_opt}}));
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  if ($assigned =~ /^(.*?)=(.*)/) {
                      ${$opts{$option_selected}}->{$1} = $2;
                  }
              } 
              
              splice @ARGV, $i, 1;
              $num_args--;
          } else {
              warn "argument $ARGV[$i] alone" if ($warn_message == 1 && $i != 0 && defined($ARGV[$i]));
              $i++;
          }
      }
  }
  
  1;
  
CENTREON_PLUGINS_ALTERNATIVE_GETOPT

$fatpacked{"centreon/plugins/misc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MISC';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::misc;
  
  use strict;
  use warnings;
  use utf8;
  
  sub execute {
      my (%options) = @_;
      
      if ($^O eq 'MSWin32') {
          return windows_execute(%options, timeout => $options{options}->{timeout});
      } else {
          return unix_execute(%options);
      }
  }
  
  sub windows_execute {
      my (%options) = @_;
      my $result;
      my ($stdout, $pid, $ended) = ('');
      my ($exit_code, $cmd);
      
      $cmd = $options{command_path} . '/' if (defined($options{command_path}));
      $cmd .= $options{command} . ' ' if (defined($options{command}));
      $cmd .= $options{command_options} if (defined($options{command_options}));
      
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'Win32::Job',
                                             error_msg => "Cannot load module 'Win32::Job'.");
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'Time::HiRes',
                                             error_msg => "Cannot load module 'Time::HiRes'.");
      
      $| = 1;
      pipe FROM_CHILD, TO_PARENT or do {
          $options{output}->add_option_msg(short_msg => "Internal error: can't create pipe from child to parent: $!");
          $options{output}->option_exit();
      };
      my $job = Win32::Job->new;
      my $stderr = 'NUL';
      $stderr = \*TO_PARENT if ($options{output}->is_debug());
      if (!($pid = $job->spawn(undef, $cmd,
                         { stdin => 'NUL',
                           stdout => \*TO_PARENT,
                           stderr => $stderr }))) {
          $options{output}->add_option_msg(short_msg => "Internal error: execution issue: $^E");
          $options{output}->option_exit();
      }
      close TO_PARENT;
  
      my $ein = '';
      vec($ein, fileno(FROM_CHILD), 1) = 1;
      $job->watch(
          sub {            
              my ($buffer);
              my $time = $options{timeout};
              my $last_time = Time::HiRes::time();
              $ended = 0;
              while (select($ein, undef, undef, $options{timeout})) {
                  if (sysread(FROM_CHILD, $buffer, 16384)) {
                      $buffer =~ s/\r//g;
                      $stdout .= $buffer;
                  } else {
                      $ended = 1;
                      last;
                  }
                  $options{timeout} -= Time::HiRes::time() - $last_time;
                  last if ($options{timeout} <= 0);         
                  $last_time = Time::HiRes::time();
              }
              return 1 if ($ended == 0);
              return 0;
          },
          0.1
      );
          
      $result = $job->status;
      close FROM_CHILD;    
      
      if ($ended == 0) {
          $options{output}->add_option_msg(short_msg => 'Command too long to execute (timeout)...');
          $options{output}->option_exit();
      }
      chomp $stdout;
      
      if (defined($options{no_quit}) && $options{no_quit} == 1) {
          return ($stdout, $result->{$pid}->{exitcode});
      }
      
      if ($result->{$pid}->{exitcode} != 0) {
          $stdout =~ s/\n/ - /g;
          $options{output}->add_option_msg(short_msg => "Command error: $stdout");
          $options{output}->option_exit();
      }
      
      return ($stdout, $result->{$pid}->{exitcode});
  }
  
  sub unix_execute {
      my (%options) = @_;
      my $cmd = '';
      my $args = [];
      my ($lerror, $stdout, $exit_code);
  
      my $redirect_stderr = 1;
      $redirect_stderr = $options{redirect_stderr} if (defined($options{redirect_stderr}));
      my $wait_exit = 1;
      $wait_exit = $options{wait_exit} if (defined($options{wait_exit}));
      
      # Build command line
      # Can choose which command is done remotely (can filter and use local file)
      if (defined($options{options}->{remote}) && 
          ($options{options}->{remote} eq '' || !defined($options{label}) || $options{label} =~ /$options{options}->{remote}/)) {
          my $sub_cmd;
  
          $cmd = $options{options}->{ssh_path} . '/' if (defined($options{options}->{ssh_path}));
          $cmd .= $options{options}->{ssh_command} if (defined($options{options}->{ssh_command}));
          
          foreach (@{$options{options}->{ssh_option}}) {
              my ($lvalue, $rvalue) = split /=/;
              push @$args, $lvalue if (defined($lvalue));
              push @$args, $rvalue if (defined($rvalue));
          }
          
          if (defined($options{options}->{ssh_address}) && $options{options}->{ssh_address} ne '') {
              push @$args, $options{options}->{ssh_address};
          } else {
              push @$args, $options{options}->{hostname};
          }
  		
          $sub_cmd = 'sudo ' if (defined($options{sudo}));
          $sub_cmd .= $options{command_path} . '/' if (defined($options{command_path}));
          $sub_cmd .= $options{command} . ' ' if (defined($options{command}));
          $sub_cmd .= $options{command_options} if (defined($options{command_options}));
          # On some equipment. Cannot get a pseudo terminal
          if (defined($options{ssh_pipe}) && $options{ssh_pipe} == 1) {
              $cmd = "echo '" . $sub_cmd . "' | " . $cmd . ' ' . join(' ', @$args);
              ($lerror, $stdout, $exit_code) = backtick(
                  command => $cmd,
                  timeout => $options{options}->{timeout},
                  wait_exit => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          } else {
              ($lerror, $stdout, $exit_code) = backtick(
                  command => $cmd,
                  arguments => [@$args, $sub_cmd],
                  timeout => $options{options}->{timeout},
                  wait_exit => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          }
      } else {
          $cmd = 'sudo ' if (defined($options{sudo}));
          $cmd .= $options{command_path} . '/' if (defined($options{command_path}));
          $cmd .= $options{command} . ' ' if (defined($options{command}));
          $cmd .= $options{command_options} if (defined($options{command_options}));
          
          ($lerror, $stdout, $exit_code) = backtick(
              command => $cmd,
              timeout => $options{options}->{timeout},
              wait_exit => $wait_exit,
              redirect_stderr => $redirect_stderr
          );
      }
  
      if (defined($options{options}->{show_output}) && 
          ($options{options}->{show_output} eq '' || (defined($options{label}) && $options{label} eq $options{options}->{show_output}))) {
          print $stdout;
          exit $exit_code;
      }
      
      $stdout =~ s/\r//g;
      if ($lerror <= -1000) {
          $options{output}->add_option_msg(short_msg => $stdout);
          $options{output}->option_exit();
      }
      
      if (defined($options{no_quit}) && $options{no_quit} == 1) {
          return ($stdout, $exit_code);
      }
      
      if ($exit_code != 0 && (!defined($options{no_errors}) || !defined($options{no_errors}->{$exit_code}))) {
          $stdout =~ s/\n/ - /g;
          $options{output}->add_option_msg(short_msg => "Command error: $stdout");
          $options{output}->option_exit();
      }
      
      return $stdout;
  }
  
  sub mymodule_load {
      my (%options) = @_;
      my $file;
      ($file = ($options{module} =~ /\.pm$/ ? $options{module} : $options{module} . '.pm')) =~ s{::}{/}g;
      
      eval {
          local $SIG{__DIE__} = 'IGNORE';
          require $file;
          $file =~ s{/}{::}g;
          $file =~ s/\.pm$//;
      };
      if ($@) {
          return 1 if (defined($options{no_quit}) && $options{no_quit} == 1);
          $options{output}->add_option_msg(long_msg => $@);
          $options{output}->add_option_msg(short_msg => $options{error_msg});
          $options{output}->option_exit();
      }
      return wantarray ? (0, $file) : 0;
  }
  
  sub backtick {
      my %arg = (
          command => undef,
          arguments => [],
          timeout => 30,
          wait_exit => 0,
          redirect_stderr => 0,
          @_,
      );
      my @output;
      my $pid;
      my $return_code;
      
      my $sig_do;
      if ($arg{wait_exit} == 0) {
          $sig_do = 'IGNORE';
          $return_code = undef;
      } else {
          $sig_do = 'DEFAULT';
      }
      local $SIG{CHLD} = $sig_do;
      $SIG{TTOU} = 'IGNORE';
      $| = 1;
  
      if (!defined($pid = open( KID, "-|" ))) {
          return (-1001, "Cant fork: $!", -1);
      }
  
      if ($pid) {
          
          eval {
             local $SIG{ALRM} = sub { die "Timeout by signal ALARM\n"; };
             alarm( $arg{timeout} );
             while (<KID>) {
                 chomp;
                 push @output, $_;
             }
  
             alarm(0);
          };
  
          if ($@) {
              if ($pid != -1) {
                  kill -9, $pid;
              }
  
              alarm(0);
              return (-1000, 'Command too long to execute (timeout)...', -1);
          } else {
              if ($arg{wait_exit} == 1) {
                  # We're waiting the exit code                
                  waitpid($pid, 0);
                  $return_code = ($? >> 8);
              }
              close KID;
          }
      } else {
          # child
          # set the child process to be a group leader, so that
          # kill -9 will kill it and all its descendents
          # We have ignore SIGTTOU to let write background processes
          setpgrp( 0, 0 );
  
          if ($arg{redirect_stderr} == 1) {
              open STDERR, '>&STDOUT';
          }
          if (scalar(@{$arg{arguments}}) <= 0) {
              exec($arg{command});
          } else {
              exec($arg{command}, @{$arg{arguments}});
          }
          # Exec is in error. No such command maybe.
          exit(127);
      }
  
      return (0, join("\n", @output), $return_code);
  }
  
  sub trim {
      my ($value) = $_[0];
      
      # Sometimes there is a null character
      $value =~ s/\x00$//;
      $value =~ s/^[ \t\n]+//;
      $value =~ s/[ \t\n]+$//;
      return $value;
  }
  
  sub powershell_encoded {
      my ($value) = $_[0];
  
      require Encode;
      require MIME::Base64;
      my $bytes = Encode::encode('utf16LE', $value);
      my $script = MIME::Base64::encode_base64($bytes, "\n");
      $script =~ s/\n//g;
      return $script;
  }
  
  sub powershell_escape {
      my ($value) = $_[0];
      $value =~ s/`/``/g;
      $value =~ s/#/`#/g;
      $value =~ s/'/`'/g;
      $value =~ s/"/`"/g;
      return $value;
  }
  
  sub powershell_json_sanitizer {
      my (%options) = @_;
  
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'JSON::XS',
                                             error_msg => "Cannot load module 'JSON::XS'.");
      foreach my $line (split /\n/, $options{string}) {
          eval { JSON::XS->new->utf8->decode($line) };
          return $line if (!$@);
      }
      return -1;
  }
  
  sub minimal_version {
      my ($version_src, $version_dst) = @_;
          
      # No Version. We skip   
      if (!defined($version_src) || !defined($version_dst) || 
          $version_src !~ /^[0-9]+(?:\.[0-9\.]+)*$/ || $version_dst !~ /^[0-9x]+(?:\.[0-9x]+)*$/) {
          return 1;
      }
    
      my @version_src = split /\./, $version_src;
      my @versions = split /\./, $version_dst;
      for (my $i = 0; $i < scalar(@versions); $i++) {
          return 1 if ($versions[$i] eq 'x');
          return 1 if (!defined($version_src[$i]));
          $version_src[$i] =~ /^([0-9]*)/;
          next if ($versions[$i] == int($1));
          return 0 if ($versions[$i] > int($1));
          return 1 if ($versions[$i] < int($1));
      }
      
      return 1;
  }
  
  sub change_seconds {
      my %options = @_;
      my ($str, $str_append) = ('', '');
      my $periods = [
          { unit => 'y', value => 31556926 },
          { unit => 'M', value => 2629743 },
          { unit => 'w', value => 604800 },
          { unit => 'd', value => 86400 },
          { unit => 'h', value => 3600 },
          { unit => 'm', value => 60 },
          { unit => 's', value => 1 },
      ];
      my %values = ('y' => 1, 'M' => 2, 'w' => 3, 'd' => 4, 'h' => 5, 'm' => 6, 's' => 7);
  
      foreach (@$periods) {
          next if (defined($options{start}) && $values{$_->{unit}} < $values{$options{start}});
          my $count = int($options{value} / $_->{value});
  
          next if ($count == 0);
          $str .= $str_append . $count . $_->{unit};
          $options{value} = $options{value} % $_->{value};
          $str_append = ' ';
      }
  
      return $str;
  }
  
  sub scale_bytesbit {
      my (%options) = @_;
      
      my $base = 1024;
      if (defined($options{dst_unit}) && defined($options{src_unit})) {
          $options{value} *= 8 if ($options{dst_unit} =~ /b/ && $options{src_unit} =~ /B/);
          $options{value} /= 8 if ($options{dst_unit} =~ /B/ && $options{src_unit} =~ /b/);
          if ($options{dst_unit} =~ /b/) {
              $base = 1000;
          }
      }
          
      my %expo = ('' => 0, k => 1, m => 2, g => 3, t => 4, p => 5, e => 6);
      my ($src_expo, $dst_expo) = (0, 0);
      $src_expo = $expo{lc($options{src_quantity})} if (defined($options{src_quantity}) && $options{src_quantity} =~ /[kmgtpe]/i);
      if ($options{dst_unit} eq 'auto') {
          my @auto = ('', 'k', 'm', 'g', 't', 'p', 'e');
          my $i = defined($options{src_quantity}) ? $expo{$options{src_quantity}} : 0;
          for (; $i < scalar(@auto); $i++) {
              last if ($options{value} < $base);
              $options{value} = $options{value} / $base;
          }
  
          return ($options{value}, $auto[$i], $options{src_unit});
      } elsif (defined($options{dst_quantity}) && ($options{dst_quantity} eq '' || $options{dst_quantity} =~ /[kmgtpe]/i )) {
          my $dst_expo = $expo{lc($options{dst_quantity})};
          if ($dst_expo - $src_expo > 0) {
              $options{value} = $options{value} / ($base ** ($dst_expo - $src_expo));
          } elsif ($dst_expo - $src_expo < 0) {
              $options{value} = $options{value} * ($base ** (($dst_expo - $src_expo) * -1));
          }
      }
      
      return $options{value};
  }
  
  sub convert_bytes {
      my (%options) = @_;
  
      my %expo = (k => 1, m => 2, g => 3, t => 4, p => 5);
      my $value = $options{value};
      my $base = defined($options{network}) ? 1000 : 1024;    
      if ($options{unit} =~ /([kmgt])b/i) {
          $value = $value * ($base ** $expo{lc($1)});
      }
  
      return $value;
  }
  
  sub expand_exponential {
      my (%options) = @_;
      
      return $options{value} unless ($options{value} =~ /^(.*)e([-+]?)(.*)$/);
      my ($num, $sign, $exp) = ($1, $2, $3);
      my $sig = $sign eq '-' ? "." . ($exp - 1 + length $num) : '';
      return sprintf("%${sig}f", $options{value});
  }
  
  sub parse_threshold {
      my (%options) = @_;
  
      my $perf = trim($options{threshold});
      my $perf_result = { arobase => 0, infinite_neg => 0, infinite_pos => 0, start => '', end => '' };
  
      my $global_status = 1;    
      if ($perf =~ /^(\@?)((?:~|(?:\+|-)?\d+(?:[\.,]\d+)?(?:[KMGTPE][bB])?|):)?((?:\+|-)?\d+(?:[\.,]\d+)?(?:[KMGTPE][bB])?)?$/) {
          $perf_result->{start} = $2 if (defined($2));
          $perf_result->{end} = $3 if (defined($3));
          $perf_result->{arobase} = 1 if (defined($1) && $1 eq '@');
          $perf_result->{start} =~ s/[\+:]//g;
          $perf_result->{end} =~ s/\+//;
          if ($perf_result->{start} =~ s/([KMGTPE])([bB])//) {
              $perf_result->{start} = scale_bytesbit(
                  value => $perf_result->{start},
                  src_unit => $2, dst_unit => $2,
                  src_quantity => $1, dst_quantity => '',
              );
          }
          if ($perf_result->{end} =~ s/([KMGTPE])([bB])//) {
              $perf_result->{end} = scale_bytesbit(
                  value => $perf_result->{end},
                  src_unit => $2, dst_unit => $2,
                  src_quantity => $1, dst_quantity => '',
              );
          }
          if ($perf_result->{end} eq '') {
              $perf_result->{end} = 1e500;
              $perf_result->{infinite_pos} = 1;
          }
          $perf_result->{start} = 0 if ($perf_result->{start} eq '');      
          $perf_result->{start} =~ s/,/\./;
          $perf_result->{end} =~ s/,/\./;
          
          if ($perf_result->{start} eq '~') {
              $perf_result->{start} = -1e500;
              $perf_result->{infinite_neg} = 1;
          }
      } else {
          $global_status = 0;
      }
  
      return ($global_status, $perf_result);
  }
  
  sub get_threshold_litteral {
      my (%options) = @_;
      
      my $perf_output = ($options{arobase} == 1 ? '@' : '') . 
                        (($options{infinite_neg} == 0) ? $options{start} : '~') . 
                        ':' . 
                        (($options{infinite_pos} == 0) ? $options{end} : '');
      return $perf_output;
  }
  
  sub set_timezone {
      my (%options) = @_;
      
      return {} if (!defined($options{name}) || $options{name} eq '');
       
      centreon::plugins::misc::mymodule_load(output => $options{output}, module => 'DateTime::TimeZone',
                                             error_msg => "Cannot load module 'DateTime::TimeZone'.");
      if (DateTime::TimeZone->is_valid_name($options{name})) {
          return { time_zone => DateTime::TimeZone->new(name => $options{name}) };
      }
      
      # try to manage syntax (:Pacific/Noumea for example)
      if ($options{name} =~ /^:(.*)$/ && DateTime::TimeZone->is_valid_name($1)) {
          return { time_zone => DateTime::TimeZone->new(name => $1) };
      }
  
      return {};
  }
  
  1;
  
  
CENTREON_PLUGINS_MISC

$fatpacked{"centreon/plugins/mode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MODE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::mode;
  
  use strict;
  use warnings;
  use centreon::plugins::perfdata;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{perfdata} = centreon::plugins::perfdata->new(output => $options{output});
      
      %{$self->{option_results}} = ();
      $self->{output} = $options{output};
      $self->{output}->use_new_perfdata(value => 1)
          if (defined($options{force_new_perfdata}) && $options{force_new_perfdata} == 1);
      $self->{mode} = $options{mode};
      $self->{version} = '1.0';
  
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      # options{default} = { mode_xxx => { option_name => option_value }, }
  
      %{$self->{option_results}} = %{$options{option_results}};
      # Manage default value
      return if (!defined($options{default}));
      foreach (keys %{$options{default}}) {
          if ($_ eq $self->{mode}) {
              foreach my $value (keys %{$options{default}->{$_}}) {
                  if (!defined($self->{option_results}->{$value})) {
                      $self->{option_results}->{$value} = $options{default}->{$_}->{$value};
                  }
              }
          }
      }
  }
  
  sub version {
      my ($self, %options) = @_;
      
      $self->{output}->add_option_msg(short_msg => "Mode Version: " . $self->{version});
  }
  
  sub disco_format {
      my ($self, %options) = @_;
  
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
  }
  
  1;
  
  
CENTREON_PLUGINS_MODE

$fatpacked{"centreon/plugins/options.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_OPTIONS';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::options;
  
  use Pod::Usage;
  use Pod::Find qw(pod_where);
  use strict;
  use warnings;
  
  my $alternative = 1;
  
  sub new {
      my ($class) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{sanity} = 0;
      $self->{options_stored} = {};
      $self->{options} = {};
      @{$self->{pod_package}} = ();
      $self->{pod_packages_once} = {};
      
      if ($alternative == 0) {
          require Getopt::Long;
          Getopt::Long->import();
          Getopt::Long::Configure("pass_through");
          Getopt::Long::Configure('bundling');
          Getopt::Long::Configure('no_auto_abbrev');
      } else {
          require centreon::plugins::alternative::Getopt;
          $centreon::plugins::alternative::Getopt::warn_message = 0;
          centreon::plugins::alternative::Getopt->import();
      }
      
      return $self;
  }
  
  sub set_sanity {
      my ($self, %options) = @_;
      
      if ($alternative == 0) {
          Getopt::Long::Configure('no_pass_through');
      } else {
          $centreon::plugins::alternative::Getopt::warn_message = 1;
      }
  
      $self->{sanity} = 1;
  }
  
  sub set_output {
      my ($self, %options) = @_;
      
      $self->{output} = $options{output};
  }
  
  sub display_help {
      my ($self, %options) = @_;
      
      my $stdout;
      foreach (@{$self->{pod_package}}) {
          
          {
              local *STDOUT;
              open STDOUT, '>', \$stdout;
              my $where = pod_where({-inc => 1}, $_->{package});
              pod2usage(-exitval => 'NOEXIT', -input => $where,
                        -verbose => 99, 
                        -sections => $_->{sections}) if (defined($where));
          }
          
          $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
      }
  }
  
  sub add_help {
      my ($self, %options) = @_;
      # $options{package} = string package
      # $options{sections} = string sections
      # $options{help_first} = put at the beginning
      # $options{once} = put help only one time for a package
      
      if (defined($options{once}) && defined($self->{pod_packages_once}->{$options{package}})) {
          return ;
      }
      
      if (defined($options{help_first})) {
          unshift @{$self->{pod_package}}, {package => $options{package}, sections => $options{sections}};
      } else {
          push @{$self->{pod_package}}, { package => $options{package}, sections => $options{sections} };
      }
      
      $self->{pod_packages_once}->{$options{package}} = 1;
  }
  
  sub add_options {
      my ($self, %options) = @_;
      # $options{arguments} = ref to hash table with string and name to store (example: { 'mode:s' => { name => 'mode', default => 'defaultvalue' )
      
      foreach (keys %{$options{arguments}}) {
          if (defined($options{arguments}->{$_}->{redirect})) {
              $self->{options}->{$_} = \$self->{options_stored}->{$options{arguments}->{$_}->{redirect}};
              next;
          }
          
          if (defined($options{arguments}->{$_}->{default})) {
              $self->{options_stored}->{$options{arguments}->{$_}->{name}} = $options{arguments}->{$_}->{default};
          } else {
              $self->{options_stored}->{$options{arguments}->{$_}->{name}} = undef;
          }
          
          $self->{options}->{$_} = \$self->{options_stored}->{$options{arguments}->{$_}->{name}};
      }
  }
  
  sub parse_options {
      my $self = shift;
      #%{$self->{options_stored}} = ();
  
      my $save_warn_handler;
      if ($self->{sanity} == 1) {
          $save_warn_handler = $SIG{__WARN__};
          $SIG{__WARN__} = sub {
              $self->{output}->add_option_msg(short_msg => $_[0]);
              $self->{output}->option_exit(nolabel => 1);
          };
      }
      
      GetOptions(
         %{$self->{options}}
      );
      %{$self->{options}} = ();
      
      $SIG{__WARN__} = $save_warn_handler if ($self->{sanity} == 1);
  }
  
  sub get_option {
      my ($self, %options) = @_;
  
      return $self->{options_stored}->{$options{argument}};
  }
  
  sub get_options {
      my $self = shift;
  
      return $self->{options_stored};
  }
  
  sub clean {
      my $self = shift;
      
      $self->{options_stored} = {};
  }
  
  1;
  
CENTREON_PLUGINS_OPTIONS

$fatpacked{"centreon/plugins/output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_OUTPUT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::output;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      if (!defined($options{options})) {
          print "Class Output: Need to specify 'options' argument to load.\n";
          exit 3;
      }
  
      $options{options}->add_options(arguments => {
          'explode-perfdata-max:s@' => { name => 'explode_perfdata_max' },
          'range-perfdata:s'        => { name => 'range_perfdata' },
          'filter-perfdata:s'       => { name => 'filter_perfdata' },
          'change-perfdata:s@'      => { name => 'change_perfdata' },
          'extend-perfdata:s@'      => { name => 'extend_perfdata' },
          'extend-perfdata-group:s@'=> { name => 'extend_perfdata_group' },
          'change-short-output:s@'  => { name => 'change_short_output' },
          'use-new-perfdata'        => { name => 'use_new_perfdata' },
          'filter-uom:s'            => { name => 'filter_uom' },
          'verbose'                 => { name => 'verbose' },
          'debug'                   => { name => 'debug' },
          'opt-exit:s'              => { name => 'opt_exit', default => 'unknown' },
          'output-xml'              => { name => 'output_xml' },
          'output-json'             => { name => 'output_json' },
          'output-openmetrics'      => { name => 'output_openmetrics' },
          'output-file:s'           => { name => 'output_file' },
          'disco-format'            => { name => 'disco_format' },
          'disco-show'              => { name => 'disco_show' },
          'float-precision:s'       => { name => 'float_precision', default => 8 },
      });
      
      %{$self->{option_results}} = ();
  
      $self->{option_msg} = [];
      
      $self->{is_output_xml} = 0;
      $self->{is_output_json} = 0;
      $self->{errors} = {OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3, PENDING => 4};
      $self->{errors_num} = {0 => 'OK', 1 => 'WARNING', 2 => 'CRITICAL', 3 => 'UNKNOWN', 4 => 'PENDING'};
      $self->{myerrors} = {0 => "OK", 1 => "WARNING", 3 => "UNKNOWN", 7 => "CRITICAL"};
      $self->{myerrors_mask} = {CRITICAL => 7, WARNING => 1, UNKNOWN => 3, OK => 0};
      $self->{global_short_concat_outputs} = {OK => undef, WARNING => undef, CRITICAL => undef, UNKNOWN => undef, UNQUALIFIED_YET => undef};
      $self->{global_short_outputs} = {OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [], UNQUALIFIED_YET => []};
      $self->{global_long_output} = [];
      $self->{perfdatas} = [];
      $self->{explode_perfdatas} = {};
      $self->{change_perfdata} = {};
      $self->{explode_perfdata_total} = 0;
      $self->{range_perfdata} = 0;
      $self->{global_status} = 0;
      $self->{encode_utf8_import} = 0;
      $self->{perlqq} = 0;
  
      $self->{disco_elements} = [];
      $self->{disco_entries} = [];
  
      $self->{plugin} = '';
      $self->{mode} = '';
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      # $options{option_results} = ref to options result
  
      %{$self->{option_results}} = %{$options{option_results}};
      $self->{option_results}->{opt_exit} = lc($self->{option_results}->{opt_exit});
      if (!$self->is_litteral_status(status => $self->{option_results}->{opt_exit})) {
          $self->add_option_msg(short_msg => "Unknown value '" . $self->{option_results}->{opt_exit}  . "' for --opt-exit.");
          $self->option_exit(exit_litteral => 'unknown');
      }
      # Go in XML Mode
      if ($self->is_disco_show() || $self->is_disco_format()) {
          # By Default XML
          if (!defined($self->{option_results}->{output_json})) {
              $self->{option_results}->{output_xml} = 1;
          }
      }
      
      if (defined($self->{option_results}->{range_perfdata})) {
          $self->{range_perfdata} = $self->{option_results}->{range_perfdata};
          $self->{range_perfdata} = 1 if ($self->{range_perfdata} eq '');
          if ($self->{range_perfdata} !~ /^[012]$/) {
              $self->add_option_msg(short_msg => "Wrong range-perfdata option '" . $self->{range_perfdata} . "'");
              $self->option_exit();
          }
      }
      
      if (defined($self->{option_results}->{explode_perfdata_max})) {
          if (${$self->{option_results}->{explode_perfdata_max}}[0] eq '') {
              $self->{explode_perfdata_total} = 2;
          } else {
              $self->{explode_perfdata_total} = 1;
              foreach (@{$self->{option_results}->{explode_perfdata_max}}) {
                  my ($perf_match, $perf_result) = split /,/;
                  if (!defined($perf_result)) {
                      $self->add_option_msg(short_msg => "Wrong explode-perfdata-max option '" . $_ . "' (syntax: match,value)");
                      $self->option_exit();
                  }
                  $self->{explode_perfdatas}->{$perf_match} = $perf_result;
              }
          }
      }
      
      $self->load_perfdata_extend_args();
      $self->{option_results}->{use_new_perfdata} = 1 if (defined($self->{option_results}->{output_openmetrics}));
  }
  
  sub add_option_msg {
      my ($self, %options) = @_;
      # $options{short_msg} = string msg
      # $options{long_msg} = string msg
      $options{severity} = 'UNQUALIFIED_YET';
      
      $self->output_add(%options);
  }
  
  sub set_status {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
  
      # Nothing to do for 'UNQUALIFIED_YET'
      if (!$self->{myerrors_mask}->{uc($options{exit_litteral})}) {
          return ;
      }
      $self->{global_status} |= $self->{myerrors_mask}->{uc($options{exit_litteral})};
  }
  
  sub output_add {
      my ($self, %params) = @_;
      my %args = (
          severity => 'OK',
          separator => ' - ',
          debug => 0,
          short_msg => undef,
          long_msg => undef,
      );
      my $options = {%args, %params};
      
      if (defined($options->{short_msg})) {
          chomp $options->{short_msg};
          if (defined($self->{global_short_concat_outputs}->{uc($options->{severity})})) {
              $self->{global_short_concat_outputs}->{uc($options->{severity})} .= $options->{separator} . $options->{short_msg};
          } else {
              $self->{global_short_concat_outputs}->{uc($options->{severity})} = $options->{short_msg};
          }
          
          push @{$self->{global_short_outputs}->{uc($options->{severity})}}, $options->{short_msg};
          $self->set_status(exit_litteral => $options->{severity});
      }
      if (defined($options->{long_msg}) && 
          ($options->{debug} == 0 || defined($self->{option_results}->{debug}))) {
          chomp $options->{long_msg};
          push @{$self->{global_long_output}}, $options->{long_msg};
      }
  }
  
  sub perfdata_add {
      my ($self, %options) = @_;
      my $perfdata = {
          label => '', value => '', unit => '', warning => '', critical => '', min => '', max => ''
      };
      foreach (keys %options) {
          next if (!defined($options{$_}));
          $perfdata->{$_} = $options{$_};
      }
      
      if (defined($self->{option_results}->{use_new_perfdata}) && defined($options{nlabel})) {
          $perfdata->{label} = $options{nlabel};
      }
      if (defined($options{instances})) {
          $options{instances} = [$options{instances}] if (!ref($options{instances}));
          my ($external_instance_separator, $internal_instance_separator) = ('#', '~');
          if (defined($self->{option_results}->{use_new_perfdata})) {
              $perfdata->{label} = join('~', @{$options{instances}}) . '#' . $perfdata->{label};
          } else {
              $perfdata->{label} .= '_' . join('_', @{$options{instances}});
          }
      }
      
      $perfdata->{label} =~ s/'/''/g;
      push @{$self->{perfdatas}}, $perfdata;
  }
  
  sub range_perfdata {
      my ($self, %options) = @_;
      
      return if ($self->{range_perfdata} == 0);
      if ($self->{range_perfdata} == 1) {
          for (my $i = 0; $i < scalar(@{$options{ranges}}); $i++) {
              ${${$options{ranges}}[$i]} =~ s/^(@?)-?[0\.]+:/$1/;
          }
      } else {
          for (my $i = 0; $i < scalar(@{$options{ranges}}); $i++) {
              ${${$options{ranges}}[$i]} = '';
          }
      }
  }
  
  sub output_json {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      my $json_content = {
          plugin => {
              name => $self->{plugin},
              mode => $self->{mode},
              exit => $options{exit_litteral},
              outputs => [],
              perfdatas => []
          }
      };    
  
      foreach my $code_litteral (keys %{$self->{global_short_outputs}}) {
          foreach (@{$self->{global_short_outputs}->{$code_litteral}}) {
              my ($child_output, $child_type, $child_msg, $child_exit);
              my $lcode_litteral = ($code_litteral eq 'UNQUALIFIED_YET' ? uc($options{exit_litteral}) : $code_litteral);
  
              push @{$json_content->{plugin}->{outputs}}, {
                  type => 1,
                  msg => ($options{nolabel} == 0 ? ($lcode_litteral . ': ') : '') . $_,
                  exit => $lcode_litteral
              };
          }
      }
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          foreach (@{$self->{global_long_output}}) {
              push @{$json_content->{plugin}->{outputs}}, {
                  type => 2,
                  msg => $_,
              };
          }
      }
  
      if ($options{force_ignore_perfdata} == 0) {
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if (defined($self->{option_results}->{filter_perfdata}) &&
                       $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
              
              my %values = ();
              foreach my $key (keys %$perf) {
                  $perf->{$key} = '' if (defined($self->{option_results}->{filter_uom}) && $key eq 'unit' &&
                      $perf->{$key} !~ /$self->{option_results}->{filter_uom}/);
                  $values{$key} = $perf->{$key};
              }
              
              push @{$json_content->{plugin}->{perfdatas}}, {
                  %values
              };
          }
      }
  
      print $self->{json_output}->encode($json_content);
  }
  
  sub output_xml {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      my ($child_plugin_name, $child_plugin_mode, $child_plugin_exit, $child_plugin_output, $child_plugin_perfdata); 
  
      my $root = $self->{xml_output}->createElement('plugin');
      $self->{xml_output}->setDocumentElement($root);
  
      $child_plugin_name = $self->{xml_output}->createElement('name');
      $child_plugin_name->appendText($self->{plugin});
  
      $child_plugin_mode = $self->{xml_output}->createElement('mode');
      $child_plugin_mode->appendText($self->{mode});
  
      $child_plugin_exit = $self->{xml_output}->createElement('exit');
      $child_plugin_exit->appendText($options{exit_litteral});
  
      $child_plugin_output = $self->{xml_output}->createElement('outputs');
      $child_plugin_perfdata = $self->{xml_output}->createElement('perfdatas');
  
      $root->addChild($child_plugin_name);
      $root->addChild($child_plugin_mode);
      $root->addChild($child_plugin_exit);
      $root->addChild($child_plugin_output);
      $root->addChild($child_plugin_perfdata);
  
      foreach my $code_litteral (keys %{$self->{global_short_outputs}}) {
          foreach (@{$self->{global_short_outputs}->{$code_litteral}}) {
              my ($child_output, $child_type, $child_msg, $child_exit);
              my $lcode_litteral = ($code_litteral eq 'UNQUALIFIED_YET' ? uc($options{exit_litteral}) : $code_litteral);
  
              $child_output = $self->{xml_output}->createElement('output');
              $child_plugin_output->addChild($child_output);
  
              $child_type = $self->{xml_output}->createElement('type');
              $child_type->appendText(1); # short
  
              $child_msg = $self->{xml_output}->createElement('msg');
              $child_msg->appendText(($options{nolabel} == 0 ? ($lcode_litteral . ': ') : '') . $_);
              $child_exit = $self->{xml_output}->createElement('exit');
              $child_exit->appendText($lcode_litteral);
  
              $child_output->addChild($child_type);
              $child_output->addChild($child_exit);
              $child_output->addChild($child_msg);
          }
      }
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          foreach (@{$self->{global_long_output}}) {
              my ($child_output, $child_type, $child_msg);
          
              $child_output = $self->{xml_output}->createElement('output');
              $child_plugin_output->addChild($child_output);
  
              $child_type = $self->{xml_output}->createElement('type');
              $child_type->appendText(2); # long
  
              $child_msg = $self->{xml_output}->createElement('msg');
              $child_msg->appendText($_);
  
              $child_output->addChild($child_type);
              $child_output->addChild($child_msg);
          }
      }
  
      if ($options{force_ignore_perfdata} == 0) {
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if (defined($self->{option_results}->{filter_perfdata}) &&
                       $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
          
              my ($child_perfdata);
              $child_perfdata = $self->{xml_output}->createElement('perfdata');
              $child_plugin_perfdata->addChild($child_perfdata);
              foreach my $key (keys %$perf) {
                  $perf->{$key} = '' if (defined($self->{option_results}->{filter_uom}) && $key eq 'unit' &&
                      $perf->{$key} !~ /$self->{option_results}->{filter_uom}/);
                  my $child = $self->{xml_output}->createElement($key);
                  $child->appendText($perf->{$key});
                  $child_perfdata->addChild($child);
              }
          }
      }
  
      print $self->{xml_output}->toString(1);
  }
  
  sub output_openmetrics {
      my ($self, %options) = @_;
  
      $self->change_perfdata();
      foreach my $perf (@{$self->{perfdatas}}) {
          next if (defined($self->{option_results}->{filter_perfdata}) &&
                   $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
          $perf->{unit} = '' if (defined($self->{option_results}->{filter_uom}) &&
              $perf->{unit} !~ /$self->{option_results}->{filter_uom}/);
          $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
          my $label = $perf->{label};
          my $instance;
          if ($label =~ /^(.*?)#(.*)$/) {
              ($perf->{instance}, $label) = ($1, $2);
          }
          my ($bucket, $append) = ('{plugin="' . $self->{plugin} . '",mode="' . $self->{mode} . '"', '');
          foreach ('unit', 'warning', 'critical', 'min', 'max', 'instance') {
              if (defined($perf->{$_}) && $perf->{$_} ne '') {
                  $bucket .= ',' . $_ . '="' . $perf->{$_} . '"';
              }
          }
          $bucket .= '}';
          
          print $label . $bucket . ' ' . $perf->{value} . "\n";
      }
  }
  
  sub output_txt_short_display {
      my ($self, %options) = @_;
      
      if (defined($self->{global_short_concat_outputs}->{CRITICAL})) {
          print (($options{nolabel} == 0 ? 'CRITICAL: ' : '') . $self->{global_short_concat_outputs}->{CRITICAL} . " ");
      }
      if (defined($self->{global_short_concat_outputs}->{WARNING})) {
          print (($options{nolabel} == 0 ? 'WARNING: ' : '') . $self->{global_short_concat_outputs}->{WARNING} . " ");
      }
      if (defined($self->{global_short_concat_outputs}->{UNKNOWN})) {
          print (($options{nolabel} == 0 ? 'UNKNOWN: ' : '') . $self->{global_short_concat_outputs}->{UNKNOWN} . " ");
      }
      if (uc($options{exit_litteral}) eq 'OK') {
          print (($options{nolabel} == 0 ? 'OK: ' : '') . (defined($self->{global_short_concat_outputs}->{OK}) ? $self->{global_short_concat_outputs}->{OK} : '') . " ");
      }
  }
  
  sub output_txt_short {
      my ($self, %options) = @_;
      
      if (!defined($self->{option_results}->{change_short_output})) {
          $self->output_txt_short_display(%options);
          return ;
      }
      
      my $stdout = '';
      {
          local *STDOUT;
          open STDOUT, '>', \$stdout;
          $self->output_txt_short_display(%options);
      }
      
      foreach (@{$self->{option_results}->{change_short_output}}) {
           my ($pattern, $replace, $modifier) = split /~/;
           next if (!defined($pattern));
           $replace = '' if (!defined($replace));
           $modifier = '' if (!defined($modifier));
           eval "\$stdout =~ s{$pattern}{$replace}$modifier";
      }
      
      print $stdout;
  }
  
  sub output_txt {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
  
      if (defined($self->{global_short_concat_outputs}->{UNQUALIFIED_YET})) {
          $self->output_add(severity => uc($options{exit_litteral}), short_msg => $self->{global_short_concat_outputs}->{UNQUALIFIED_YET});
      }
  
      $self->output_txt_short(%options);
  
      if ($force_ignore_perfdata == 1) {
          print "\n";
      } else {
          print '|';
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if (defined($self->{option_results}->{filter_perfdata}) &&
                       $perf->{label} !~ /$self->{option_results}->{filter_perfdata}/);
              $perf->{unit} = '' if (defined($self->{option_results}->{filter_uom}) &&
                  $perf->{unit} !~ /$self->{option_results}->{filter_uom}/);
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
              print " '" . $perf->{label} . "'=" . $perf->{value} . $perf->{unit} . ';' . $perf->{warning} . ';' . $perf->{critical} . ';' . $perf->{min} . ';' . $perf->{max};
          }
          print "\n";
      }
      
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          if (scalar(@{$self->{global_long_output}})) {
              print join("\n", @{$self->{global_long_output}});
              print "\n";
          }
      }
  }
  
  sub display {
      my ($self, %options) = @_;
      my $nolabel = defined($options{nolabel}) ? 1 : 0;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      $force_long_output = 1 if (defined($self->{option_results}->{debug}));
  
      if (defined($self->{option_results}->{output_file})) {
          if (!open (STDOUT, '>', $self->{option_results}->{output_file})) {
              $self->output_add(severity => 'UNKNOWN',
                                short_msg => "cannot open file  '" . $self->{option_results}->{output_file} . "': $!");
          }
      }
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $self->get_litteral_status(), 
                                nolabel => $nolabel, 
                                force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output);
              return ;
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $self->get_litteral_status(), 
                                 nolabel => $nolabel,
                                 force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output);
              return ;
          }
      } elsif (defined($self->{option_results}->{output_openmetrics})) {
          $self->output_openmetrics();
          return ;
      }
      
      $self->output_txt(
          exit_litteral => $self->get_litteral_status(), 
          nolabel => $nolabel,
          force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output
      );
  }
  
  sub die_exit {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
      # $options{nolabel} = interger label display
      my $exit_litteral = defined($options{exit_litteral}) ? $options{exit_litteral} : $self->{option_results}->{opt_exit};
      my $nolabel = defined($options{nolabel}) ? 1 : 0;
      # ignore long output in the following case
      $self->{option_results}->{verbose} = undef;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } 
  
      $self->output_txt(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
      $self->exit(exit_litteral => $exit_litteral);
  }
  
  sub option_exit {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
      # $options{nolabel} = interger label display
      my $exit_litteral = defined($options{exit_litteral}) ? $options{exit_litteral} : $self->{option_results}->{opt_exit};
      my $nolabel = defined($options{nolabel}) ? 1 : 0;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      }
  
      $self->output_txt(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
      $self->exit(exit_litteral => $exit_litteral);
  }
  
  sub exit {
      my ($self, %options) = @_;
      # $options{exit_litteral} = exit
      
      if (defined($options{exit_litteral})) {
          exit $self->{errors}->{uc($options{exit_litteral})};
      }
      exit $self->{errors}->{$self->{myerrors}->{$self->{global_status}}};
  }
  
  sub get_most_critical {
      my ($self, %options) = @_;
      my $current_status = 0; # For 'OK'
  
      foreach (@{$options{status}}) {
          if ($self->{myerrors_mask}->{uc($_)} > $current_status) {
              $current_status = $self->{myerrors_mask}->{uc($_)};
          }
      }
      return $self->{myerrors}->{$current_status};
  }
  
  sub get_litteral_status {
      my ($self, %options) = @_;
      
      if (defined($options{status})) {
          if (defined($self->{errors_num}->{$options{status}})) {
              return $self->{errors_num}->{$options{status}};
          }
          return $options{status};
      } else {
          return $self->{myerrors}->{$self->{global_status}};
      }
  }
  
  sub is_status {
      my ($self, %options) = @_;
      # $options{value} = string status 
      # $options{litteral} = value is litteral
      # $options{compare} = string status 
  
      if (defined($options{litteral})) {
          my $value = defined($options{value}) ? $options{value} : $self->get_litteral_status();
      
          if (uc($value) eq uc($options{compare})) {
              return 1;
          }
          return 0;
      }
  
      my $value = defined($options{value}) ? $options{value} : $self->{global_status};
      my $dec_val = $self->{myerrors_mask}->{$value};
      my $lresult = $value & $dec_val;
      # Need to manage 0
      if ($lresult > 0 || ($dec_val == 0 && $value == 0)) {
          return 1;
      }
      return 0;
  }
  
  sub is_litteral_status {
      my ($self, %options) = @_;
      # $options{status} = string status
  
      if (defined($self->{errors}->{uc($options{status})})) {
          return 1;
      }
  
      return 0;
  }
  
  sub create_json_document {
      my ($self) = @_;
  
      if (centreon::plugins::misc::mymodule_load(no_quit => 1, module => 'JSON',
                                             error_msg => "Cannot load module 'JSON'.")) {
          print "Cannot load module 'JSON'\n";
          $self->exit(exit_litteral => 'unknown');
      }
      $self->{is_output_json} = 1;
      $self->{json_output} = JSON->new->utf8();
  }
  
  sub create_xml_document {
      my ($self) = @_;
  
      if (centreon::plugins::misc::mymodule_load(no_quit => 1, module => 'XML::LibXML',
                                             error_msg => "Cannot load module 'XML::LibXML'.")) {
          print "Cannot load module 'XML::LibXML'\n";
          $self->exit(exit_litteral => 'unknown');
      }
      $self->{is_output_xml} = 1;
      $self->{xml_output} = XML::LibXML::Document->new('1.0', 'utf-8');
  }
  
  sub plugin {
      my ($self, %options) = @_;
      # $options{name} = string name
      
      if (defined($options{name})) {
          $self->{plugin} = $options{name};
      }
      return $self->{plugin};
  }
  
  sub mode {
      my ($self, %options) = @_;
      # $options{name} = string name
  
      if (defined($options{name})) {
          $self->{mode} = $options{name};
      }
      return $self->{mode};
  }
  
  sub add_disco_format {
      my ($self, %options) = @_;
  
      push @{$self->{disco_elements}}, @{$options{elements}};
  }
  
  sub display_disco_format {
      my ($self, %options) = @_;
      
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
      
          my $root = $self->{xml_output}->createElement('data');
          $self->{xml_output}->setDocumentElement($root);
  
          foreach (@{$self->{disco_elements}}) {
              my $child = $self->{xml_output}->createElement("element");
              $child->appendText($_);
              $root->addChild($child);
          }
  
          print $self->{xml_output}->toString(1);
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          my $json_content = {data => [] };
          foreach (@{$self->{disco_elements}}) {
              push @{$json_content->{data}}, $_;
          }
          
          print $self->{json_output}->encode($json_content);
      }
  }
  
  sub display_disco_show {
      my ($self, %options) = @_;
      
       if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          
          my $root = $self->{xml_output}->createElement('data');
          $self->{xml_output}->setDocumentElement($root);
  
          foreach (@{$self->{disco_entries}}) {
              my $child = $self->{xml_output}->createElement('label');
              foreach my $key (keys %$_) {
                  $child->setAttribute($key, $_->{$key});
              }
              $root->addChild($child);
          }
  
          print $self->{xml_output}->toString(1);
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          my $json_content = {data => [] };
          foreach (@{$self->{disco_entries}}) {
              my %values = ();
              foreach my $key (keys %$_) {
                  $values{$key} = $_->{$key};
              }
              push @{$json_content->{data}}, {%values};
          }
          
          print $self->{json_output}->encode($json_content);
      }
  }
  
  sub to_utf8 {
      my ($self, $value) = @_;
      
      if ($self->{encode_utf8_import} == 0) {
          # Some Perl version dont have the following module (like Perl 5.6.x)
          if (centreon::plugins::misc::mymodule_load(no_quit => 1, module => 'Encode',
                                                     error_msg => "Cannot load module 'Encode'.")) {
              print "Cannot load module 'Encode'\n";
              $self->exit(exit_litteral => 'unknown');
          }
          
          $self->{encode_utf8_import} = 1;
          eval '$self->{perlqq} = Encode::PERLQQ';
      }
      
      return centreon::plugins::misc::trim(Encode::decode('UTF-8', $value, $self->{perlqq}));
  }
  
  sub add_disco_entry {
      my ($self, %options) = @_;
      
      push @{$self->{disco_entries}}, {%options};
  }
  
  sub is_disco_format {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{disco_format})) {
          return 1;
      }
      return 0;
  }
  
  sub is_disco_show {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{disco_show})) {
          return 1;
      }
      return 0;
  }
  
  sub is_verbose {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{verbose})) {
          return 1;
      }
      return 0;
  }
  
  sub is_debug {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{debug})) {
          return 1;
      }
      return 0;
  }
  
  sub use_new_perfdata {
      my ($self, %options) = @_;
  
      $self->{option_results}->{use_new_perfdata} = $options{value}
          if (defined($options{value}));
      if (defined($self->{option_results}->{use_new_perfdata})) {
          return 1;
      }
      return 0;
  }
  
  sub get_instance_perfdata_separator {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{use_new_perfdata})) {
          return '~';
      }
      return '_';
  }
  
  sub parse_pfdata_scale {
      my ($self, %options) = @_;
      
      # --extend-perfdata=traffic_in,,scale(Mbps),mbps
      my $args = { unit => 'auto' };
      if ($options{args} =~ /^([KMGTPEkmgtpe])?(B|b|bps|Bps|b\/s|auto)$/) {
          $args->{quantity} = defined($1) ? $1 : '';
          $args->{unit} = $2;
      } elsif ($options{args} ne '') {
          return 1;
      }
      
      return (0, $args);
  }
  
  sub parse_pfdata_math {
      my ($self, %options) = @_;
  
      # --extend-perfdata=perfx,,math(current + 10 - 100, 1)
      my $args = { math => undef, apply_threshold => 0 };
      my ($math, $apply_threshold) = split /\|/, $options{args};
      if ($math =~ /^((?:[\s\.\-\+\*\/0-9\(\)]|current)+)$/) {
          $args->{math} = $1;
      } elsif ($options{args} ne '') {
          return 1;
      }
      
      if (defined($apply_threshold) && $apply_threshold =~ /^\s*(0|1)\s*$/ ) {
          $args->{apply_threshold} = $1;
      }
      
      return (0, $args);
  }
  
  sub parse_group_pfdata {
      my ($self, %options) = @_;
      
      $options{args} =~ s/^\s+//;
      $options{args} =~ s/\s+$//;
      my $args = { pattern_pf => $options{args} };
      return $args;
  }
  
  sub parse_pfdata_min {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_max {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_average {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_sum {
      my ($self, %options) = @_;
      
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub apply_pfdata_scale {
      my ($self, %options) = @_;
      
      return if (${$options{perf}}->{unit} !~ /^([KMGTPEkmgtpe])?(B|b|bps|Bps|b\/s)$/);
      
      my ($src_quantity, $src_unit) = ($1, $2);
      my ($value, $dst_quantity, $dst_unit) = centreon::plugins::misc::scale_bytesbit(value => ${$options{perf}}->{value},
          src_quantity => $src_quantity, src_unit => $src_unit, dst_quantity => $options{args}->{quantity}, dst_unit => $options{args}->{unit});
      ${$options{perf}}->{value} = sprintf("%.2f", $value);
      if (defined($dst_unit)) {
         ${$options{perf}}->{unit} = $dst_quantity . $dst_unit;
      } else {
          ${$options{perf}}->{unit} = $options{args}->{quantity} . $options{args}->{unit};
      }
      
      if (defined(${$options{perf}}->{max}) && ${$options{perf}}->{max} ne '') {
          ($value) = centreon::plugins::misc::scale_bytesbit(value => ${$options{perf}}->{max},
              src_quantity => $src_quantity, src_unit => $src_unit, 
              dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity}, 
              dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          ${$options{perf}}->{max} = sprintf('%.2f', $value);
      }
      
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              ($result->{start}) = centreon::plugins::misc::scale_bytesbit(value => $result->{start},
                  src_quantity => $src_quantity, src_unit => $src_unit, 
                  dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity}, 
                  dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              ($result->{end}) = centreon::plugins::misc::scale_bytesbit(value => $result->{end},
                  src_quantity => $src_quantity, src_unit => $src_unit, 
                  dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity}, 
                  dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
  }
  
  sub apply_pfdata_invert {
      my ($self, %options) = @_;
      
      return if (!defined(${$options{perf}}->{max}) || ${$options{perf}}->{max} eq '');
      
      ${$options{perf}}->{value} = ${$options{perf}}->{max} - ${$options{perf}}->{value};
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
          
          my $tmp = { arobase => $result->{arobase}, infinite_pos => 0, infinite_neg => 0, start => $result->{start}, end => $result->{end} };
          $tmp->{infinite_neg} = 1 if ($result->{infinite_pos} == 1);
          $tmp->{infinite_pos} = 1 if ($result->{infinite_neg} == 1);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $tmp->{end} = ${$options{perf}}->{max} - $result->{start};
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $tmp->{start} = ${$options{perf}}->{max} - $result->{end};
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$tmp);
      }
  }
  
  sub apply_pfdata_percent {
      my ($self, %options) = @_;
  
      return if (!defined(${$options{perf}}->{max}) || ${$options{perf}}->{max} eq '');
      
      ${$options{perf}}->{value} = sprintf('%.2f', ${$options{perf}}->{value} * 100 / ${$options{perf}}->{max});
      ${$options{perf}}->{unit} = '%';
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $result->{start} = sprintf('%.2f', $result->{start} * 100 / ${$options{perf}}->{max});
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $result->{end} = sprintf('%.2f', $result->{end} * 100 / ${$options{perf}}->{max});
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
      
      ${$options{perf}}->{max} = 100; 
  }
  
  sub apply_pfdata_math {
      my ($self, %options) = @_;
      
      my $math = $options{args}->{math};
      $math =~ s/current/\$value/g;
      
      my $value = ${$options{perf}}->{value};
      eval "\${\$options{perf}}->{value} = $math";
      
      return if ($options{args}->{apply_threshold} == 0);
      
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $value = $result->{start};
              eval "\$result->{start} = $math";
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $value = $result->{end};
              eval "\$result->{end} = $math";
          }
          
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
      
      ${$options{perf}}->{max} = 100;
  }
  
  sub apply_pfdata_min {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my $min;
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $min = $self->{perfdatas}->[$i]->{value}
              if (!defined($min) || $min > $self->{perfdatas}->[$i]->{value});
      }
  
      ${$options{perf}}->{value} = $min
          if (defined($min));
  }
  
  sub apply_pfdata_max {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my $max;
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $max = $self->{perfdatas}->[$i]->{value}
              if (!defined($max) || $max < $self->{perfdatas}->[$i]->{value});
      }
  
      ${$options{perf}}->{value} = $max
          if (defined($max));
  }
  
  sub apply_pfdata_sum {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my ($sum, $num) = (0, 0);
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $sum += $self->{perfdatas}->[$i]->{value};
          $num++;
      }
  
      ${$options{perf}}->{value} = $sum
          if ($num > 0);
  }
  
  sub apply_pfdata_average {
      my ($self, %options) = @_;
  
      my $pattern_pf;
      eval "\$pattern_pf = \"$options{args}->{pattern_pf}\"";
      my ($sum, $num) = (0, 0);
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $sum += $self->{perfdatas}->[$i]->{value};
          $num++;
      }
  
      ${$options{perf}}->{value} = sprintf("%.2f", ($sum / $num))
          if ($num > 0);
  }
  
  sub load_perfdata_extend_args {
      my ($self, %options) = @_;
  
      foreach (
          [$self->{option_results}->{change_perfdata}, 1],
          [$self->{option_results}->{extend_perfdata}, 2],
          [$self->{option_results}->{extend_perfdata_group}, 3],
      ) {
          next if (!defined($_->[0]));
          foreach my $arg (@{$_->[0]}) {
              $self->parse_perfdata_extend_args(arg => $arg, type => $_->[1]);
          }
      }
  }
  
  sub parse_perfdata_extend_args {
      my ($self, %options) = @_;
      
      # --extend-perfdata=searchlabel,newlabel,method[,[newuom],[min],[max]]
      my ($pfdata_match, $pfdata_substitute, $method, $uom_sub, $min_sub, $max_sub) = 
          split /,/, $options{arg};
      return if ((!defined($pfdata_match) || $pfdata_match eq '') && $options{type} != 3);
      
      $self->{pfdata_extends} = [] if (!defined($self->{pfdata_extends}));
      my $pfdata_extends = {
          pfdata_match => defined($pfdata_match) && $pfdata_match ne '' ? $pfdata_match : undef,
          pfdata_substitute => defined($pfdata_substitute) && $pfdata_substitute ne '' ? $pfdata_substitute : undef,
          uom_sub => defined($uom_sub) && $uom_sub ne '' ? $uom_sub : undef,
          min_sub => defined($min_sub) && $min_sub ne '' ? $min_sub : undef,
          max_sub => defined($max_sub) && $max_sub ne '' ? $max_sub : undef,
          type => $options{type}
      };
  
      if (defined($method) && $method ne '') {
          if ($method !~ /^\s*(invert|percent|scale|math|min|max|average|sum)\s*\(\s*(.*?)\s*\)\s*$/) {
              $self->output_add(long_msg => "method in argument '$options{arg}' is unknown", debug => 1);
              return ;
          }
          
          $pfdata_extends->{method_name} = $1;
          my $args = $2;
          if (my $func = $self->can('parse_pfdata_' . $pfdata_extends->{method_name})) {
              (my $status, $pfdata_extends->{method_args}) = $func->($self, args => $args);
              if ($status == 1) {
                  $self->output_add(long_msg => "argument in method '$options{arg}' is unknown", debug => 1);
                  return ;
              }
          }
      }
  
      push  @{$self->{pfdata_extends}}, $pfdata_extends;
  }
  
  sub apply_perfdata_explode {
      my ($self, %options) = @_;
      
      return if ($self->{explode_perfdata_total} == 0);
      foreach (@{$self->{perfdatas}}) {
          next if ($_->{max} eq '');
          if ($self->{explode_perfdata_total} == 2) {
              $self->perfdata_add(label => $_->{label} . '_max', value => $_->{max});
              next;
          }
          foreach my $regexp (keys %{$self->{explode_perfdatas}}) {
              if ($_->{label} =~ /$regexp/) {
                  $self->perfdata_add(label => $self->{explode_perfdatas}->{$regexp}, value => $_->{max});
                  last;
              }
          }
      }
  }
  
  sub apply_perfdata_extend {
      my ($self, %options) = @_;
  
      foreach my $extend (@{$self->{pfdata_extends}}) {
          my $new_pfdata = [];
          
          # Manage special case when type group and pfdata_match empty
          if ($extend->{type} == 3 && (!defined($extend->{pfdata_match}) || $extend->{pfdata_match} eq '')) {
              next if (!defined($extend->{pfdata_substitute}) || $extend->{pfdata_substitute} eq '');
              my $new_perf = {
                  label => $extend->{pfdata_substitute}, value => '',
                  unit => defined($extend->{uom_sub}) ? $extend->{uom_sub} : '',
                  warning => '', critical => '',
                  min => defined($extend->{min_sub}) ? $extend->{min_sub} : '',
                  max => defined($extend->{max_sub}) ? $extend->{max_sub} : ''
              };
  
              if (defined($extend->{method_name})) {
                  my $func = $self->can('apply_pfdata_' . $extend->{method_name});
                  $func->($self, perf => \$new_perf, args => $extend->{method_args});
              }
  
              if (length($new_perf->{value})) {
                  push @{$self->{perfdatas}}, $new_perf;
              }
              next;
          }
          
          for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
              next if ($self->{perfdatas}->[$i]->{label} !~ /$extend->{pfdata_match}/);
              
              my $new_perf = { %{$self->{perfdatas}->[$i]} };
              if ($extend->{type} == 3) {
                  $new_perf = { label => $self->{perfdatas}->[$i]->{label}, value => '', unit => '', warning => '', critical => '', min => '', max => '' };
              }
              
              if (defined($extend->{pfdata_substitute})) {
                  eval "\$new_perf->{label} =~ s{$extend->{pfdata_match}}{$extend->{pfdata_substitute}}";
              }
  
              if (defined($extend->{method_name})) {
                  my $func = $self->can('apply_pfdata_' . $extend->{method_name});
                  $func->($self, perf => \$new_perf, args => $extend->{method_args});
              }
              
              $new_perf->{unit} = $extend->{uom_sub} if (defined($extend->{uom_sub}));
              $new_perf->{min} = $extend->{min_sub} if (defined($extend->{min_sub}));
              $new_perf->{max} = $extend->{max_sub} if (defined($extend->{max_sub}));
  
              if ($extend->{type} == 1) {
                  $self->{perfdatas}->[$i] = $new_perf;
              } else {
                  push @$new_pfdata, $new_perf if (length($new_perf->{value}));
              }
          }
  
          push @{$self->{perfdatas}}, @$new_pfdata;
      }
  }
  
  sub change_perfdata {
      my ($self, %options) = @_;
      
      $self->apply_perfdata_extend();
      $self->apply_perfdata_explode();
  }
  
  1;
  
  
  =head1 NAME
  
  Output class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 OUTPUT OPTIONS
  
  =over 8
  
  =item B<--verbose>
  
  Display long output.
  
  =item B<--debug>
  
  Display also debug messages.
  
  =item B<--filter-perfdata>
  
  Filter perfdata that match the regexp.
  
  =item B<--explode-perfdata-max>
  
  Put max perfdata (if it exist) in a specific perfdata 
  (without values: same with '_max' suffix) (Multiple options)
  
  =item B<--change-perfdata> B<--extend-perfdata> 
  
  Change or extend perfdata. 
  Syntax: --extend-perfdata=searchlabel,newlabel,target[,[newuom],[min],[max]]
  
  Common examples:
  
  =over 4
  
  Change storage free perfdata in used: --change-perfdata=free,used,invert()
  
  Change storage free perfdata in used: --change-perfdata=used,free,invert()
  
  Scale traffic values automaticaly: --change-perfdata=traffic,,scale(auto)
  
  Scale traffic values in Mbps: --change-perfdata=traffic_in,,scale(Mbps),mbps
  
  Change traffic values in percent: --change-perfdata=traffic_in,,percent()
  
  =back
  
  =item B<--extend-perfdata-group> 
  
  Extend perfdata from multiple perfdatas (methods in target are: min, max, average, sum)
  Syntax: --extend-perfdata-group=searchlabel,newlabel,target[,newuom]
  
  Common examples:
  
  =over 4
  
  Sum wrong packets from all interfaces (with interface need  --units-errors=absolute): --extend-perfdata-group=',packets_wrong,sum(packets_(discard|error)_(in|out))'
  
  Sum traffic by interface: --extend-perfdata-group='traffic_in_(.*),traffic_$1,sum(traffic_(in|out)_$1)'
  
  =back
  
  =item B<--change-short-output>
  
  Change short output display. --change-short-output=pattern~replace~modifier
  
  =item B<--range-perfdata>
  
  Change perfdata range thresholds display: 
  1 = start value equals to '0' is removed, 2 = threshold range is not display.
  
  =item B<--filter-uom>
  
  Filter UOM that match the regexp.
  
  =item B<--opt-exit>
  
  Optional exit code for an execution error (i.e. wrong option provided,
  SSH connection refused, timeout, etc)
  (Default: unknown).
  
  =item B<--output-xml>
  
  Display output in XML format.
  
  =item B<--output-json>
  
  Display output in JSON format.
  
  =item B<--output-openmetrics>
  
  Display metrics in OpenMetrics format.
  
  =item B<--output-file>
  
  Write output in file (can be used with json and xml options)
  
  =item B<--disco-format>
  
  Display discovery arguments (if the mode manages it).
  
  =item B<--disco-show>
  
  Display discovery values (if the mode manages it).
  
  =item B<--float-precision>
  
  Set the float precision for thresholds (Default: 8).
  
  =head1 DESCRIPTION
  
  B<output>.
  
  =cut
CENTREON_PLUGINS_OUTPUT

$fatpacked{"centreon/plugins/perfdata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PERFDATA';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::perfdata;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{output} = $options{output};
      # Typical Nagios Perfdata 'with ~ @ ..'
      $self->{threshold_label} = {};
      $self->{float_precision} = defined($self->{output}->{option_results}->{float_precision}) && $self->{output}->{option_results}->{float_precision} =~ /\d+/ ?  
          int($self->{output}->{option_results}->{float_precision}) : 8;
  
      return $self;
  }
  
  sub get_perfdata_for_output {
      my ($self, %options) = @_;
      # $options{label} : threshold label
      # $options{total} : percent threshold to transform in global
      # $options{cast_int} : cast absolute to int
      # $options{op} : operator to apply to start/end value (uses with 'value'})
      # $options{value} : value to apply with 'op' option
      
      if (!defined($self->{threshold_label}->{$options{label}}->{value}) || $self->{threshold_label}->{$options{label}}->{value} eq '') {
          return '';
      }
      
      my %perf_value = %{$self->{threshold_label}->{$options{label}}};
      
      if (defined($options{op}) && defined($options{value})) {
          eval "\$perf_value{start} = \$perf_value{start} $options{op} \$options{value}" if ($perf_value{infinite_neg} == 0);
          eval "\$perf_value{end} = \$perf_value{end} $options{op} \$options{value}" if ($perf_value{infinite_pos} == 0);
      }
      if (defined($options{total})) {
          $perf_value{start} = $perf_value{start} * $options{total} / 100 if ($perf_value{infinite_neg} == 0);
          $perf_value{end} = $perf_value{end} * $options{total} / 100 if ($perf_value{infinite_pos} == 0);
          $perf_value{start} = sprintf("%.2f", $perf_value{start}) if ($perf_value{infinite_neg} == 0 && (!defined($options{cast_int}) || $options{cast_int} != 1));
          $perf_value{end} = sprintf("%.2f", $perf_value{end}) if ($perf_value{infinite_pos} == 0 && (!defined($options{cast_int}) || $options{cast_int} != 1));
      }
      
      $perf_value{start} = int($perf_value{start}) if ($perf_value{infinite_neg} == 0 && defined($options{cast_int}) && $options{cast_int} == 1);
      $perf_value{end} = int($perf_value{end}) if ($perf_value{infinite_pos} == 0 && defined($options{cast_int}) && $options{cast_int} == 1);
      
      my $perf_output = ($perf_value{arobase} == 1 ? '@' : '') . 
                        (($perf_value{infinite_neg} == 0) ? $perf_value{start} : '~') . 
                        ':' . 
                        (($perf_value{infinite_pos} == 0) ? $perf_value{end} : '');
  
      return $perf_output;
  }
  
  sub threshold_validate {
      my ($self, %options) = @_;
      # $options{label} : threshold label
      # $options{value} : threshold value
  
      my $status = 1;
      $self->{threshold_label}->{$options{label}} = { value => $options{value}, start => undef, end => undef, arobase => undef, infinite_neg => undef, infinite_pos => undef };
      if (!defined($options{value}) || $options{value} eq '') {
          return $status;
      }
  
      ($status, my $result_perf) = 
          centreon::plugins::misc::parse_threshold(threshold => $options{value});
      $self->{threshold_label}->{$options{label}} = { %{$self->{threshold_label}->{$options{label}}}, %$result_perf };
      
      $self->{threshold_label}->{$options{label}}->{start_precision} = $self->{threshold_label}->{$options{label}}->{start};
      if ($self->{threshold_label}->{$options{label}}->{start} =~ /[.,]/) {
          $self->{threshold_label}->{$options{label}}->{start_precision} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $self->{threshold_label}->{$options{label}}->{start});
      }
      
      $self->{threshold_label}->{$options{label}}->{end_precision} = $self->{threshold_label}->{$options{label}}->{end};
      if ($self->{threshold_label}->{$options{label}}->{end} =~ /[.,]/) {
          $self->{threshold_label}->{$options{label}}->{end_precision} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $self->{threshold_label}->{$options{label}}->{end});
      }
      
      return $status;
  }
  
  sub threshold_check {
      my ($self, %options) = @_;
      # Can check multiple threshold. First match: out. Order is important
      # options{value}: value to compare
      # options{threshold}: ref to an array (example: [ {label => 'warning', exit_litteral => 'warning' }, {label => 'critical', exit_litteral => 'critical'} ]
      if ($options{value} =~ /[.,]/) {
          $options{value} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $options{value});
      }
      
      foreach (@{$options{threshold}}) {
          next if (!defined($self->{threshold_label}->{$_->{label}}));
          next if (!defined($self->{threshold_label}->{$_->{label}}->{value}) || $self->{threshold_label}->{$_->{label}}->{value} eq '');
          if ($self->{threshold_label}->{$_->{label}}->{arobase} == 0 && ($options{value} < $self->{threshold_label}->{$_->{label}}->{start_precision} || $options{value} > $self->{threshold_label}->{$_->{label}}->{end_precision})) {
              return $_->{exit_litteral};
          } elsif ($self->{threshold_label}->{$_->{label}}->{arobase}  == 1 && ($options{value} >= $self->{threshold_label}->{$_->{label}}->{start_precision} && $options{value} <= $self->{threshold_label}->{$_->{label}}->{end_precision})) {
              return $_->{exit_litteral};
          }
      }
  
      return 'ok';
  }
  
  sub trim {
      my ($self, $value) = @_;
      
      $value =~ s/^[ \t]+//;
      $value =~ s/[ \t]+$//;
      return $value;
  }
  
  sub change_bytes {
      my ($self, %options) = @_;
  
      my $value = $options{value};
      my $divide = defined($options{network}) ? 1000 : 1024;
      my @units = ('K', 'M', 'G', 'T');
      my $unit = '';
      my $sign = '';
  
      $sign = '-' if ($value != abs($value));
      $value = abs($value);
      
      for (my $i = 0; $i < scalar(@units); $i++) {
          last if (($value / $divide) < 1);
          $unit = $units[$i];
          $value = $value / $divide;
      }
  
      return (sprintf('%.2f', $sign . $value), $unit . (defined($options{network}) ? 'b' : 'B'));
  }
  
  1;
  
  
  =head1 NAME
  
  Perfdata class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 DESCRIPTION
  
  B<perfdata>.
  
  =cut
CENTREON_PLUGINS_PERFDATA

$fatpacked{"centreon/plugins/script.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SCRIPT';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::script;
  
  use strict;
  use warnings;
  use centreon::plugins::output;
  use centreon::plugins::misc;
  use FindBin;
  use Pod::Usage;
  use Pod::Find qw(pod_where);
  
  my %handlers = (DIE => {});
  
  my $global_version = '20190704 (727d0077)';
  my $alternative_fatpacker = 1;
  
  sub new {
      my ($class) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{options} = undef;
      $self->{plugin} = undef;
      $self->{help} = undef;
  
      # Avoid to destroy because it keeps a ref on the object. 
      # A problem if we execute it multiple times in the same perl execution
      # Use prepare_destroy
      $self->set_signal_handlers;
      return $self;
  }
  
  sub prepare_destroy {
      my ($self) = @_;
  
      delete $handlers{DIE}->{$self};
  }
  
  sub set_signal_handlers {
      my $self = shift;
  
      $SIG{__DIE__} = \&class_handle_DIE;
      $handlers{DIE}->{$self} = sub { $self->handle_DIE($_[0]) };
  }
  
  sub class_handle_DIE {
      my ($msg) = @_;
  
      foreach (keys %{$handlers{DIE}}) {
          &{$handlers{DIE}->{$_}}($msg);
      }
  }
  
  sub handle_DIE {
      my ($self, $msg) = @_;
  
      return unless defined $^S and $^S == 0; # Ignore errors in eval
      $self->{output}->add_option_msg(short_msg => $msg);
      $self->{output}->die_exit();
  }
  
  sub get_global_version {
      return $global_version;
  }
  
  sub get_plugin {
      my ($self) = @_;
      
      ######
      # Need to load global 'Output' and 'Options'
      ######
      if ($alternative_fatpacker == 0) {
          require centreon::plugins::options;
          $self->{options} = centreon::plugins::options->new();
      } else {
          require centreon::plugins::alternative::FatPackerOptions;
          $self->{options} = centreon::plugins::alternative::FatPackerOptions->new();
      }
      $self->{output} = centreon::plugins::output->new(options => $self->{options});
      $self->{options}->set_output(output => $self->{output});
  
      $self->{options}->add_options(arguments => {
          'plugin:s'          => { name => 'plugin' },
          'list-plugin'       => { name => 'list_plugin' }, 
          'help'              => { name => 'help' },
          'ignore-warn-msg'   => { name => 'ignore_warn_msg' },
          'version'           => { name => 'version' },
          'runas:s'           => { name => 'runas' },
          'environment:s%'    => { name => 'environment' },
          'convert-args:s'    => { name => 'convert_args' },
      });
  
      $self->{options}->parse_options();
  
      $self->{plugin} = $self->{options}->get_option(argument => 'plugin' );
      $self->{list_plugin} = $self->{options}->get_option(argument => 'list_plugin' );
      $self->{help} = $self->{options}->get_option(argument => 'help' );
      $self->{version} = $self->{options}->get_option(argument => 'version' );
      $self->{runas} = $self->{options}->get_option(argument => 'runas' );
      $self->{environment} = $self->{options}->get_option(argument => 'environment' );
      $self->{ignore_warn_msg} = $self->{options}->get_option(argument => 'ignore_warn_msg' );
      $self->{convert_args} = $self->{options}->get_option(argument => 'convert_args' );
  
      $self->{output}->plugin(name => $self->{plugin});
      $self->{output}->check_options(option_results => $self->{options}->get_options());
  
      $self->{options}->clean();
  }
  
  sub convert_args {
      my ($self) = @_;
      
      if ($self->{convert_args} =~ /^(.+?),(.*)/) {
          my ($search, $replace) = ($1, $2);
          for (my $i = 0; $i <= $#ARGV; $i++) {
              eval "\$ARGV[\$i] =~ s/$search/$replace/g";
          }
      }
  }
  
  sub display_local_help {
      my ($self) = @_;
  
      my $stdout;
      if ($self->{help}) {
          local *STDOUT;
          open STDOUT, '>', \$stdout;
          
          if ($alternative_fatpacker == 0) {
              pod2usage(-exitval => 'NOEXIT', -input => pod_where({-inc => 1}, __PACKAGE__));
          } else {
              my $pp = __PACKAGE__ . '.pm';
              $pp =~ s{::}{/}g;
              my $content_class = $INC{$pp}->{$pp};
              open my $str_fh, '<', \$content_class;
              pod2usage(-exitval => 'NOEXIT', -input => $str_fh);
              close $str_fh;
          }
      }
      
      $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
  }
  
  sub check_directory {
      my ($self, $directory) = @_;
      
      opendir(my $dh, $directory) || return ;
      while (my $filename = readdir $dh) {
          $self->check_directory($directory . '/' . $filename) if ($filename !~ /^\./ && -d $directory . '/' . $filename);
          if ($filename eq 'plugin.pm') {
              my $stdout = '';
              
              {
                  local *STDOUT;
                  open STDOUT, '>', \$stdout;
                  pod2usage(-exitval => 'NOEXIT', -input => $directory . "/" . $filename,
                            -verbose => 99, 
                            -sections => "PLUGIN DESCRIPTION");
              }
              $self->{plugins_result}->{$directory . "/" . $filename} = $stdout;
          }
      }
      closedir $dh;
  }
  
  sub fatpacker_find_plugin {
      my ($self) = @_;
      
      my $plugins = [];
      foreach (@INC) {
          next if (ref($_) !~ /FatPacked/);
          foreach my $name (keys %$_) {
              if ($name =~ /plugin.pm$/) {
                  push @$plugins, $name;
              }
          }
      }
      
      return $plugins;
  }
  
  sub check_plugin_option {
      my ($self) = @_;
      
      if (defined($self->{version})) {
          $self->{output}->add_option_msg(short_msg => 'Global Version: ' . $global_version);
          $self->{output}->option_exit(nolabel => 1);
      }
      
      my $no_plugin = 1;
      if ($alternative_fatpacker == 1) {
          my $integrated_plugins = $self->fatpacker_find_plugin();
          if (scalar(@$integrated_plugins) == 1) {
              $self->{plugin} = $integrated_plugins->[0];
              $no_plugin = 0;
          }
      }
      
      if ($no_plugin == 1) {
          $self->{output}->add_option_msg(short_msg => "Need to specify '--plugin' option.");
          $self->{output}->option_exit();
      }
  }
  
  sub display_list_plugin {
      my ($self) = @_;
      $self->{plugins_result} = {};
      
      if ($alternative_fatpacker == 1) {
          my $integrated_plugins = $self->fatpacker_find_plugin();
          
          foreach my $key (@$integrated_plugins) {
              # Need to load it to get the description
              centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $key, 
                                                     error_msg => 'Cannot load module --plugin.');
                                                 
              my $name = $key;
              $name =~ s/\.pm//g;
              $name =~ s/\//::/g;
              $self->{output}->add_option_msg(long_msg => '-----------------');
              $self->{output}->add_option_msg(long_msg => 'PLUGIN: ' . $name);
              {
                  my $stdout = '';
                  local *STDOUT;
                  open STDOUT, '>', \$stdout;
                  my $content_class = $INC{$key}->{$key};
                  open my $str_fh, '<', \$content_class;
                  pod2usage(-exitval => 'NOEXIT', -input => $str_fh, -verbose => 99, -sections => 'PLUGIN DESCRIPTION');
                  close $str_fh;
                  $self->{output}->add_option_msg(long_msg => $stdout);
              }
          }
          return ;
      }
      
      # Search file 'plugin.pm'
      $self->check_directory($FindBin::Bin);
      foreach my $key (keys %{$self->{plugins_result}}) {
          my $name = $key;
          $name =~ s/^$FindBin::Bin\/(.*)\.pm/$1/;
          $name =~ s/\//::/g;
          $self->{plugins_result}->{$key} =~ s/^Plugin Description/DESCRIPTION/i;
          
          $self->{output}->add_option_msg(long_msg => '-----------------');
          $self->{output}->add_option_msg(long_msg => 'PLUGIN: ' . $name);
          $self->{output}->add_option_msg(long_msg => $self->{plugins_result}->{$key});
      }
  }
  
  sub check_relaunch {
      my $self = shift;
      my $need_restart = 0;
      my $cmd = $FindBin::Bin . "/" . $FindBin::Script;
      my @args = ();
      
      if (defined($self->{environment})) {
          foreach (keys %{$self->{environment}}) {
              if ($_ ne '' && (!defined($ENV{$_}) || $ENV{$_} ne $self->{environment}->{$_})) {
                  $ENV{$_} = $self->{environment}->{$_};
                  $need_restart = 1;
              }
          }
      }
      
      if (defined($self->{runas}) && $self->{runas} ne '') {
          # Check if it's already me and user exist ;)
          my ($name, $passwd, $uid) = getpwnam($self->{runas});
          if (!defined($uid)) {
              $self->{output}->add_option_msg(short_msg => "Runas user '" . $self->{runas} . "' not exist.");
              $self->{output}->option_exit();
          }
          if ($uid != $>) {
              if ($> == 0) {
                  unshift @args, "-s", "/bin/bash", "-l", $self->{runas}, "-c", join(" ", $cmd, "--plugin=" . $self->{plugin}, @ARGV);
                  $cmd = "su";
              } else {
                  unshift @args, "-S", "-u", $self->{runas}, $cmd, "--plugin=" . $self->{plugin}, @ARGV;
                  $cmd = "sudo";
              }
              $need_restart = 1;
          }
      }
  
      if ($need_restart == 1) {
          if (scalar(@args) <= 0) {
              unshift @args, @ARGV, '--plugin=' . $self->{plugin}
          }
  
          my ($lerror, $stdout, $exit_code) = centreon::plugins::misc::backtick(
              command => $cmd,
              arguments => [@args],
              timeout => 30,
              wait_exit => 1
          );
  
          if ($exit_code <= -1000) {
              if ($exit_code == -1000) {
                  $self->{output}->output_add(severity => 'UNKNOWN', 
                                              short_msg => $stdout);
              }
              $self->{output}->display();
              $self->{output}->exit();
          }
          print $stdout;
          # We put unknown
          if (!($exit_code >= 0 && $exit_code <= 4)) {
              exit 3;
          }
          exit $exit_code;
      }
  }
  
  sub run {
      my ($self) = @_;
  
      $self->get_plugin();
  
      if (defined($self->{help}) && !defined($self->{plugin})) {
          $self->display_local_help();
          $self->{output}->option_exit();
      }
      if (defined($self->{list_plugin})) {
          $self->display_list_plugin();
          $self->{output}->option_exit();
      }
      $self->check_plugin_option() if (!defined($self->{plugin}) || $self->{plugin} eq '');
      if (defined($self->{ignore_warn_msg})) {
          $SIG{__WARN__} = sub {};
      }
      $self->convert_args() if (defined($self->{convert_args}));
  
      $self->check_relaunch();
      
      (undef, $self->{plugin}) = 
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{plugin}, 
                                                 error_msg => 'Cannot load module --plugin.');
      my $plugin = $self->{plugin}->new(options => $self->{options}, output => $self->{output});
      $plugin->init(help => $self->{help},
                    version => $self->{version});
      $plugin->run();
  }
  
  1;
  
  
  =head1 NAME
  
  centreon_plugins.pl - main program to call Centreon plugins.
  
  =head1 SYNOPSIS
  
  centreon_plugins.pl [options]
  
  =head1 OPTIONS
  
  =over 8
  
  =item B<--plugin>
  
  Specify the path to the plugin.
  
  =item B<--list-plugin>
  
  Print available plugins.
  
  =item B<--version>
  
  Print global version.
  
  =item B<--help>
  
  Print a brief help message and exits.
  
  =item B<--ignore-warn-msg>
  
  Perl warn messages are ignored (not displayed).
  
  =item B<--runas>
  
  Run the script as a different user (prefer to use directly the good user).
  
  =item B<--environment>
  
  Set environment variables for the script (prefer to set it before running it for better performance).
  
  =item B<--convert-args>
  
  Change strings of arguments. Useful to use '!' in nrpe protocol.
  Example: --convert-args='##,\x21'
  
  =back
  
  =head1 DESCRIPTION
  
  B<centreon_plugins.pl> .
  
  =cut
CENTREON_PLUGINS_SCRIPT

$fatpacked{"centreon/plugins/script_custom.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SCRIPT_CUSTOM';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::script_custom;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      # $options{package} = parent package caller
      # $options{options} = options object
      # $options{output} = output object
      $self->{options} = $options{options};
      $self->{output} = $options{output};
      
      $self->{options}->add_options(
          arguments => {
              'mode:s'          => { name => 'mode_name' },
              'dyn-mode:s'      => { name => 'dynmode_name' },
              'list-mode'       => { name => 'list_mode' },
              'custommode:s'    => { name => 'custommode_name' },
              'list-custommode' => { name => 'list_custommode' },
              'multiple'        => { name => 'multiple' },
              'sanity-options'  => { name => 'sanity_options' }, # keep it for 6 month before remove it
          }
      );
      $self->{version} = '1.0';
      %{$self->{modes}} = ();
      %{$self->{custom_modes}} = ();
      $self->{default} = undef;
      $self->{customdefault} = {};
      $self->{custommode_current} = undef;
      $self->{custommode_stored} = [];
      
      $self->{options}->parse_options();
      $self->{option_results} = $self->{options}->get_options();
      foreach (keys %{$self->{option_results}}) {
          $self->{$_} = $self->{option_results}->{$_};
      }
      $self->{options}->clean();
  
      $self->{options}->add_help(package => $options{package}, sections => 'PLUGIN DESCRIPTION');
      $self->{options}->add_help(package => __PACKAGE__, sections => 'GLOBAL OPTIONS');
      $self->{output}->mode(name => $self->{mode_name});
  
      return $self;
  }
  
  sub load_custom_mode {
      my ($self, %options) = @_;
      
      $self->is_custommode(custommode => $self->{custommode_name});
      centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{custom_modes}{$self->{custommode_name}}, 
                                             error_msg => "Cannot load module --custommode.");
      $self->{custommode_current} = $self->{custom_modes}{$self->{custommode_name}}->new(options => $self->{options}, output => $self->{output}, mode => $self->{custommode_name});
  }
  
  sub init {
      my ($self, %options) = @_;
      # $options{version} = string version
      # $options{help} = string help
  
      if (defined($options{help}) && !defined($self->{mode_name}) && !defined($self->{dynmode_name})) {
          $self->{options}->display_help();
          $self->{output}->option_exit();
      }
      if (defined($options{version}) && !defined($self->{mode_name})&& !defined($self->{dynmode_name})) {
          $self->version();
      }
      if (defined($self->{list_mode})) {
          $self->list_mode();
      }
      if (defined($self->{list_custommode})) {
          $self->list_custommode();
      }
      $self->{options}->set_sanity();
  
      # Output HELP
      $self->{options}->add_help(package => 'centreon::plugins::output', sections => 'OUTPUT OPTIONS');
      
      $self->load_password_mgr();
  
      if (defined($self->{custommode_name}) && $self->{custommode_name} ne '') {
          $self->load_custom_mode();
      } elsif (scalar(keys %{$self->{custom_modes}}) == 1) {
          $self->{custommode_name} = (keys(%{$self->{custom_modes}}))[0];
          $self->load_custom_mode();
      } else {
          $self->{output}->add_option_msg(short_msg => "Need to specify '--custommode'.");
          $self->{output}->option_exit();
      }
      
      # Load mode
      if (defined($self->{mode_name}) && $self->{mode_name} ne '') {
          $self->is_mode(mode => $self->{mode_name});
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{modes}{$self->{mode_name}}, 
                                                 error_msg => "Cannot load module --mode.");
          $self->{mode} = $self->{modes}{$self->{mode_name}}->new(options => $self->{options}, output => $self->{output}, mode => $self->{mode_name});
      } elsif (defined($self->{dynmode_name}) && $self->{dynmode_name} ne '') {
          (undef, $self->{dynmode_name}) = centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{dynmode_name}, 
                                                                                  error_msg => "Cannot load module --dyn-mode.");
          $self->{mode} = $self->{dynmode_name}->new(options => $self->{options}, output => $self->{output}, mode => $self->{dynmode_name});
      } else {
          $self->{output}->add_option_msg(short_msg => "Need to specify '--mode' or '--dyn-mode' option.");
          $self->{output}->option_exit();
      }
  
      if (defined($options{help})) {
          if (defined($self->{mode_name}) && $self->{mode_name} ne '') {
              $self->{options}->add_help(package => $self->{modes}{$self->{mode_name}}, sections => 'MODE');
          } else {
              $self->{options}->add_help(package => $self->{dynmode_name}, sections => 'MODE');
          }
          $self->{options}->display_help();
          $self->{output}->option_exit();
      }
      if (defined($options{version})) {
          $self->{mode}->version();
          $self->{output}->option_exit(nolabel => 1);
      }
      
      $self->{options}->parse_options();
      $self->{option_results} = $self->{options}->get_options();
      $self->{pass_mgr}->manage_options(option_results => $self->{option_results}) if (defined($self->{pass_mgr}));
  
      push @{$self->{custommode_stored}}, $self->{custommode_current};
      $self->{custommode_current}->set_options(option_results => $self->{option_results});
      $self->{custommode_current}->set_defaults(default => $self->{customdefault});
  
      while ($self->{custommode_current}->check_options()) {
          $self->{custommode_current} = $self->{custom_modes}{$self->{custommode_name}}->new(noptions => 1, options => $self->{options}, output => $self->{output}, mode => $self->{custommode_name});
          $self->{custommode_current}->set_options(option_results => $self->{option_results});
          push @{$self->{custommode_stored}}, $self->{custommode_current};
      }
      $self->{mode}->check_options(option_results => $self->{option_results}, default => $self->{default});
  }
  
  sub load_password_mgr {
      my ($self, %options) = @_;
      
      return if (!defined($self->{option_results}->{pass_manager}) || $self->{option_results}->{pass_manager} eq '');
  
      (undef, my $pass_mgr_name) = centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => "centreon::plugins::passwordmgr::" . $self->{option_results}->{pass_manager}, 
          error_msg => "Cannot load module 'centreon::plugins::passwordmgr::" . $self->{option_results}->{pass_manager} . "'"
      );
      $self->{pass_mgr} = $pass_mgr_name->new(options => $self->{options}, output => $self->{output});
  }
  
  sub run {
      my $self = shift;
  
      if ($self->{output}->is_disco_format()) {
          $self->{mode}->disco_format();
          $self->{output}->display_disco_format();
          $self->{output}->exit(exit_litteral => 'ok');
      }
  
      if ($self->{output}->is_disco_show()) {
          if (defined($self->{multiple})) {
              $self->{mode}->disco_show(custom => $self->{custommode});
          } else {
              $self->{mode}->disco_show(custom => $self->{custommode_stored}[0]);
          }
          $self->{output}->display_disco_show();
          $self->{output}->exit(exit_litteral => 'ok');
      } else {
          if (defined($self->{multiple})) {
              $self->{mode}->run(custom => $self->{custommode_stored});
          } else {
              $self->{mode}->run(custom => $self->{custommode_stored}[0]);
          }
      }
  }
  
  sub is_mode {
      my ($self, %options) = @_;
      
      # $options->{mode} = mode
      if (!defined($self->{modes}{$options{mode}})) {
          $self->{output}->add_option_msg(short_msg => "mode '" . $options{mode} . "' doesn't exist (use --list-mode option to show available modes).");
          $self->{output}->option_exit();
      }
  }
  
  sub is_custommode {
      my ($self, %options) = @_;
      
      # $options->{custommode} = mode
      if (!defined($self->{custom_modes}{$options{custommode}})) {
          $self->{output}->add_option_msg(short_msg => "mode '" . $options{custommode} . "' doesn't exist (use --list-custommode option to show available modes).");
          $self->{output}->option_exit();
      }
  }
  
  sub version {
      my $self = shift;    
      $self->{output}->add_option_msg(short_msg => "Plugin Version: " . $self->{version});
      $self->{output}->option_exit(nolabel => 1);
  }
  
  sub list_mode {
      my $self = shift;
      $self->{options}->display_help();
      
      $self->{output}->add_option_msg(long_msg => "Modes Available:");
      foreach (sort keys %{$self->{modes}}) {
          $self->{output}->add_option_msg(long_msg => "   " . $_);
      }
      $self->{output}->option_exit(nolabel => 1);
  }
  
  sub list_custommode {
      my $self = shift;
      $self->{options}->display_help();
      
      $self->{output}->add_option_msg(long_msg => "Custom Modes Available:");
      foreach (keys %{$self->{custom_modes}}) {
          $self->{output}->add_option_msg(long_msg => "   " . $_);
      }
      $self->{output}->option_exit(nolabel => 1);
  }
  
  1;
  
  
  =head1 NAME
  
  -
  
  =head1 SYNOPSIS
  
  -
  
  =head1 GLOBAL OPTIONS
  
  =over 8
  
  =item B<--mode>
  
  Choose a mode.
  
  =item B<--dyn-mode>
  
  Specify a mode with the path (separated by '::').
  
  =item B<--list-mode>
  
  List available modes.
  
  =item B<--mode-version>
  
  Check minimal version of mode. If not, unknown error.
  
  =item B<--version>
  
  Display plugin version.
  
  =item B<--custommode>
  
  Choose a custom mode.
  
  =item B<--list-custommode>
  
  List available custom modes.
  
  =item B<--multiple>
  
  Multiple custom mode objects (some mode needs it).
  
  =back
  
  =head1 DESCRIPTION
  
  B<>.
  
  =cut
CENTREON_PLUGINS_SCRIPT_CUSTOM

$fatpacked{"centreon/plugins/statefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_STATEFILE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::statefile;
  
  use strict;
  use warnings;
  use Data::Dumper;
  use vars qw($datas);
  use centreon::plugins::misc;
  
  my $default_dir = '/var/lib/centreon/centplugins';
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (defined($options{options})) {
          $options{options}->add_options(arguments => {
              'memcached:s'           => { name => 'memcached' },
              'redis-server:s'        => { name => 'redis_server' },
              'redis-attribute:s%'    => { name => 'redis_attribute' },
              'redis-db:s'            => { name => 'redis_db' },
              'memexpiration:s'       => { name => 'memexpiration', default => 86400 },
              'statefile-dir:s'       => { name => 'statefile_dir', default => $default_dir },
              'statefile-suffix:s'    => { name => 'statefile_suffix', default => '' },
              'statefile-concat-cwd'  => { name => 'statefile_concat_cwd' },
              'statefile-storable'    => { name => 'statefile_storable' },
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'RETENTION OPTIONS', once => 1);
      }
      
      $self->{error} = 0;
      $self->{output} = $options{output};
      $self->{datas} = {};
      $self->{storable} = 0;
      $self->{memcached_ok} = 0;
      $self->{memcached} = undef;
      
      $self->{statefile_dir} = undef;
      $self->{statefile_suffix} = undef;
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      if (defined($options{option_results}) && defined($options{option_results}->{memcached})) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Memcached::libmemcached',
                                                 error_msg => "Cannot load module 'Memcached::libmemcached'.");
          $self->{memcached} = Memcached::libmemcached->new();
          Memcached::libmemcached::memcached_server_add($self->{memcached}, $options{option_results}->{memcached});
      }
      
      # Check redis
      if (defined($options{option_results}->{redis_server})) {
          $self->{redis_attributes} = '';
          if (defined($options{option_results}->{redis_attribute})) {
              foreach (keys %{$options{option_results}->{redis_attribute}}) {
                  $self->{redis_attributes} .= "$_ => " . $options{option_results}->{redis_attribute}->{$_} . ', ';
              }
          }
          
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Redis',
                                                 error_msg => "Cannot load module 'Redis'.");
          eval {
              $self->{redis_cnx} = Redis->new(server => $options{option_results}->{redis_server}, 
                                              eval $self->{redis_attributes});
              if (defined($self->{redis_cnx}) && 
                  defined($options{option_results}->{redis_db}) &&
                  $options{option_results}->{redis_db} ne ''
                  ) {
                  $self->{redis_cnx}->select($options{option_results}->{redis_db});
              }
          };
      }
      
      $self->{statefile_dir} = $options{option_results}->{statefile_dir};
      if ($self->{statefile_dir} ne $default_dir && defined($options{option_results}->{statefile_concat_cwd})) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Cwd',
                                                 error_msg => "Cannot load module 'Cwd'.");
          $self->{statefile_dir} = Cwd::cwd() . '/' . $self->{statefile_dir};
      }
      if (defined($options{option_results}->{statefile_storable})) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'Storable',
                                                 error_msg => "Cannot load module 'Storable'.");
          $self->{storable} = 1;
      }
      $self->{statefile_suffix} = $options{option_results}->{statefile_suffix};
      $self->{memexpiration} = $options{option_results}->{memexpiration};
  }
  
  sub error {
      my ($self) = shift;
       
      if (@_) {
          $self->{error} = $_[0];
      }
      return $self->{error};
  }
  
  sub read {
      my ($self, %options) = @_;
      $self->{statefile_suffix} = defined($options{statefile_suffix}) ? $options{statefile_suffix} : $self->{statefile_suffix};
      $self->{statefile_dir} = defined($options{statefile_dir}) ? $options{statefile_dir} : $self->{statefile_dir};
      $self->{statefile} = defined($options{statefile}) ? $options{statefile} . $self->{statefile_suffix} : 
                              $self->{statefile};
      $self->{no_quit} = defined($options{no_quit}) && $options{no_quit} == 1 ? 1 : 0;
  
      if (defined($self->{memcached})) {
          # if "SUCCESS" or "NOT FOUND" is ok. Other with use the file
          my $val = Memcached::libmemcached::memcached_get($self->{memcached}, $self->{statefile_dir} . "/" . $self->{statefile});
          if (defined($self->{memcached}->errstr) && $self->{memcached}->errstr =~ /^SUCCESS|NOT FOUND$/i) {
              $self->{memcached_ok} = 1;
              if (defined($val)) {
                  eval( $val );
                  $self->{datas} = $datas;
                  $datas = {};
                  return 1;
              }
              return 0;
          }
      }
      
      if (defined($self->{redis_cnx})) {
          my $val = $self->{redis_cnx}->get($self->{statefile_dir} . "/" . $self->{statefile});
          if (defined($val)) {
              eval($val);
              $self->{datas} = $datas;
              $datas = {};
              return 1;
          }
          
          return 0;
      }
      
      if (! -e $self->{statefile_dir} . '/' . $self->{statefile}) {
          if (! -w $self->{statefile_dir} || ! -x $self->{statefile_dir}) {
              $self->error(1);
              $self->{output}->add_option_msg(short_msg =>  "Cannot write statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'. Need write/exec permissions on directory.");
              if ($self->{no_quit} == 0) {
                  $self->{output}->option_exit();
              }
          }
          return 0;
      } elsif (! -w $self->{statefile_dir} . '/' . $self->{statefile}) {
          $self->error(1);
          $self->{output}->add_option_msg(short_msg => "Cannot write statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'. Need write permissions on file.");
          if ($self->{no_quit} == 0) {
              $self->{output}->option_exit();
          }
          return 1;
      } elsif (! -s $self->{statefile_dir} . '/' . $self->{statefile}) {
          # Empty file. Not a problem. Maybe plugin not manage not values
          return 0;
      }
      
      if ($self->{storable} == 1) {
          open FILE, $self->{statefile_dir} . '/' . $self->{statefile};
          eval {
              $self->{datas} = Storable::fd_retrieve(*FILE);
          };
          # File is corrupted surely. We'll reset it
          if ($@) {
              close FILE;
              return 0;
          }
          close FILE;
      } else {
          unless (my $return = do $self->{statefile_dir} . '/' . $self->{statefile}) {
              # File is corrupted surely. We'll reset it
              return 0;
              #if ($@) {
              #    $self->{output}->add_option_msg(short_msg => "Couldn't parse '" . $self->{statefile_dir} . "/" . $self->{statefile} . "': $@");
              #    $self->{output}->option_exit();
              #}
              #unless (defined($return)) {
              #    $self->{output}->add_option_msg(short_msg => "Couldn't do '" . $self->{statefile_dir} . "/" . $self->{statefile} . "': $!");
              #    $self->{output}->option_exit();
              #}
              #unless ($return) {
              #    $self->{output}->add_option_msg(short_msg => "Couldn't run '" . $self->{statefile_dir} . "/" . $self->{statefile} . "': $!");
              #    $self->{output}->option_exit();
          }
          $self->{datas} = $datas;
          $datas = {};
      }
  
      return 1;
  }
  
  sub get_string_content {
      my ($self, %options) = @_;
  
      return Data::Dumper::Dumper($self->{datas});
  }
  
  sub get {
      my ($self, %options) = @_;
  
      if (defined($self->{datas}->{$options{name}})) {
          return $self->{datas}->{$options{name}};
      }
      return undef;
  }
  
  sub write {
      my ($self, %options) = @_;
  
      if ($self->{memcached_ok} == 1) {
          Memcached::libmemcached::memcached_set($self->{memcached}, $self->{statefile_dir} . '/' . $self->{statefile}, 
                                                 Data::Dumper->Dump([$options{data}], ['datas']), $self->{memexpiration});
          if (defined($self->{memcached}->errstr) && $self->{memcached}->errstr =~ /^SUCCESS$/i) {
              return ;
          }
      }
      if (defined($self->{redis_cnx})) {
          return if (defined($self->{redis_cnx}->set($self->{statefile_dir} . '/' . $self->{statefile}, Data::Dumper->Dump([$options{data}], ['datas']),
                                                    'EX', $self->{memexpiration})));
      }
      open FILE, '>', $self->{statefile_dir} . '/' . $self->{statefile};
      if ($self->{storable} == 1) {
          Storable::store_fd($options{data}, *FILE);
      } else {
          print FILE Data::Dumper->Dump([$options{data}], ['datas']);
      }
      close FILE;
  }
  
  1;
  
  
  =head1 NAME
  
  Statefile class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 RETENTION OPTIONS
  
  =over 8
  
  =item B<--memcached>
  
  Memcached server to use (only one server).
  
  =item B<--redis-server>
  
  Redis server to use (only one server).
  
  =item B<--redis-attribute>
  
  Set Redis Options (--redis-attribute="cnx_timeout=5").
  
  =item B<--redis-db>
  
  Set Redis database index.
  
  =item B<--memexpiration>
  
  Time to keep data in seconds (Default: 86400).
  
  =item B<--statefile-dir>
  
  Directory for statefile (Default: '/var/lib/centreon/centplugins').
  
  =item B<--statefile-suffix>
  
  Add a suffix for the statefile name (Default: '').
  
  =item B<--statefile-concat-cwd>
  
  Concat current working directory with option '--statefile-dir'.
  Useful on Windows when plugin is compiled.
  
  =item B<--statefile-storable>
  
  Use Perl Module 'Storable' (instead Data::Dumper) to store datas.
  
  =back
  
  =head1 DESCRIPTION
  
  B<statefile>.
  
  =cut
CENTREON_PLUGINS_STATEFILE

$fatpacked{"centreon/plugins/templates/catalog_functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_CATALOG_FUNCTIONS';
  #
  # Copyright 2018 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::catalog_functions;
  
  use strict;
  use warnings;
  use Exporter;
  
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(catalog_status_threshold catalog_status_calc);
  
  sub catalog_status_threshold {
      my ($self, %options) = @_;
      my $status = 'ok';
      my $message;
  
      eval {
          local $SIG{__WARN__} = sub { $message = $_[0]; };
          local $SIG{__DIE__} = sub { $message = $_[0]; };
  
          my $label = $self->{label};
          $label =~ s/-/_/g;
          if (defined($self->{instance_mode}->{option_results}->{'ok_' . $label}) && $self->{instance_mode}->{option_results}->{'ok_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'ok_' . $label}") {
              $status = 'ok';
          } elsif (defined($self->{instance_mode}->{option_results}->{'critical_' . $label}) && $self->{instance_mode}->{option_results}->{'critical_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'critical_' . $label}") {
              $status = 'critical';
          } elsif (defined($self->{instance_mode}->{option_results}->{'warning_' . $label}) && $self->{instance_mode}->{option_results}->{'warning_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'warning_' . $label}") {
              $status = 'warning';
          } elsif (defined($self->{instance_mode}->{option_results}->{'unknown_' . $label}) && $self->{instance_mode}->{option_results}->{'unknown_' . $label} ne '' &&
              eval "$self->{instance_mode}->{option_results}->{'unknown_' . $label}") {
              $status = 'unknown';
          }
      };
      if (defined($message)) {
          $self->{output}->output_add(long_msg => 'filter status issue: ' . $message);
      }
  
      return $status;
  }
  
  sub catalog_status_calc {
      my ($self, %options) = @_;
  
      foreach (keys %{$options{new_datas}}) {
          if (/^\Q$self->{instance}\E_(.*)/) {
              $self->{result_values}->{$1} = $options{new_datas}->{$_};
          }
      }
  }
  
  1;
  
  
CENTREON_PLUGINS_TEMPLATES_CATALOG_FUNCTIONS

$fatpacked{"centreon/plugins/templates/counter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_COUNTER';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::counter;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  use centreon::plugins::values;
  use centreon::plugins::misc;
  
  my $sort_subs = {
      num => sub { $a <=> $b },
      cmp => sub { $a cmp $b },
  };
  
  sub set_counters {
      my ($self, %options) = @_;
      
      if (!defined($self->{maps_counters})) {
          $self->{maps_counters} = {};
      }
      
      $self->{maps_counters_type} = [];
      
      # 0 = mode total
      # 1 = mode instances
      #push @{$self->{maps_counters_type}}, { 
      #    name => 'global', type => 0, message_separator => ', ', cb_prefix_output => undef, cb_init => undef,
      #};
  
      #$self->{maps_counters}->{global} = [
      #    { label => 'client', set => {
      #           key_values => [ { name => 'client' } ],
      #           output_template => 'Current client connections : %s',
      #           perfdatas => [
      #               { label => 'Client', value => 'client_absolute', template => '%s', 
      #                 min => 0, unit => 'con' },
      #           ],
      #       }
      #    },
      #];
      
      # Example for instances
      #push @{$self->{maps_counters_type}}, { 
      #    name => 'cpu', type => 1, message_separator => ', ', cb_prefix_output => undef, cb_init => undef,
      #    message_multiple => 'All CPU usages are ok',
      #};    
  }
  
  sub get_callback {
      my ($self, %options) = @_;
  
      if (defined($options{method_name})) {
          return $self->can($options{method_name});
      }
      
      return undef;
  }
  
  sub call_object_callback {
      my ($self, %options) = @_;
      
      if (defined($options{method_name})) {
          my $method = $self->can($options{method_name});
          if ($method) {
              return $self->$method(%options);
          }
      }
      
      return undef;
  }
  
  sub get_threshold_prefix {
      my ($self, %options) = @_;
      
      my $prefix = '';
      END_LOOP: foreach (@{$self->{maps_counters_type}}) {
          if ($_->{name} eq $options{name}) {
              $prefix = 'instance-' if ($_->{type} == 1);
              last;
          }
          
          if ($_->{type} == 3) {
              foreach (@{$_->{group}}) {
                  if ($_->{name} eq $options{name}) {
                      $prefix = 'instance-' if ($_->{type} == 0);
                      $prefix = 'subinstance-' if ($_->{type} == 1);
                      last END_LOOP;
                  }
              }
          }
      }
  
      return $prefix;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $self->{version} = '1.0';
      $options{options}->add_options(arguments => {
          'filter-counters:s'     => { name => 'filter_counters' },
          'display-ok-counters:s' => { name => 'display_ok_counters' },
          'list-counters'         => { name => 'list_counters' },
      });
      $self->{statefile_value} = undef;
      if (defined($options{statefile}) && $options{statefile}) {
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => 'centreon::plugins::statefile',
                                                 error_msg => "Cannot load module 'centreon::plugins::statefile'.");
          $self->{statefile_value} = centreon::plugins::statefile->new(%options);
      }
      
      $self->{maps_counters} = {} if (!defined($self->{maps_counters}));
      $self->set_counters(%options);
      
      foreach my $key (keys %{$self->{maps_counters}}) {
          foreach (@{$self->{maps_counters}->{$key}}) {
              my $label = $_->{label};
              my $thlabel = $label;
              if ($self->{output}->use_new_perfdata() && defined($_->{nlabel})) {
                  $label = $_->{nlabel};
                  $thlabel = $self->get_threshold_prefix(name => $key) . $label;
              }
              $thlabel =~ s/\./-/g;
              
              if (!defined($_->{threshold}) || $_->{threshold} != 0) {
                  $options{options}->add_options(arguments => {
                      'warning-' . $thlabel . ':s'     => { name => 'warning-' . $thlabel },
                      'critical-' . $thlabel . ':s'    => { name => 'critical-' . $thlabel },
                  });
  
                  if (defined($_->{nlabel})) {
                      $options{options}->add_options(arguments => {
                          'warning-' . $_->{label} . ':s'     => { name => 'warning-' . $_->{label}, redirect => 'warning-' . $thlabel },
                          'critical-' . $_->{label} . ':s'    => { name => 'critical-' . $_->{label}, redirect => 'critical-' . $thlabel },
                      });
                  }
              }
              $_->{obj} = centreon::plugins::values->new(
                  statefile => $self->{statefile_value},
                  output => $self->{output}, perfdata => $self->{perfdata},
                  label => $_->{label}, nlabel => $_->{nlabel}, thlabel => $thlabel,
              );
              $_->{obj}->set(%{$_->{set}});
          }
      }
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (defined($self->{option_results}->{list_counters})) {
          my $list_counter = 'counter list:';
          my $th_counter = '';
          foreach my $key (keys %{$self->{maps_counters}}) {
              foreach (@{$self->{maps_counters}->{$key}}) {
                  my $label = $_->{label};
                  $label =~ s/-//g;
                  $list_counter .= " " . $_->{label};
                  $th_counter .= " --warning-$_->{label}='\$_SERVICEWARNING" . uc($label) . "\$' --critical-$_->{label}='\$_SERVICECRITICAL" . uc($label) . "\$'";  
              }
          }
          $self->{output}->output_add(short_msg => $list_counter);
          $self->{output}->output_add(long_msg => 'configuration: ' . $th_counter); 
          $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1);
          $self->{output}->exit();
      }
      foreach my $key (keys %{$self->{maps_counters}}) {
          foreach (@{$self->{maps_counters}->{$key}}) {
              $_->{obj}->{instance_mode} = $self;
              $_->{obj}->init(option_results => $self->{option_results});
          }
      }
      
      if (defined($self->{statefile_value})) {
          $self->{statefile_value}->check_options(%options);
      }
  }
  
  sub run_global {
      my ($self, %options) = @_;
      
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $resume = defined($options{resume}) && $options{resume} == 1 ? 1 : 0;
      # Can be set when it comes from type 3 counters
      my $called_multiple = defined($options{called_multiple}) && $options{called_multiple} == 1 ? 1 : 0;
      my $multiple_parent = defined($options{multiple_parent}) && $options{multiple_parent} == 1 ? 1 : 0;
      my $force_instance = defined($options{force_instance}) ? $options{force_instance} : undef;
      
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator}: ', ';
      my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
      my @exits;
      foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
          my $obj = $_->{obj};
  
          next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
              $_->{label} !~ /$self->{option_results}->{filter_counters}/);
      
          $obj->set(instance => defined($force_instance) ? $force_instance : $options{config}->{name});
      
          my ($value_check) = $obj->execute(new_datas => $self->{new_datas}, values => $self->{$options{config}->{name}});
  
          next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
          if ($value_check != 0) {
              $long_msg .= $long_msg_append . $obj->output_error();
              $long_msg_append = $message_separator;
              next;
          }
          my $exit2 = $obj->threshold_check();
          push @exits, $exit2;
  
          my $output = $obj->output();
          if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
              (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
               $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
              $long_msg .= $long_msg_append . $output;
              $long_msg_append = $message_separator;
          }
  
          if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
              $short_msg .= $short_msg_append . $output;
              $short_msg_append = $message_separator;
          }
          
          $obj->perfdata(extra_instance => $multiple_parent);
      }
  
      my ($prefix_output, $suffix_output);
      $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}) 
          if (defined($options{config}->{cb_prefix_output}));
      $prefix_output = '' if (!defined($prefix_output));
      
      $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
      $suffix_output = '' if (!defined($suffix_output));
      
      if ($called_multiple == 1 && $long_msg ne '') {
          $self->{output}->output_add(long_msg => $options{indent_long_output} . $prefix_output. $long_msg . $suffix_output);
      }
      
      my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
      if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
          if ($called_multiple == 0) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => $prefix_output . $short_msg . $suffix_output);
          } else {
              $self->run_multiple_prefix_output(severity => $exit,
                                                short_msg => $prefix_output . $short_msg . $suffix_output);
          }
      } else {
          if ($long_msg ne '' && $multiple_parent == 0) {
              if ($called_multiple == 0) {
                  $self->{output}->output_add(short_msg => $prefix_output . $long_msg . $suffix_output) ;
              } else {
                  $self->run_multiple_prefix_output(severity => 'ok',
                                                    short_msg => $prefix_output . $long_msg . $suffix_output);
              }
          }
      }
  }
  
  sub run_instances {
      my ($self, %options) = @_;
      
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $cb_init_counters = $self->get_callback(method_name => $options{config}->{cb_init_counters});
      my $display_status_lo = defined($options{display_status_long_output}) && $options{display_status_long_output} == 1 ? 1 : 0;
      my $resume = defined($options{resume}) && $options{resume} == 1 ? 1 : 0;
      my $no_message_multiple = 1;
      
      $self->{lproblems} = 0;
      $self->{multiple} = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $self->{multiple} = 0;
      }
      
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator}: ', ';
  
      my $sort_method = 'cmp';
      $sort_method = $options{config}->{sort_method}
          if (defined($options{config}->{sort_method}));
      foreach my $id (sort { $sort_subs->{$sort_method}->() } keys %{$self->{$options{config}->{name}}}) {
          my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
          my @exits = ();
          foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
              my $obj = $_->{obj};
  
              next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
                  $_->{label} !~ /$self->{option_results}->{filter_counters}/);
              next if ($cb_init_counters && $self->$cb_init_counters(%$_) == 1);
  
              $no_message_multiple = 0;
              $obj->set(instance => $id);
          
              my ($value_check) = $obj->execute(new_datas => $self->{new_datas},
                                                values => $self->{$options{config}->{name}}->{$id});
              next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
              if ($value_check != 0) {
                  $long_msg .= $long_msg_append . $obj->output_error();
                  $long_msg_append = $message_separator;
                  next;
              }
              my $exit2 = $obj->threshold_check();
              push @exits, $exit2;
  
              my $output = $obj->output();
              if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
                  (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
                   $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
                  $long_msg .= $long_msg_append . $output;
                  $long_msg_append = $message_separator;
              }
              
              if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
                  $self->{lproblems}++;
                  $short_msg .= $short_msg_append . $output;
                  $short_msg_append = $message_separator;
              }
              
              $obj->perfdata(extra_instance => $self->{multiple});
          }
  
          my ($prefix_output, $suffix_output);
          $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
          $prefix_output = '' if (!defined($prefix_output));
          
          $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
          $suffix_output = '' if (!defined($suffix_output));
  
          my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
          # in mode grouped, we don't display 'ok'
          my $debug = 0;
          $debug = 1 if ($display_status_lo == 1 && $self->{output}->is_status(value => $exit, compare => 'OK', litteral => 1));
          if (scalar @{$self->{maps_counters}->{$options{config}->{name}}} > 0 && $long_msg ne '') {
              $self->{output}->output_add(long_msg => ($display_status_lo == 1 ? lc($exit) . ': ' : '') . $prefix_output . $long_msg . $suffix_output, debug => $debug);
          }
          if ($resume == 1) {
              $self->{most_critical_instance} = $self->{output}->get_most_critical(status => [ $self->{most_critical_instance},  $exit ]);  
              next;
          }
          
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => $prefix_output . $short_msg . $suffix_output);
          }
          
          if ($self->{multiple} == 0)  {
              $self->{output}->output_add(short_msg => $prefix_output . $long_msg . $suffix_output);
          }
      }
      
      if ($no_message_multiple == 0 && $self->{multiple} == 1 && $resume == 0) {
          $self->{output}->output_add(short_msg => $options{config}->{message_multiple});
      }
  }
  
  sub run_group {
      my ($self, %options) = @_;
  
      my $multiple = 1;
      return if (scalar(keys %{$self->{$options{config}->{name}}}) <= 0);
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $multiple = 0;
      }
      
      if ($multiple == 1) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => $options{config}->{message_multiple});
      }
      
      my $format_output = defined($options{config}->{format_output}) ? $options{config}->{format_output} : '%s problem(s) detected';
      
      my ($global_exit, $total_problems) = ([], 0);
      foreach my $id (sort keys %{$self->{$options{config}->{name}}}) {
          $self->{most_critical_instance} = 'ok';
          if (defined($options{config}->{cb_long_output})) {
              $self->{output}->output_add(long_msg => $self->call_object_callback(method_name => $options{config}->{cb_long_output},
                                                                                  instance_value => $self->{$options{config}->{name}}->{$id}));
          }
          
          foreach my $group (@{$options{config}->{group}}) {
              $self->{$group->{name}} = $self->{$options{config}->{name}}->{$id}->{$group->{name}};
              
              # we resume datas
              $self->run_instances(config => $group, display_status_long_output => 1, resume => 1);
              
              push @{$global_exit}, $self->{most_critical_instance};
              $total_problems += $self->{lproblems};
              
              my $prefix_output;
              $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
              $prefix_output = '' if (!defined($prefix_output));
              
              if ($multiple == 0 && (!defined($group->{display}) || $group->{display} != 0)) {
                  $self->{output}->output_add(severity => $self->{most_critical_instance},
                                              short_msg => sprintf("${prefix_output}" . $format_output, $self->{lproblems}));
              }
          }
      }
      
      if ($multiple == 1) {
          my $exit = $self->{output}->get_most_critical(status => [ @{$global_exit} ]);
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf($format_output, $total_problems));
          }
      }
      
      if (defined($options{config}->{display_counter_problem})) {
          $self->{output}->perfdata_add(
              label => $options{config}->{display_counter_problem}->{label},
              nlabel => $options{config}->{display_counter_problem}->{nlabel},
              unit => $options{config}->{display_counter_problem}->{unit},
              value => $total_problems,
              min => $options{config}->{display_counter_problem}->{min}, max => $options{config}->{display_counter_problem}->{max}
          );
      }
  }
  
  sub run_multiple_instances {
      my ($self, %options) = @_;
      
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $use_new_perfdata = $self->{output}->use_new_perfdata();
      my $multiple_parent = defined($options{multiple_parent}) && $options{multiple_parent} == 1 ? $options{multiple_parent} : 0;
      my $indent_long_output = defined($options{indent_long_output}) ? $options{indent_long_output} : '';
      my $no_message_multiple = 1;
      
      my $multiple = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $multiple = 0;
      }
      
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator} : ', ';
      my $sort_method = 'cmp';
      $sort_method = $options{config}->{sort_method}
          if (defined($options{config}->{sort_method}));
      foreach my $id (sort { $sort_subs->{$sort_method}->() } keys %{$self->{$options{config}->{name}}}) {
          my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
          my @exits = ();
          foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
              my $obj = $_->{obj};
              
              next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
                  $_->{label} !~ /$self->{option_results}->{filter_counters}/);
              
              my $instance = $id;
              if ($use_new_perfdata || ($multiple_parent == 1 && $multiple == 1)) {
                  $instance = $options{instance_parent} . ($self->{output}->get_instance_perfdata_separator()) . $id;
              } elsif ($multiple_parent == 1 && $multiple == 0) {
                  $instance = $options{instance_parent};
              }
              
              $no_message_multiple = 0;
              $obj->set(instance => $instance);
          
              my ($value_check) = $obj->execute(new_datas => $self->{new_datas},
                                                values => $self->{$options{config}->{name}}->{$id});
              next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
              if ($value_check != 0) {
                  $long_msg .= $long_msg_append . $obj->output_error();
                  $long_msg_append = $message_separator;
                  next;
              }
              my $exit2 = $obj->threshold_check();
              push @exits, $exit2;
  
              my $output = $obj->output();
              $long_msg .= $long_msg_append . $output;
              $long_msg_append = $message_separator;
              
              if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
                  $short_msg .= $short_msg_append . $output;
                  $short_msg_append = $message_separator;
              }
              
              if ($multiple_parent == 1 && $multiple == 0) {
                  $obj->perfdata(extra_instance => 1);
              } else {
                  $obj->perfdata(extra_instance => $multiple);
              }
          }
  
          my ($prefix_output, $suffix_output);
          $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
          $prefix_output = '' if (!defined($prefix_output));
          
          $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
          $suffix_output = '' if (!defined($suffix_output));
  
          my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
          if (scalar @{$self->{maps_counters}->{$options{config}->{name}}} > 0 && $long_msg ne '') {
              $self->{output}->output_add(long_msg => $indent_long_output . $prefix_output . $long_msg . $suffix_output)
                  if (!defined($options{config}->{display_long}) || $options{config}->{display_long} != 0);
          }
          
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->run_multiple_prefix_output(severity => $exit,
                  short_msg => $prefix_output . $short_msg . $suffix_output);
          }
          
          if ($multiple == 0 && $multiple_parent == 0) {
              $self->run_multiple_prefix_output(severity => 'ok', short_msg => $prefix_output . $long_msg . $suffix_output);            
          }
      }
      
      if ($no_message_multiple == 0 && $multiple == 1 && $multiple_parent == 0) {
          $self->{output}->output_add(short_msg => $options{config}->{message_multiple});
      }
  }
  
  sub run_multiple_prefix_output {
      my ($self, %options) = @_;
      
      my %separator;
      if ($self->{prefix_multiple_output_done}->{lc($options{severity})} == 0) {
          $self->{output}->output_add(severity => $options{severity}, short_msg => $self->{prefix_multiple_output});
          $self->{prefix_multiple_output_done}->{lc($options{severity})} = 1;
          $separator{separator} = '';
      }
      
      $self->{output}->output_add(severity => $options{severity}, short_msg => "$options{short_msg}", %separator);
  }
  
  sub run_multiple {
      my ($self, %options) = @_;
  
      my $multiple = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) == 1) {
          $multiple = 0;
      }
      
      if ($multiple == 1) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => $options{config}->{message_multiple});
      }
      
      foreach my $instance (sort keys %{$self->{$options{config}->{name}}}) {
          if (defined($options{config}->{cb_long_output})) {
              $self->{output}->output_add(long_msg => $self->call_object_callback(method_name => $options{config}->{cb_long_output},
                                                                                  instance_value => $self->{$options{config}->{name}}->{$instance}));
          }
          
          $self->{prefix_multiple_output} = '';
          $self->{prefix_multiple_output_done} = { ok => 0, warning => 0, critical => 0, unknown => 0 };
          $self->{prefix_multiple_output} = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}->{$instance})
               if (defined($options{config}->{cb_prefix_output}));
          my $indent_long_output = '';
          $indent_long_output = $options{config}->{indent_long_output}
              if (defined($options{config}->{indent_long_output}));
          
          foreach my $group (@{$options{config}->{group}}) {
              next if (!defined($self->{$options{config}->{name}}->{$instance}->{$group->{name}}));
              $self->{$group->{name}} = $self->{$options{config}->{name}}->{$instance}->{$group->{name}};
              
              if ($group->{type} == 1) {
                  $self->run_multiple_instances(config => $group, multiple_parent => $multiple, instance_parent => $instance, indent_long_output => $indent_long_output);
              } elsif ($group->{type} == 0) {
                  $self->run_global(config => $group, multiple_parent => $multiple, called_multiple => 1, force_instance => $instance, indent_long_output => $indent_long_output);
              }
          }
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      
      $self->manage_selection(%options);
      
      $self->{new_datas} = undef;
      if (defined($self->{statefile_value})) {
          $self->{new_datas} = {};
          $self->{statefile_value}->read(statefile => $self->{cache_name}) if (defined($self->{cache_name}));
          $self->{new_datas}->{last_timestamp} = time();
      }
      
      foreach my $entry (@{$self->{maps_counters_type}}) {
          if ($entry->{type} == 0) {
              $self->run_global(config => $entry);
          } elsif ($entry->{type} == 1) {
              $self->run_instances(config => $entry);
          } elsif ($entry->{type} == 2) {
              $self->run_group(config => $entry);
          } elsif ($entry->{type} == 3) {
              $self->run_multiple(config => $entry);
          }
      }
          
      if (defined($self->{statefile_value})) {
          $self->{statefile_value}->write(data => $self->{new_datas});
      }
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      # example for snmp
      #use Digest::MD5 qw(md5_hex);
      #$self->{cache_name} = "choose_name_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
      #    (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  sub change_macros {
      my ($self, %options) = @_;
  
      foreach (@{$options{macros}}) {
          if (defined($self->{option_results}->{$_})) {
              $self->{option_results}->{$_} =~ s/%\{(.*?)\}/\$self->{result_values}->{$1}/g;
          }
      }
  }
      
  1;
  
  
  =head1 MODE
  
  Default template for counters. Should be extended.
  
  =over 8
  
  =item B<--filter-counters>
  
  Only display some counters (regexp can be used).
  Example to check SSL connections only : --filter-counters='^xxxx|yyyy$'
  
  =item B<--warning-*>
  
  Threshold warning.
  Can be: 'xxx', 'xxx'.
  
  =item B<--critical-*>
  
  Threshold critical.
  Can be: 'xxx', 'xxx'.
  
  =back
  
  =cut
CENTREON_PLUGINS_TEMPLATES_COUNTER

$fatpacked{"centreon/plugins/templates/hardware.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_HARDWARE';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::hardware;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub set_system {
      my ($self, %options) = @_;
      
      # To check with a regexp
      #$self->{regexp_threshold_overload_check_section_option} = '';
      #$self->{cb_threshold_overload_check_section_option} = 'callbackname';
      
      #$self->{regexp_threshold_numeric_check_section_option} = '';
      #$self->{cb_threshold_numeric_check_section_option} = 'callbackname';
      
      # Some callbacks 
      #$self->{cb_hook1} = 'callbackname'; # before the loads
      #$self->{cb_hook2} = 'callbackname'; # between loads and requests
      #$self->{cb_hook3} = 'callbackname'; # after requests
      #$self->{cb_hook4} = 'callbackname'; # after output
      
      # Example for threshold:
      #$self->{thresholds} = {
      #    fan => [
      #        ['bad', 'CRITICAL'],
      #        ['good', 'OK'],
      #        ['notPresent', 'OK'],
      #    ],
      #};
      
      # Unset the call to load components
      #$self->{components_exec_load} = 0;
      
      # Set the path_info
      #$self->{components_path} = 'network::xxxx::mode::components';
      
      # Set the components
      #$self->{components_module} = ['cpu', 'memory', ...];
  }
  
  sub call_object_callback {
      my ($self, %options) = @_;
      
      if (defined($options{method_name})) {
          my $method = $self->can($options{method_name});
          if ($method) {
              return $self->$method(%options);
          }
      }
      
      return undef;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $self->{version} = '1.0';
      $options{options}->add_options(arguments => {
          'component:s'             => { name => 'component', default => '.*' },
          'no-component:s'          => { name => 'no_component' },
          'threshold-overload:s@'   => { name => 'threshold_overload' },
          'add-name-instance'       => { name => 'add_name_instance' },
      });
      
      $self->{performance} = (defined($options{no_performance}) && $options{no_performance} == 1) ?
          0 : 1;
      if ($self->{performance} == 1) {
          $options{options}->add_options(arguments => {
              'warning:s@'     => { name => 'warning' },
              'critical:s@'   => { name => 'critical' },
          });
      }
      
      $self->{filter_exclude} = (defined($options{no_filter_exclude}) && $options{no_filter_exclude} == 1) ?
          0 : 1;
      if ($self->{filter_exclude} == 1) {
          $options{options}->add_options(arguments => {
              'exclude:s'     => { name => 'exclude' },
              'filter:s@'     => { name => 'filter' },
          });
      }
      $self->{absent} = (defined($options{no_absent}) && $options{no_absent} == 1) ?
          0 : 1;
      if ($self->{absent} == 1) {
          $options{options}->add_options(arguments => {
              'absent-problem:s@'       => { name => 'absent_problem' },
          });
      }
      
      $self->{load_components} = (defined($options{no_load_components}) && $options{no_load_components} == 1) ?
          0 : 1;
      $self->{components} = {};
      $self->{no_components} = undef;
      
      $self->{components_module} = [];
      $self->{components_exec_load} = 1;
      $self->set_system();
  
      $self->{count} = (defined($options{no_count}) && $options{no_count} == 1) ?
          0 : 1;
      if ($self->{count} == 1) {
          foreach my $component (@{$self->{components_module}}) {
              $options{options}->add_options(arguments => {
                  'warning-count-' . $component . ':s'    => { name => 'warning_count_' . $component },
                  'critical-count-' . $component . ':s'    => { name => 'critical_count_' . $component },
              });
          }
      }
  
      $self->{request} = [];
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (defined($self->{option_results}->{no_component})) {
          if ($self->{option_results}->{no_component} ne '') {
              $self->{no_components} = $self->{option_results}->{no_component};
          } else {
              $self->{no_components} = 'critical';
          }
      }
      
      if ($self->{filter_exclude} == 1) {
          $self->{filter} = [];
          foreach my $val (@{$self->{option_results}->{filter}}) {
              next if (!defined($val) || $val eq '');
              my @values = split (/,/, $val);
              push @{$self->{filter}}, { filter => $values[0], instance => $values[1] }; 
          }
      }
      
      if ($self->{absent} == 1) {
          $self->{absent_problem} = [];
          foreach my $val (@{$self->{option_results}->{absent_problem}}) {
              next if (!defined($val) || $val eq '');
              my @values = split (/,/, $val);
              push @{$self->{absent_problem}}, { filter => $values[0], instance => $values[1] }; 
          }
      }
      
      $self->{overload_th} = {};
      foreach my $val (@{$self->{option_results}->{threshold_overload}}) {
          next if (!defined($val) || $val eq '');
          my @values = split (/,/, $val);
          if (scalar(@values) < 3) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload option '" . $val . "'.");
              $self->{output}->option_exit();
          }
          my ($section, $instance, $status, $filter);
          if (scalar(@values) == 3) {
              ($section, $status, $filter) = @values;
              $instance = '.*';
          } else {
               ($section, $instance, $status, $filter) = @values;
          }
          if (defined($self->{regexp_threshold_overload_check_section_option}) && 
              $section !~ /$self->{regexp_threshold_overload_check_section_option}/) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload section '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->call_object_callback(method_name => $self->{cb_threshold_overload_check_section_option}, 
                                      section => $section, option_value => $val);
  
          if ($self->{output}->is_litteral_status(status => $status) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload status '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->{overload_th}->{$section} = [] if (!defined($self->{overload_th}->{$section}));
          push @{$self->{overload_th}->{$section}}, {filter => $filter, status => $status, instance => $instance };
      }
      
      if ($self->{performance} == 1) {
          $self->{numeric_threshold} = {};
          foreach my $option (('warning', 'critical')) {
              foreach my $val (@{$self->{option_results}->{$option}}) {
                  next if (!defined($val) || $val eq '');
                  if ($val !~ /^(.*?),(.*?),(.*)$/) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option option '" . $val . "'.");
                      $self->{output}->option_exit();
                  }
                  my ($section, $instance, $value) = ($1, $2, $3);                
                  if (defined($self->{regexp_threshold_numeric_check_section_option}) && 
                      $section !~ /$self->{regexp_threshold_numeric_check_section_option}/) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option option '" . $val . "'.");
                      $self->{output}->option_exit();
                  }   
                  $self->call_object_callback(method_name => $self->{cb_threshold_numeric_check_section_option}, 
                                              section => $section, option_name => $option, option_value => $val);
  
                  my $position = 0;
                  if (defined($self->{numeric_threshold}->{$section})) {
                      $position = scalar(@{$self->{numeric_threshold}->{$section}});
                  }
                  if (($self->{perfdata}->threshold_validate(label => $option . '-' . $section . '-' . $position, value => $value)) == 0) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option threshold '" . $value . "'.");
                      $self->{output}->option_exit();
                  }
                  $self->{numeric_threshold}->{$section} = [] if (!defined($self->{numeric_threshold}->{$section}));
                  push @{$self->{numeric_threshold}->{$section}}, { label => $option . '-' . $section . '-' . $position, threshold => $option, instance => $instance };
              }
          }
      }
      
      if ($self->{count} == 1) {
          foreach my $comp (@{$self->{components_module}}) {
              foreach my $threshold (('warning', 'critical')) {
                  if (($self->{perfdata}->threshold_validate(label => $threshold . '-count-' . $comp, value => $self->{option_results}->{$threshold . '_count_' . $comp})) == 0) {
                      $self->{output}->add_option_msg(short_msg => "Wrong " . $threshold . " threshold '" . $self->{option_results}->{$threshold . '_count_' . $comp} . "'.");
                      $self->{output}->option_exit();
                  }
              }
          }
      }
  }
  
  sub load_components {
      my ($self, %options) = @_;
      
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $mod_name,
                                                     error_msg => "Cannot load module '$mod_name'.") if ($self->{load_components} == 1);
              $self->{loaded} = 1;
              if ($self->{components_exec_load} == 1) {
                  my $func = $mod_name->can('load');
                  $func->($self);
              }
          }
      }
  }
  
  sub exec_components {
      my ($self, %options) = @_;
      
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              my $func = $mod_name->can('check');
              $func->($self); 
          }
      }
  }
  
  sub display {
      my ($self, %options) = @_;
      
      my $total_components = 0;
      my $display_by_component = '';
      my $display_by_component_append = '';
      my $exit = 'OK';
      my $exits = [];
      my ($warn, $crit);
  
      foreach my $comp (sort(keys %{$self->{components}})) {
          # Skipping short msg when no components
          next if ($self->{components}->{$comp}->{total} == 0 && $self->{components}->{$comp}->{skip} == 0);
  
          if ($self->{count} == 1) {
              ($exit, $warn, $crit) = $self->get_severity_count(label => $comp, value => $self->{components}->{$comp}->{total});
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("'%s' components '%s' checked",
                                                              $self->{components}->{$comp}->{total},
                                                              $comp));
              }
              $self->{output}->perfdata_add(
                  label => 'count_' . $comp,
                  nlabel => 'hardware.' . $comp . '.count',
                  value => $self->{components}->{$comp}->{total},
                  warning => $warn,
                  critical => $crit
              );
              push @{$exits}, $exit;
          }
  
          $total_components += $self->{components}->{$comp}->{total} + $self->{components}->{$comp}->{skip};
          my $count_by_components = $self->{components}->{$comp}->{total} + $self->{components}->{$comp}->{skip}; 
          $display_by_component .= $display_by_component_append . $self->{components}->{$comp}->{total} . '/' . $count_by_components . ' ' . $self->{components}->{$comp}->{name};
          $display_by_component_append = ', ';
      }
  
      $exit = $self->{output}->get_most_critical(status => $exits) if (scalar(@{$exits}) > 0);
      
      if ($self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
          $self->{output}->output_add(short_msg => sprintf('All %s components are ok [%s].', 
                                                          $total_components,
                                                          $display_by_component)
                                      );
      }
  
      if (defined($self->{option_results}->{no_component}) && $total_components == 0) {
          $self->{output}->output_add(severity => $self->{no_components},
                                      short_msg => 'No components are checked.');
      }
  }
  
  sub run {
      my ($self, %options) = @_;
  
      $self->{loaded} = 0;  
      $self->call_object_callback(method_name => $self->{cb_hook1}, %options);
  
      $self->load_components(%options);
      if ($self->{loaded} == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong option. Cannot find component '" . $self->{option_results}->{component} . "'.");
          $self->{output}->option_exit();
      }
      
      $self->call_object_callback(method_name => $self->{cb_hook2}, %options);
      $self->exec_components(%options);
      $self->call_object_callback(method_name => $self->{cb_hook3}, %options);
      
      $self->display();
  
      $self->call_object_callback(method_name => $self->{cb_hook4}, %options);
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub check_filter {
      my ($self, %options) = @_;
      
      # Old compatibility variable. We'll be deleted
      if (defined($self->{option_results}->{exclude})) {
          if (defined($options{instance})) {
              if ($self->{option_results}->{exclude} =~ /(^|\s|,)${options{section}}[^,]*#\Q$options{instance}\E#/) {
                  $self->{components}->{$options{section}}->{skip}++;
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section $options{instance} instance."));
                  return 1;
              }
          } elsif (defined($self->{option_results}->{exclude}) && $self->{option_results}->{exclude} =~ /(^|\s|,)$options{section}(\s|,|$)/) {
              $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section."));
              return 1;
          }
      }
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));   
      foreach (@{$self->{filter}}) {
          if ($options{section} =~ /$_->{filter}/) {
              if (!defined($options{instance}) && !defined($_->{instance})) {
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section."));
                  return 1;
              } elsif (defined($options{instance}) && $options{instance} =~ /$_->{instance}/) {
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section $options{instance} instance."));
                  return 1;
              }
          }
      }
      
      return 0;
  }
  
  sub absent_problem {
      my ($self, %options) = @_;
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
      foreach (@{$self->{absent_problem}}) {
          if ($options{section} =~ /$_->{filter}/) {
              if (!defined($_->{instance}) || $options{instance} =~ /$_->{instance}/) {
                  $self->{output}->output_add(severity => 'CRITICAL',
                                              short_msg => sprintf("Component '%s' instance '%s' is not present", 
                                                                   $options{section}, $options{instance}));
                  $self->{output}->output_add(long_msg => sprintf("Skipping $options{section} section $options{instance} instance (not present)"));
                  $self->{components}->{$options{section}}->{skip}++;
                  return 1;
              }
          }
      }
      
      return 0;
  }
  
  sub get_severity_count {
      my ($self, %options) = @_;
      my $status = 'OK'; # default
      my $thresholds = { warning => undef, critical => undef };
      
      $status = $self->{perfdata}->threshold_check(value => $options{value},
                                                   threshold => [ { label => 'critical-count-' . $options{label}, 'exit_litteral' => 'critical' }, 
                                                                  { label => 'warning-count-' . $options{label}, 'exit_litteral' => 'warning' } ]);
      $thresholds->{critical} = $self->{perfdata}->get_perfdata_for_output(label => 'critical-count-' . $options{label});
      $thresholds->{warning} = $self->{perfdata}->get_perfdata_for_output(label => 'warning-count-' . $options{label});
  
      return ($status, $thresholds->{warning}, $thresholds->{critical});
  }
  
  sub get_severity_numeric {
      my ($self, %options) = @_;
      my $status = 'OK'; # default
      my $thresholds = { warning => undef, critical => undef };
      my $checked = 0;
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
      if (defined($self->{numeric_threshold}->{$options{section}})) {
          my $exits = [];
          foreach (@{$self->{numeric_threshold}->{$options{section}}}) {
              if ($options{instance} =~ /$_->{instance}/) {
                  push @{$exits}, $self->{perfdata}->threshold_check(value => $options{value}, threshold => [ { label => $_->{label}, exit_litteral => $_->{threshold} } ]);
                  $thresholds->{$_->{threshold}} = $self->{perfdata}->get_perfdata_for_output(label => $_->{label});
                  $checked = 1;
              }
          }
          $status = $self->{output}->get_most_critical(status => $exits) if (scalar(@{$exits}) > 0);
      }
      
      return ($status, $thresholds->{warning}, $thresholds->{critical}, $checked);
  }
  
  sub get_severity {
      my ($self, %options) = @_;
      my $status = 'UNKNOWN'; # default 
      
      if (defined($self->{overload_th}->{$options{section}})) {
          foreach (@{$self->{overload_th}->{$options{section}}}) {            
              if ($options{value} =~ /$_->{filter}/i && 
                  (!defined($options{instance}) || $options{instance} =~ /$_->{instance}/)) {
                  $status = $_->{status};
                  return $status;
              }
          }
      }
      my $label = defined($options{label}) ? $options{label} : $options{section};
      foreach (@{$self->{thresholds}->{$label}}) {
          if ($options{value} =~ /$$_[0]/i) {
              $status = $$_[1];
              return $status;
          }
      }
      
      return $status;
  }
      
  1;
  
  
  =head1 MODE
  
  Default template for hardware. Should be extended.
  
  =over 8
  
  =item B<--component>
  
  Which component to check (Default: '.*').
  Can be: 'xxx', 'yyy'.
  
  =item B<--filter>
  
  Exclude some parts (comma seperated list) (Example: --filter=xxx --filter=yyyy)
  Can also exclude specific instance: --filter=xxxxx,instancevalue
  
  =item B<--absent-problem>
  
  Return an error if an entity is not 'present' (default is skipping) (comma seperated list)
  Can be specific or global: --absent-problem=xxxx,instancevalue
  
  =item B<--no-component>
  
  Return an error if no compenents are checked.
  If total (with skipped) is 0. (Default: 'critical' returns).
  
  =item B<--threshold-overload>
  
  Set to overload default threshold values (syntax: section,[instance,]status,regexp)
  It used before default thresholds (order stays).
  Example: --threshold-overload='xxxxx,CRITICAL,^(?!(normal)$)'
  
  =item B<--warning>
  
  Set warning threshold for temperatures (syntax: type,instance,threshold)
  Example: --warning='xxxxx,.*,30'
  
  =item B<--critical>
  
  Set critical threshold for temperatures (syntax: type,instance,threshold)
  Example: --critical='xxxxx,.*,40'
  
  =item B<--warning-count-xxxx>
  
  Set warning threshold for component count.
  
  =item B<--critical-count-xxxx>
  
  Set critical threshold for component count.
  
  =back
  
  =cut
CENTREON_PLUGINS_TEMPLATES_HARDWARE

$fatpacked{"centreon/plugins/values.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_VALUES';
  #
  # Copyright 2019 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::values;
  
  use strict;
  use warnings;
  # Warning message with sprintf and too much arguments.
  # Really annoying. Need to disable that warning
  no if ($^V gt v5.22.0), 'warnings' => 'redundant';
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{statefile} = $options{statefile};
      $self->{output} = $options{output};
      $self->{perfdata} = $options{perfdata};
      $self->{label} = $options{label};
      $self->{nlabel} = $options{nlabel};
      $self->{thlabel} = defined($options{thlabel}) ? $options{thlabel} : $self->{label};
  
      $self->{perfdatas} = [];
      
      $self->{output_template} = $self->{label} . ' : %s';
      $self->{output_use} = undef;
      $self->{output_change_bytes} = 0;
      $self->{output_absolute_unit} = '';
      $self->{output_per_second_unit} = '';
      
      $self->{output_error_template} = $self->{label} . ' : %s';
      
      $self->{threshold_use} = undef;
      $self->{threshold_warn} = undef;
      $self->{threshold_crit} = undef;
  
      $self->{per_second} = 0;
      $self->{manual_keys} = 0;
      $self->{last_timestamp} = undef;
  
      $self->{result_values} = {};
      
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel}; 
      
      if (($self->{perfdata}->threshold_validate(label => $warn, value => $options{option_results}->{$warn})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $warn threshold '" . $options{option_results}->{$warn} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => $crit, value => $options{option_results}->{$crit})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $crit threshold '" . $options{option_results}->{$crit} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub set {
      my ($self, %options) = @_;
  
      foreach (keys %options) {
          $self->{$_} = $options{$_};
      }
  }
  
  sub calc {
      my ($self, %options) = @_;
  
      # manage only one value ;)
      foreach my $value (@{$self->{key_values}}) {
          if (defined($value->{diff}) && $value->{diff} == 1) { 
              if (defined($self->{per_second}) && $self->{per_second} == 1) {
                  $self->{result_values}->{$value->{name} . '_per_second'} = ($options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}}) / $options{delta_time};
              }
              $self->{result_values}->{$value->{name} . '_absolute'} = $options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}};
          } else {
              # absolute one. nothing to do. Can be used for values.
              $self->{result_values}->{$value->{name} . '_absolute'} = $options{new_datas}->{$self->{instance} . '_' . $value->{name}};
          }
      }
  
      return 0;
  }
  
  sub threshold_check {
      my ($self, %options) = @_;
      
      if (defined($self->{closure_custom_threshold_check})) {
          return &{$self->{closure_custom_threshold_check}}($self, %options);
      }
      
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel};
      
      my $first = defined($self->{key_values}->[0]) ? $self->{key_values}->[0]->{name} : '';
      my $value;
  
      if (!defined($self->{threshold_use})) {
          $value = $self->{result_values}->{$first . '_absolute'};
          if (defined($self->{per_second}) && $self->{per_second} == 1) {
              $value = $self->{result_values}->{$first . '_per_second'};
          }
      } else {
          $value = $self->{result_values}->{$self->{threshold_use}};
      }
  
      return $self->{perfdata}->threshold_check(value => $value, threshold => [ { label => $crit, 'exit_litteral' => 'critical' },
                                                                                { label => $warn, 'exit_litteral' => 'warning' }]);
  }
  
  sub output_error {
      my ($self, %options) = @_;
      
      return sprintf($self->{output_error_template}, $self->{error_msg});
  }
  
  sub output {
      my ($self, %options) = @_;
       
      if (defined($self->{closure_custom_output})) {
          return $self->{closure_custom_output}->($self);
      }
      my $first = $self->{key_values}->[0]->{name};
      my ($value, $unit) = (defined($first) ? $self->{result_values}->{$first . '_absolute'} : '', $self->{output_absolute_unit});
      
      if (!defined($self->{output_use})) {
          if ($self->{per_second} == 1) {
              $value = $self->{result_values}->{$first . '_per_second'};
              $unit = $self->{output_per_second_unit};
          }
      } else {
          $value = $self->{result_values}->{$self->{output_use}};
      }
  
      if ($self->{output_change_bytes} == 1) {
          ($value, $unit) = $self->{perfdata}->change_bytes(value => $value);
      } elsif ($self->{output_change_bytes} == 2) {
          ($value, $unit) = $self->{perfdata}->change_bytes(value => $value, network => 1);
      }
      
      return sprintf($self->{output_template}, $value, $unit);
  }
  
  sub use_instances {
      my ($self, %options) = @_;
  
      if (!defined($options{extra_instance}) || $options{extra_instance} != 0 || $self->{output}->use_new_perfdata()) {
          return 1;
      }
      
      return 0;
  }
  
  sub perfdata {
      my ($self, %options) = @_;
      
      if (defined($self->{closure_custom_perfdata})) {
          return &{$self->{closure_custom_perfdata}}($self, %options);
      }
      
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel}; 
      
      foreach my $perf (@{$self->{perfdatas}}) {
          my ($label, $extra_label, $min, $max, $th_total) = ($self->{label}, '');
          my $cast_int = (defined($perf->{cast_int}) && $perf->{cast_int} == 1) ? 1 : 0;
          my $template = '%s';
          
          $template = $perf->{template} if (defined($perf->{template}));
          $label = $perf->{label} if (defined($perf->{label}));
          if (defined($perf->{min})) {
              $min = ($perf->{min} =~ /[^0-9]/) ? $self->{result_values}->{$perf->{min}} : $perf->{min};
          }
          if (defined($perf->{max})) {
              $max = ($perf->{max} =~ /[^0-9]/) ? $self->{result_values}->{$perf->{max}} : $perf->{max};
          }
          if (defined($perf->{threshold_total})) {
              $th_total = ($perf->{threshold_total} =~ /[^0-9]/) ? $self->{result_values}->{$perf->{threshold_total}} : $perf->{threshold_total};
          }
          
          my $instances;
          if (defined($perf->{label_extra_instance}) && $perf->{label_extra_instance} == 1) {
              my $instance = '';
              if (defined($perf->{instance_use})) {
                  $instance = $self->{result_values}->{$perf->{instance_use}};
              } else {
                  $instance = $self->{instance};
              }
              
              if (!defined($options{extra_instance}) || $options{extra_instance} != 0 || $self->{output}->use_new_perfdata()) {
                  $instances = $instance;
              }
          }
  
          $self->{output}->perfdata_add(
              label => $label,
              instances => $instances,
              nlabel => $self->{nlabel},
              unit => $perf->{unit},
              value => $cast_int == 1 ? int($self->{result_values}->{$perf->{value}}) : sprintf($template, $self->{result_values}->{$perf->{value}}),
              warning => $self->{perfdata}->get_perfdata_for_output(label => $warn, total => $th_total, cast_int => $cast_int),
              critical => $self->{perfdata}->get_perfdata_for_output(label => $crit, total => $th_total, cast_int => $cast_int),
              min => $min, max => $max
          );
      }
  }
  
  sub execute {
      my ($self, %options) = @_;
      my $old_datas = {};
  
      $self->{result_values} = {},
      $self->{error_msg} = undef;
      my $quit = 0;
      my $per_second = 0;
      
      $options{new_datas} = {} if (!defined($options{new_datas}));
      foreach my $value (@{$self->{key_values}}) {
          if (!defined($options{values}->{$value->{name}}) || 
              defined($value->{no_value}) && $options{values}->{$value->{name}} eq $value->{no_value}) {
              $quit = 2;
              last;
          }
      
          if (defined($value->{diff}) && $value->{diff} == 1) {            
              $options{new_datas}->{$self->{instance} . '_' . $value->{name}} = $options{values}->{$value->{name}};
              $old_datas->{$self->{instance} . '_' . $value->{name}} = $self->{statefile}->get(name => $self->{instance} . '_' . $value->{name});
              if (!defined($old_datas->{$self->{instance} . '_' . $value->{name}})) {
                  $quit = 1;
                  next;
              }
              if ($old_datas->{$self->{instance} . '_' . $value->{name}} > $options{new_datas}->{$self->{instance} . '_' . $value->{name}}) {
                  $old_datas->{$self->{instance} . '_' . $value->{name}} = 0;
              }
          } else {
              $options{new_datas}->{$self->{instance} . '_' . $value->{name}} = $options{values}->{$value->{name}};
              if (defined($self->{statefile})) {
                  $old_datas->{$self->{instance} . '_' . $value->{name}} = $self->{statefile}->get(name => $self->{instance} . '_' . $value->{name});
              }
          }
      }
      
      # Very manual
      if ($self->{manual_keys} == 1) {
          foreach my $name (keys %{$options{values}}) {
              $options{new_datas}->{$self->{instance} . '_' . $name} = $options{values}->{$name};
              if (defined($self->{statefile})) {
                  $old_datas->{$self->{instance} . '_' . $name} = $self->{statefile}->get(name => $self->{instance} . '_' . $name);
              }
          }
      }
  
      if ($quit == 2) {
          $self->{error_msg} = "skipped (no value(s))";
          return -10;
      }
      
      if ($quit == 1) {
          $self->{error_msg} = "Buffer creation";
          return -1;
      }
      
      if (defined($self->{per_second}) && $self->{per_second} == 1) {
          if (!defined($self->{last_timestamp})) {
              $self->{last_timestamp} = $self->{statefile}->get(name => 'last_timestamp');
          }
          if (!defined($self->{last_timestamp})) {
              $self->{error_msg} = "Buffer creation";
              return -1;
          }
      }
     
      my $delta_time;
      if (defined($self->{per_second}) && $self->{per_second} == 1) {
          $delta_time = $options{new_datas}->{last_timestamp} - $self->{last_timestamp};
          if ($delta_time <= 0) {
              $delta_time = 1;
          }
      }
  
      if (defined($self->{closure_custom_calc})) {
          return $self->{closure_custom_calc}->($self, old_datas => $old_datas, new_datas => $options{new_datas}, delta_time => $delta_time, extra_options => $self->{closure_custom_calc_extra_options});
      }
      return $self->calc(old_datas => $old_datas, new_datas => $options{new_datas}, delta_time => $delta_time);
  }
  
  1;
  
  
CENTREON_PLUGINS_VALUES

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#
# Copyright 2019 Centreon (http://www.centreon.com/)
#
# Centreon is a full-fledged industry-strength solution that meets
# the needs in IT infrastructure and application monitoring for
# service performance.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

use strict;
use warnings;
# Not perl embedded compliant at all
use FindBin;
use lib "$FindBin::Bin";
# use lib '/usr/lib/nagios/plugins/';

use centreon::plugins::script;

centreon::plugins::script->new()->run();
